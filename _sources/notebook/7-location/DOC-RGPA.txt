
Robust Geometric Positioning Algorithm

.. code-block:: python

    from pylayers.location.geometric.constraints.cla import *
    from pylayers.location.geometric.constraints.toa import *
    from pylayers.location.geometric.constraints.tdoa import *
    from pylayers.location.geometric.constraints.rss import *
    from pylayers.network.model import *
    
    import matplotlib.pyplot as plt

Let's define 4 anchors in the plane.

.. code-block:: python

    pt1=np.array(([0,0]))
    pt2=np.array(([10,15]))
    pt3=np.array(([5,28]))
    pt4=np.array(([-10,-10]))
    # the unknown point is p
    p = np.array((0,5))
Then displaying the scene with ancho nodes (in red) and blind nodes in
blue

.. code-block:: python

    f=plt.figure()
    ax=f.add_subplot(111)
    ax.plot(pt1[0],pt1[1],'or',label='anchor 1')
    ax.plot(pt2[0],pt2[1],'or',label='anchor 2')
    ax.plot(pt3[0],pt3[1],'or',label='anchor 3')
    ax.plot(pt4[0],pt4[1],'or',label='anchor 4')
    ax.plot(p[0],p[1],'xb',label='p')
    
    
    ax.legend(loc='best')



.. parsed-literal::

    <matplotlib.legend.Legend at 0x489f990>




.. image:: DOC-RGPA_files/DOC-RGPA_5_1.png


The euclidian distance betwenn blind node :math:`$p$` and anchors ans
the corresponding Time of flight are evaluated.

.. code-block:: python

    d1=np.sqrt(np.sum((pt1-p)**2))
    d2=np.sqrt(np.sum((pt2-p)**2))
    d3=np.sqrt(np.sum((pt3-p)**2))
    d4=np.sqrt(np.sum((pt4-p)**2))
    
    toa1=d1/0.3
    toa2=d2/0.3
    toa3=d3/0.3
    toa4=d4/0.3
    
    print 'distance p-1=',d1, '/ toa1=',toa1
    print 'distance p-2=',d2, '/ toa2=',toa2
    print 'distance p-3=',d3, '/ toa3=',toa3
    print 'distance p-4=',d4, '/ toa3=',toa4

.. parsed-literal::

    distance p-1= 5.0 / toa1= 16.6666666667
    distance p-2= 14.1421356237 / toa2= 47.1404520791
    distance p-3= 23.5372045919 / toa3= 78.4573486396
    distance p-4= 18.0277563773 / toa3= 60.0925212577


RGPA (Robust Geometric Positioning Algorithm)
=============================================


Exploiting Time of Arrival (ToA) only
-------------------------------------


We call ``Constraint Layer Array`` (CLA) the object which gathers all
the geometric constraints of a considered scenario.

.. code-block:: python

    C=CLA()
Instanciate TOA constraints, notice that their id are differents

.. code-block:: python

    T1=TOA(id=0,value = toa1, std = np.array([1.0]), p = pt1)
    T2=TOA(id=1,value = toa2, std = np.array([1.0]), p = pt2)
    T3=TOA(id=2,value = toa3, std = np.array([1.0]), p = pt3)
    T4=TOA(id=3,value = toa4, std = np.array([1.0]), p = pt4)
Add TOA contraints to the CLA

.. code-block:: python

    C.append(T1)
    C.append(T2)
    C.append(T3)
    C.append(T4)
All the constraints of the CLA can be listed as follows

.. code-block:: python

    C.c



.. parsed-literal::

    [<pylayers.location.geometric.constraints.toa.TOA at 0x47cb210>,
     <pylayers.location.geometric.constraints.toa.TOA at 0x47cb810>,
     <pylayers.location.geometric.constraints.toa.TOA at 0x47cbfd0>,
     <pylayers.location.geometric.constraints.toa.TOA at 0x47cb5d0>]



Get information on the cla :

-  type : TOA / RSS
-  p : Position of the origin of the constraint
-  value : power ( RSS ) / time in ns ( TOA)
-  std : standard deviation :math:`$\sigma^2$` of value
-  runable : does the constraint has a position p ?
-  obsolete : does the value has been obtained recently ?
-  usuable : runbale AND NOT obsolete
-  evlauated : obsolete


.. code-block:: python

    C.info()

.. parsed-literal::

    type , p         , value     , std    , runable, usable, obsolete, evaluated
    TOA , [0 0]     , 16.6666666667, [ 1.]  , 1, 1, 0, 0
    type , p         , value     , std    , runable, usable, obsolete, evaluated
    TOA , [10 15]   , 47.1404520791, [ 1.]  , 1, 1, 0, 0
    type , p         , value     , std    , runable, usable, obsolete, evaluated
    TOA , [ 5 28]   , 78.4573486396, [ 1.]  , 1, 1, 0, 0
    type , p         , value     , std    , runable, usable, obsolete, evaluated
    TOA , [-10 -10] , 60.0925212577, [ 1.]  , 1, 1, 0, 0


Update the CLA

.. code-block:: python

    C.update()
Compute the cla

.. code-block:: python

    C.compute()



.. parsed-literal::

    True



show the estimated position

.. code-block:: python

    C.pe



.. parsed-literal::

    array([ -4.735e-03,   4.992e+00])



to be compare with the actual position value

.. code-block:: python

    p



.. parsed-literal::

    array([0, 5])



RSS
---


The RSS is a quantity which is weakly related to distance via a
parametric model. The bettet the model, better would be tthe inference
ab out tthe associated distance. t To model the Path Loss shadowing
model is widely used.

To define the classical path loss shadowing model widely used in this
context the ``PLSmodel`` class has been defined.

.. code-block:: python

    M = PLSmodel(f=3.0,rssnp=2.64,d0=1.0,sigrss=3.0,method='mode')
For simulation purpose : get RSS from distances (or associated delay)
with the above model

.. code-block:: python

    toa1



.. parsed-literal::

    16.666666666666668



.. code-block:: python

    M.getPL(toa1,1)



.. parsed-literal::

    7.1990008820632072



TDOA
----


.. code-block:: python

    Td1=TDOA(id=0,value = toa1-toa2, std = np.array([1.0]), p = np.array([pt1,pt2]))
    Td2=TDOA(id=1,value = toa1-toa3, std = np.array([1.0]), p = np.array([pt1,pt3]))
    Td3=TDOA(id=2,value = toa1-toa4, std = np.array([1.0]), p = np.array([pt1,pt4]))

.. code-block:: python

    C=CLA()
    C.append(Td1)
    C.append(Td2)
    C.append(Td3)
.. code-block:: python

    C.compute()

.. parsed-literal::

    TDOA 2.0
    TDOA 2.0
    TDOA 2.0
    TDOA 1.5
    TDOA 1.5
    TDOA 1.5
    TDOA 1.375
    TDOA 1.375
    TDOA 1.375
    TDOA 1.375
    TDOA 1.375
    TDOA 1.375




.. parsed-literal::

    True



.. code-block:: python

    C.pe



.. parsed-literal::

    array([ 0.021,  4.987])



.. code-block:: python

    from IPython.core.display import HTML
    
    def css_styling():
        styles = open("../styles/custom.css", "r").read()
        return HTML(styles)
    css_styling()



.. raw:: html

    <style>
        @font-face {
            font-family: "Computer Modern";
            src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunss.otf');
        }
        div.cell{
            width:800px;
            margin-left:16% !important;
            margin-right:auto;
        }
        h1 {
            font-family: Helvetica, serif;
        }
        h4{
            margin-top:12px;
            margin-bottom: 3px;
           }
        div.text_cell_render{
            font-family: Computer Modern, "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;
            line-height: 145%;
            font-size: 130%;
            width:800px;
            margin-left:auto;
            margin-right:auto;
        }
        .CodeMirror{
                font-family: "Source Code Pro", source-code-pro,Consolas, monospace;
        }
        .prompt{
            display: None;
        }
        .text_cell_render h5 {
            font-weight: 300;
            font-size: 22pt;
            color: #4057A1;
            font-style: italic;
            margin-bottom: .5em;
            margin-top: 0.5em;
            display: block;
        }
        
        .warning{
            color: rgb( 240, 20, 20 )
            }  
    </style>
    <script>
        MathJax.Hub.Config({
                            TeX: {
                               extensions: ["AMSmath.js"]
                               },
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
                    },
                    displayAlign: 'center', // Change this to 'center' to center equations.
                    "HTML-CSS": {
                        styles: {'.MathJax_Display': {"margin": 4}}
                    }
            });
    </script>


