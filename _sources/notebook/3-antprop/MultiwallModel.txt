
Multi-wall model
================

.. code-block:: python

    import time
    from pylayers.util.project import *
    import pylayers.util.pyutil as pyu
    from pylayers.util.utilnet import str2bool
    from pylayers.gis.layout import Layout
    from pylayers.antprop.multiwall import *
    from pylayers.antprop.coverage import *
    from pylayers.network.model import *


.. parsed-literal::

    <matplotlib.figure.Figure at 0x442c850>


The layout is loaded from an ini file. If the graphs are not available,
they are built.

.. code-block:: python

    L=Layout('TA-Office.ini')
Defining a radio link
---------------------

The 2 extremities of the radio link are coordinates in ``numpy.array``
of transmitter and receiver.

-  A a radio node

-  B a radio node

.. code-block:: python

    A=np.array((4,1)) # defining transmitter position 
    B=np.array((30,12)) # defining receiver position
Ploting the scene
-----------------

The scene is plotted with the ``showG`` method of the Layout

.. code-block:: python

    # figure instanciation
    f = plt.figure(figsize=(25,25))
    ax = f.add_subplot(111)
    r = np.array((A,B))
    # plotting the Layout
    f,ax = L.showG(fig=f,ax=ax,graph='s',nodes=False)
    # plotting the Tx and Rx
    ax.plot(A[0],A[1],'ob')
    ax.plot(B[0],B[1],'or')
    # plotting the LOS
    ax.plot(r[:,0],r[:,1])
    a = plt.axis('off')


.. image:: MultiwallModel_files/MultiwallModel_9_0.png


Finding the intersection between the "direct" path and the walls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The function ``angleonlink`` returns the list of intersected segments
and the corresponding incidence angles (in radians) with respect to the
segment normal.

.. code-block:: python

    %pdef L.angleonlink

.. parsed-literal::

     [0mL[0m[1;33m.[0m[0mangleonlink[0m[1;33m([0m[0mself[0m[1;33m,[0m [0mp1[0m[1;33m=[0m[0marray[0m[1;33m([0m[1;33m[[0m[1;36m0[0m[1;33m,[0m [1;36m0[0m[1;33m][0m[1;33m)[0m[1;33m,[0m [0mp2[0m[1;33m=[0m[0marray[0m[1;33m([0m[1;33m[[0m[1;36m10[0m[1;33m,[0m  [1;36m3[0m[1;33m][0m[1;33m)[0m[1;33m)[0m[1;33m[0m[0m
     

.. code-block:: python

    data=L.angleonlink(A,B)
Computing the Multi-wall model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The multi-wall model computation returns losses and LOS excess delay for
orthogonal and parallel polarization

.. code-block:: python

    fGHz = 2.4
    # observation grid
    
    r = np.array((B,B))
    
    Lwo,Lwp,Edo,Edp = Losst(L,fGHz,r.T,A)
    
    print 'Losses orthogonal polarization \t %g dB' %(Lwo[0][0])
    print 'Losses parallel polarization \t %g  dB' % (Lwp[0][0])
    print 'Excess delay orthogonal polarization  \t %g ns' %(Edo[0][0])
    print 'Excess delay parallel polarization   \t %g ns' %(Edp[0][0])

.. parsed-literal::

    Losses orthogonal polarization 	 27.7333 dB
    Losses parallel polarization 	 16.0573  dB
    Excess delay orthogonal polarization  	 2.23113 ns
    Excess delay parallel polarization   	 2.12364 ns


Coverage class
==============

By extension, the multi-wall model can also be used to perform a full
coverage of a Layout given a transmitter position.

.. code-block:: python

    C = Coverage()
    C.L  = L # set layout
    C.tx = A # set the transmitter
.. code-block:: python

    C.L



.. parsed-literal::

    
    ----------------
    TA-Office.ini
    Image('/home/uguen/Bureau/P1/struc/images/DLR4991.png')
    ----------------
    
    Number of points  : 71
    Number of segments  : 87
    Number of sub segments  : 16
    Number of cycles  : 0
    Number of rooms  : 0
    degree 0 : []
    degree 1 : []
    degree 2 : 39
    degree 3 : 32
    
    xrange :(0.0, 40.0)
    yrange :(0.0, 15.0)
    
    Useful dictionnaries
    ----------------
    sl {slab name : slab dictionary}
    name :  {slab :seglist} 
    
    Useful arrays
    ----------------
    tsg : get segment index in Gs from tahe
    isss :  sub-segment index above Nsmax
    tgs : get segment index in tahe from Gs
    lsss : list of segments with sub-segment
    sla : list of all slab names (Nsmax+Nss+1)
    degree : degree of nodes 



.. code-block:: python

    C.creategrid()
The coverage is performed on grid. The boundaries can be specified in
the coverage.ini file

.. code-block:: python

    C.grid



.. parsed-literal::

    array([[  1.00000000e-02,   1.00000000e-02],
           [  1.00000000e-02,   3.94102564e-01],
           [  1.00000000e-02,   7.78205128e-01],
           ..., 
           [  3.99900000e+01,   1.42217949e+01],
           [  3.99900000e+01,   1.46058974e+01],
           [  3.99900000e+01,   1.49900000e+01]])



Compute the coverage
~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    t1=time.time()
    C.cover()
    t2=time.time()
    print 'Coverage performed in ', t2-t1, 's'

.. parsed-literal::

    Coverage performed in  1.38903713226 s


Coverage Map
~~~~~~~~~~~~

For Orthogonal polarization

.. code-block:: python

    fig1=plt.figure(figsize=(10,10))
    C.showPower(polar='o',fig=fig1)
    
    fig2=plt.figure(figsize=(10,10))
    C.showEd(polar='o',fig=fig2)



.. image:: MultiwallModel_files/MultiwallModel_26_0.png



.. image:: MultiwallModel_files/MultiwallModel_26_1.png




.. parsed-literal::

    (<matplotlib.figure.Figure at 0x7f5bd0b77c50>,
     <matplotlib.axes.AxesSubplot at 0x7f5bd09b8650>)



For parallel polarization

.. code-block:: python

    fig1=plt.figure(figsize=(10,10))
    C.showPower(polar='p',fig=fig1)
    
    fig2=plt.figure(figsize=(10,10))
    C.showEd(polar='p',fig=fig2)


.. image:: MultiwallModel_files/MultiwallModel_28_0.png



.. image:: MultiwallModel_files/MultiwallModel_28_1.png




.. parsed-literal::

    (<matplotlib.figure.Figure at 0x7f5bd0d65d90>,
     <matplotlib.axes.AxesSubplot at 0x7f5bd0d60950>)



.. code-block:: python

    from IPython.core.display import HTML
    
    def css_styling():
        styles = open("../styles/custom.css", "r").read()
        return HTML(styles)
    css_styling()



.. raw:: html

    <style>
        @font-face {
            font-family: "Computer Modern";
            src: url('http://mirrors.ctan.org/fonts/cm-unicode/fonts/otf/cmunss.otf');
        }
        div.cell{
            width:800px;
            margin-left:16% !important;
            margin-right:auto;
        }
        h1 {
            font-family: Helvetica, serif;
        }
        h4{
            margin-top:12px;
            margin-bottom: 3px;
           }
        div.text_cell_render{
            font-family: Computer Modern, "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;
            line-height: 145%;
            font-size: 130%;
            width:800px;
            margin-left:auto;
            margin-right:auto;
        }
        .CodeMirror{
                font-family: "Source Code Pro", source-code-pro,Consolas, monospace;
        }
        .prompt{
            display: None;
        }
        .text_cell_render h5 {
            font-weight: 300;
            font-size: 22pt;
            color: #4057A1;
            font-style: italic;
            margin-bottom: .5em;
            margin-top: 0.5em;
            display: block;
        }
        
        .warning{
            color: rgb( 240, 20, 20 )
            }  
    </style>
    <script>
        MathJax.Hub.Config({
                            TeX: {
                               extensions: ["AMSmath.js"]
                               },
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
                    },
                    displayAlign: 'center', // Change this to 'center' to center equations.
                    "HTML-CSS": {
                        styles: {'.MathJax_Display': {"margin": 4}}
                    }
            });
    </script>


