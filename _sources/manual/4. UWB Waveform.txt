In[29]:

.. code:: python

    from pylayers.signal.bsignal import *
    from pylayers.simul.simulem import *
    figsize(8,8)

Generation of an Impulse of normalized energy
=============================================

One possible manner to define an ernergy normalized short UWB impulse is
as follows.

:math:`p(t)= \frac{\sqrt{2\sqrt{2}}}{\tau\sqrt{\pi}} \cos(2\pi f_c t) e^{-(\frac{t}{\tau})^2}`

:math:`\tau = \frac{2}{B\pi}\sqrt{\frac{\gamma_{dB}\ln{10}}{20}}`

where :math:`B` is the desired bandwidth defined at
:math:`\gamma_{dB}` below the spectrum maximum and :math:`f_c` is
the central frequency of the pulse.

This waveform is a gaussian windowing of a sine wave of frequency
:math:`f_c`. The normalization term depends on the exponential scaling
factor :math:`\tau`.

In[30]:

.. code:: python

    fc     = 4 
    band   = 2
    thresh = 10
    fe     = 100 
    ip =EnImpulse([],fc,band,thresh,fe)

In[31]:

.. code:: python

    ip.info()

.. parsed-literal::

    TUsignal
    --------
    shx :  (343,)
    shy :  (343,)
    dx :   0.01
    xmin : -1.71
    xmax : 1.71
    ymin : -1.89545539648
    ymax : 2.16154131873


Verification of energy normalization in both domains
----------------------------------------------------


In[32]:

.. code:: python

    E1= sum(ip.y*ip.y)*ip.dx()
    print "Integration in time",E1

.. parsed-literal::

    Integration in time 1.0


In[33]:

.. code:: python

    P = ip.esd()
    E2 = sum(P.y)*P.dx()
    print "Integration in frequency domain ",E2

.. parsed-literal::

    Integration in frequency domain  1.0


Calcul of UWB channel impulse response
--------------------------------------


In[34]:

.. code:: python

    S= Simul()
    S.load('where2.ini')

In[35]:

.. code:: python

    st = S.wav.st
    sf = S.wav.sf
    S.wav.info()

.. parsed-literal::

    tw  :  30.0
    band  :  4.0
    fc  :  4.493
    thresh  :  3.0
    fe  :  50.0
    Np  :  1500.0
    te  :  0.02
    type  :  file


Here the time domain waveform is measured and the anticausal part of the
signal is artificially set to 0.

To handle properly the time domain wavefom it is required to center the
signal in the middle of the array.

``st`` stands for signal in time domain

Ploting the waveform
--------------------

In time domain
--------------

In[36]:

.. code:: python

    S.wav.st.plot()


.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_00.png

in frequency domain 
--------------------

The frequency domain version of the signal is embedded in the same
object.

``sf`` stands for signal in frequency domain.

In[37]:

.. code:: python

    f,ax=S.wav.sf.plot()

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_01.png

Construction of the propagation channel 
----------------------------------------

The link between Txid = 1 and Rxid =1 is simply loaded as

In[38]:

.. code:: python

    vc = S.VC(1,1)

.. parsed-literal::

    nray :  500
    nfreq :  181
    nb rays in .tauk file:  500
    nb rays 2:  500


The following representation shows the spatial spreading of the
propagation channel. On the left are scattered the intensity of rays wrt
to angles of departure (in azimut and elevation). On the right is the
intensity of rays wrt to angles of arrival. It misses the application
between the 2 planes as well as the delay dimension of the propagation
channel.

In[39]:

.. code:: python

    vc.doadod()

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_02.png

Construction of the transmission channel
----------------------------------------


The transmission channel is obtain from the combianation of the
propagation channel and the vector antenna pattern at bot side of the
radio link

In[40]:

.. code:: python

    sc = vc.vec2scal()

The ScalChannel object contains all the information about the ray
transfer functions. The transmission channel is obtained by applying a
vector radiation pattern using an antenna file. In the presented case,
it comes from a real antenna which has been used during the FP7 WHERE1
measurement campaign M1.

In[41]:

.. code:: python

    S.tx.A.info()

.. parsed-literal::

    defant.vsh3
    type :  vsh3
    --------------------------
    fmin (GHz) : 2.0
    fmax (GHz) : 8.0
    Nf   : 121
    Br
    -------------
    Nf   :  121
    fmin (GHz) :  2.0
    fmax (GHz) :  8.0
    Ncoeff s3 :  18
    Bi
    -------------
    Nf   :  121
    fmin (GHz) :  2.0
    fmax (GHz) :  8.0
    Ncoeff s3 :  18
    Cr
    -------------
    Nf   :  121
    fmin (GHz) :  2.0
    fmax (GHz) :  8.0
    Ncoeff s3 :  18
    Ci
    -------------
    Nf   :  121
    fmin (GHz) :  2.0
    fmax (GHz) :  8.0
    Ncoeff s3 :  18


In[42]:

.. code:: python

    f,ax=sc.H.plot()


.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_03.png

The antenna can also been taken into account

In[43]:

.. code:: python

    alpha = 1./sqrt(30)  # scaling constant depends on how are stored the antenna data
    sca = vc.vec2scalA(S.tx.A,S.rx.A,alpha)
    sca.H.plot()

Out[43]:

.. parsed-literal::

    (<matplotlib.figure.Figure at 0xb1c9b2c>,
     array([Axes(0.125,0.547727;0.775x0.352273),
           Axes(0.125,0.125;0.775x0.352273)], dtype=object))

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_04.png

Calculate UWB Channel Impulse Response
--------------------------------------


In[44]:

.. code:: python

    cir = sc.applywavB(S.wav.sfg)

In[45]:

.. code:: python

    cir.plot()

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_05.png

Hermitian symetry enforcment 
-----------------------------

If the number of point for the transmission channel and the waveform
were the same the mathematical operation is an Hadamrd-Shur product
between :math:`$\mathbf{Y}$` and :math:`$\mathbf{W}$`.

:math:`$\mathbf{Y} = \mathbf{S} \odot \mathbf{W}$`

In practice this is what is done after a resampling of the time base
with the greater time step.

The process whic consist in going time domain to frequency domain is
delegate to a specialized class which maintain the proper binding
between signal samples and their indexation either in time or in
frequency domain.

In[46]:

.. code:: python

    wgam = S.wav.sfg
    Y    = sc.apply(wgam)
    tau  = Y.tau0

The transmission channel has a member data which is the time delay of
each path

In[47]:

.. code:: python

    print 'tau =', tau

.. parsed-literal::

    tau = [ 23.86713221  25.90353456  26.71456706  31.5656444   36.76975426
      33.13220501  29.70841516  33.77007551  38.12306298  38.67871406
      27.8861973   27.64609677  40.8039797   36.1848012   44.63339207
      40.97791791  26.00589677  56.03851137  56.50109556  28.40727606
      45.75470239  46.21869515  28.64099626  31.45147939  56.93564665
      57.39100019  57.30918643  57.76159531  49.6141571   31.23879355
      45.89051822  25.74826855  34.70312186  34.5104815   48.01134886
      59.20577447  58.76448492  39.86471567  35.1232117   45.28595588
      40.03159863  35.31250959  46.67807592  55.69281322  33.21104234
      65.58905058  65.1909849   33.00969555  41.92951758  63.97682332
      64.44036847  43.69434237  42.08821424  43.38811921  42.01423039
      37.6279447   53.22774303  37.45035232  41.69566991  69.27701651
      69.74102761  46.85683446  54.41707085  49.77517159  64.76408746
      65.22203762  51.0450064   65.09271861  65.54837284  70.4639201
      70.0047007   70.76608669  70.30884091  42.25683377  42.09877275
      48.44775243  38.19069113  39.32593151  50.54234748  66.37758547
      66.8244792   50.67407841  71.94971066  71.5000346   68.36337908
      67.98156041  46.89321202  45.5860115   59.98403491  47.21435752
      38.01572774  39.49509112  69.29340929  58.934858    59.54859827
      45.29257972  47.03516415  60.09507282  60.01118612  59.6604466
      47.35534699  48.9702404   58.11322282  58.55933363  72.12893787
      72.54040836  49.10618879  77.28751962  76.86907554  58.2278284
      58.67306783  51.16678171  66.29124293  58.31307211  43.20334349
      50.48955888  65.89749616  66.39173309  77.23599638  77.70053523
      56.52016356  55.17961088  56.97789045  42.89361517  65.99858584
      45.809703    56.63799275  88.72342731  89.65357417  89.18849218
      77.88935896  78.35002411  56.86076562  78.16282511  49.04279311
      78.62188797  55.26377154  46.30185981  54.0932939   45.66394152
      46.44561934  46.76033457  57.99665686  55.38427374  50.24950477
      54.21639768  47.80371906  89.29277494  90.21705196  89.75488978
      89.5314171   90.45325563  72.3931858   89.99230651  79.65543756
      47.66405587  79.24949727  72.0327308   50.70038352  75.90628341
      80.45504151  75.51315577  57.43282066  64.89406137  50.83170489
      67.51358711  70.66550806  67.0713716   58.19389048  51.94736653
      63.56523608  57.74495649  79.2360339   79.68891458  46.90268886
      69.03683397  67.61226056  68.6588345   67.17069467  52.07554342
      68.1027834   69.13333333  68.7558644   69.95773327  91.38223729
      90.46986507  57.31662547  90.92599776  70.05296409  66.25100419
      52.13525146  84.11271541  84.53947558  47.98186891  59.71670155
      82.66784744  77.88221877  82.35237675  66.35155529  77.46706827
      60.77898028  73.17464649  95.64158676  94.77022903  95.20576082
      57.86029151  58.3083375   59.82823562  72.76684227  77.96777112
      77.5530786   65.80030395  60.88856853  72.14362219  73.26569608
      71.41643135  70.96346478  75.05823665  72.58922479  62.36672794
      72.85840148  61.27669898  64.79979424  70.03675226  72.23597134
      90.45565753  90.44995498  89.97290449  65.90154272  83.13970461]


symHz force the Hermitian symetry of Y with zero padding of 500

In[48]:

.. code:: python

    UH   = Y.symHz(500)
    
    UH.plot()


Out[48]:

.. parsed-literal::

    (<matplotlib.figure.Figure at 0xb3d356c>,
     array([Axes(0.125,0.547727;0.775x0.352273),
           Axes(0.125,0.125;0.775x0.352273)], dtype=object))

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_06.png

In[49]:

.. code:: python

    uh   = UH.ifft(1)
    uh.plot()

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_07.png

In[50]:

.. code:: python

    ips  = Y.ift(500,1)
    t    = ips.x 
    ip0  = TUsignal(t,ips.y[0,:])

In[51]:

.. code:: python

    plot(UH.x,real(UH.y[0,:]),UH.x,imag(UH.y[0,:]))
    U0 = FHsignal(UH.x,UH.y[0,:])
    u0 = U0.ifft(1)
    u1 = ifft(U0.y)
    plt.figure()


Out[51]:

.. parsed-literal::

    <matplotlib.figure.Figure at 0xb391fcc>

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_08.png

In[52]:

.. code:: python

    plot(uh.x,uh.y[0,:]*1000+3)


Out[52]:

.. parsed-literal::

    [<matplotlib.lines.Line2D at 0xc247c2c>]

.. image:: 4__UWB_Waveform_files/4__UWB_Waveform_fig_09.png
