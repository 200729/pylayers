Example of a trajectory synthesis in DLR WHERE2 environment 
------------------------------------------------------------


.. code-block:: python

    from pylayers.simul.simulem import *
    from pylayers.antprop.rays import *
    from pylayers.antprop.channel import *
    from pylayers.antprop.signature import *
    import pylayers.util.pyutil as pyu
    from pylayers.gis.layout import *
    from pylayers.util.project import *
    import pylayers.signal.bsignal as bs
    from datetime import datetime
    import time
    import pdb
    import pickle
    import numpy as np
    import matplotlib.pyplot as plt 

.. parsed-literal::

    <matplotlib.figure.Figure at 0x4073610>

This function has to be moved in simulem module. It is a temporary
implementation. Signatures can be handled much more efficiently here. It
run a full simulation and returns a list of channel impulse response.


.. code-block:: python

    def evalcir(S,wav,cutoff=4):
        """
        Parameters
        ----------
    
        S 
        tx
        rx
        wav
        cutoff
    
        """
    
        crxp =-1
        ctxp =-1
        tcir = {}
        tx = S.tx.position 
        Ntx = len(tx[0])
        rx = S.rx.position
        Nrx = len(rx[0])
    
        #for kt in range(1,Ntx-1):
        #print kt+1
        kt=0
        tcir[kt+1] = {}
        t = np.array([S.tx.position[0,kt+1],S.tx.position[1,kt+1],S.tx.position[2,kt+1]])
        for kr in range(Nrx-1):
            if (mod(kr,10)==0):
                print kr+1
            r = np.array([S.rx.position[0,kr+1],S.rx.position[1,kr+1],S.rx.position[2,kr+1]])
            ctx = S.L.pt2cy(t)
            crx = S.L.pt2cy(r)
            if (ctx<>ctxp)|(crx<>crxp):
                Si  = Signatures(S.L,ctx,crx)
                ctxp = ctx
                crxp = crx
                Si.run1(cutoff=cutoff)
            r2d = Si.rays(t,r)
            #r2d.show(S.L)
    
            r3d = r2d.to3D(S.L)
            r3d.locbas(S.L)
            r3d.fillinter(S.L)
            Ct  = r3d.eval(S.fGHz)
            sca = Ct.prop2tran(S.tx.A,S.rx.A)
            cir = sca.applywavB(wav.sfg)
            tcir[kt+1][kr+1]=cir
        return(tcir)

loading the Layout
..................


.. code-block:: python

    S = Simul()
    filestr = 'DLR2'
    S.layout(filestr+'.ini','matDB.ini','slabDB.ini')
    try:
        S.L.dumpr()
    except:
        S.L.build()
        S.L.dumpw()


.. code-block:: python

    S.L.display['ednodes']=False
    S.L.display['nodes']=False
    S.L.display['title']='DLR WP4 WHERE2 measurement site'
    S.L.display['overlay']=False
    fig,ax = S.L.showGs()    

.. image:: DOC-trajectory_files/_fig_02.png

We have a list of static Anchor Nodes. Those values correspond to the
actual anchor nodes coordinates of the WHERE2 project DLR measurement
campaign.


.. code-block:: python

    AnchorNodes = {390:{'name':'MT_ACO_05','coord':[6,0.81,1.64]},
                   386:{'name':'MT_ACO_08','coord':[30.574,2.8,1.291]},
                   391:{'name':'MT_ACO_07','coord':[11.78,-5.553,1.5]},
                   385:{'name': 'MT_ACO_01','coord':[19.52,-0.69,1.446]},
                   387:{'name':'MT_ACO_03','coord':[28.606,-0.74,1.467]},
                   400:{'name':'MT_ACO_02','coord':[30.574,2.8,1.291]},
                   1:{'name':'MT_DLR_RTDSlave','coord':[0.85,0,1.18]}
                  }


.. code-block:: python

    S.tx.clear()
    S.rx.clear()
    S.tx.filant='def.vsh3'
    S.rx.filant='def.vsh3'
    da ={}
    dm ={}

Vizualization of the simulated scenario


.. code-block:: python

    fig,ax=S.L.showG('s',nodes=False)
    plt.axis('off')
    #
    # add new points in tx and rx
    #
    #for c,k in enumerate(AnchorNodes):
    c = 0 # first anchor nodes
    k = AnchorNodes.keys()[c]
    pta = array([AnchorNodes[k]['coord'][0],AnchorNodes[k]['coord'][1],AnchorNodes[k]['coord'][2]]).reshape(3,1)
    #
    # To add a point 
    #
    S.tx.point(pta,mode="add")
    da[c]=k
    plt.plot(pta[0,:],pta[1,:],'or')


.. parsed-literal::

    [<matplotlib.lines.Line2D at 0x4242910>]


.. image:: DOC-trajectory_files/_fig_05.png

In the following a trajectory for the receiver is defined.

``linevect`` function allows to define a linear trajectory from ``ptt``
along direction ``vec``.


.. code-block:: python

    S.rx.linevect(npt=150, step=0.2, ptt=[0, 0, 1.275], vec=[1, 0, 0], mode='subst')
    ps = S.rx.position[:,-1]
    S.rx.linevect(npt=20, step=0.2, ptt=ps,vec=[0,1,0],mode='append')

Looking what is does


.. code-block:: python

    S.L.display['ednodes']=False
    S.L.display['edges']=True
    S.L.display['nodes']=False
    S.L.display['title']='Trajectory to be simulated'
    S.show(s=20)


.. parsed-literal::

    Warning : no furniture file loaded


.. parsed-literal::

    (<matplotlib.figure.Figure at 0x29084d0>,
     <matplotlib.axes.AxesSubplot at 0x4314cd0>)


.. image:: DOC-trajectory_files/_fig_09.png

Choosing a UWB waveform for the simulation


.. code-block:: python

    wav = wvf.Waveform(type='W1compensate')
    wav.show()

.. image:: DOC-trajectory_files/_fig_11.png

running the simulation


.. code-block:: python

    tcir = evalcir(S,wav,cutoff=3)


.. parsed-literal::

    1
    11
    21
    31
    41
    51
    61
    71
    81
    no T interaction to evaluate
    91
    101
    111
    121
    131
    141
    151
    161



Saving the data in pickle format


.. code-block:: python

    file = open("tcir5.pickle","w")
    pickle.dump(tcir,file)
    file.close()

Reading the data from the above file


.. code-block:: python

    del tcir
    file=open("tcir5.pickle","r")
    tcir=pickle.load(file)
    file.close()
    #
    for i in tcir[1].keys():
        cir = tcir[1][i]
        cir.zlr(0,150)
        try:
            ttcir=np.vstack((ttcir,cir.y))
        except:
            ttcir=cir.y

Aggregated CIR along a synthetic trajectory (line in the corridor) 
...................................................................


.. code-block:: python

    figsize(10,10)
    dmax=150*0.3
    plt.imshow(20*np.log10(ttcir+1e-20),vmax=-40,vmin=-160,origin='lower',extent=[0,dmax,1,160])
    plt.xlabel(r'delay $\times$ c (meters)',fontsize=20)
    #plt.ylabel(r'distance along trajectory (meters)',fontsize=20)
    plt.ylabel(r'trajectory index number',fontsize=20)
    clb=plt.colorbar()
    clb.set_label('level (dB)',fontsize=20)
    plt.axis('tight')


.. parsed-literal::

    (0.0, 45.0, 1.0, 160.0)


.. image:: DOC-trajectory_files/_fig_15.png

The abrupt interuption which is noticeable in the above representation
results from a still active implementation problem. When the trajectory
crosses an 'AIR' wall it counts for an extra interaction. This 'AIR'
wall problem should be fixed.


.. code-block:: python

    figsize(10,5)
    tcir[1][1].plot()
    xlabel('Delay (ns)')
    ylabel('Level (V)')
    title('Received Waveform')


.. parsed-literal::

    <matplotlib.text.Text at 0x712cad0>


.. image:: DOC-trajectory_files/_fig_18.png


.. code-block:: python

    tcir[1][40].plot()
    xlabel('Delay (ns)')
    ylabel('Level (V)')
    title('Received Waveform')


.. parsed-literal::

    <matplotlib.text.Text at 0x70a1f90>


.. image:: DOC-trajectory_files/_fig_21.png

