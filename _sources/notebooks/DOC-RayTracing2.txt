Example of an UWB channel Ray Tracing simulation
================================================


In the following, all steps required for going from the descrpition of
the radio scene until the calculation of the UWB channel impulse
response is described on a simple example.

A ray-tracing simulation is controlled via a configuration file which is
stored in the *ini* directory of the project directory. By default, a
default configuration file named **default.ini** is loaded.


.. code-block:: python

    from pylayers.simul.simulem import *
    from pylayers.antprop.rays import *
    from pylayers.antprop.channel import *
    from pylayers.antprop.signature import *
    from pylayers.measures.mesuwb import *
    import pylayers.util.pyutil as pyu
    import pylayers.signal.bsignal as bs

.. parsed-literal::

    <matplotlib.figure.Figure at 0x4e51390>

A first step consists in loading a layout associated with the
simulation. Here the ``WHERE1.ini`` layout is chosen along with the
corresponding slabs and materials files ``matDB.ini`` and
``slabDB.ini``.

This layout corresponds to the office building where the first WHERE1
UWB measurement campaign has been conducted.

The layout method loads those in a member layout object **L** of the
simulation object **S**.

If not already available, the layout associated graphs are built.


.. code-block:: python

    S = Simul()
    # loading a layout 
    filestr = 'WHERE1'
    S.layout(filestr+'.ini','matDB.ini','slabDB.ini')
    try:
        S.L.dumpr()
    except:
        S.L.build()
        S.L.dumpw()

The layout display is fully parameterized via the embedded **display**
dictionnary member of the Layout object.which allows to configure the
``showGs()`` method behavior.


.. code-block:: python

    figsize(15,7)    
    S.L.display['ednodes']=False
    S.L.display['nodes']=False
    S.L.display['title']='WHERE1 Project Office Measurement Site'
    S.L.display['overlay']=False
    fig,ax=S.L.showGs()    


.. image:: DOC-RayTracing2_files/_fig_02.png

Adding coordinates of transmiting and receiving points

-------------------------------------------------------

Coordinates of transmitters and receivers for the simulation are stored
in **.ini** files. Transmitter and Receiver are instances of the class
RadioNode which offers different methods for specifying nodes positions.
The stucture of this **.ini** file presented below. The node Id is
associated with the 3 coordinates :math:`$x,y,z$` separated by white
spaces.

::

    [coordinates]
    1 = -12.2724 7.76319999993 1.2
    2 = -18.7747 15.1779999998 1.2
    3 = -4.14179999998 8.86029999983 1.2
    4 = -9.09139999998 15.1899000001 1.2



.. code-block:: python

    S.tx = RadioNode(_fileini='w2m1rx.ini',_fileant='defant.vsh3')
    S.rx = RadioNode(_fileini='w2m1tx.ini',_fileant='defant.vsh3')

The whole simulation setup can then be displayed using the **show**
method of the Simulation object


.. code-block:: python

    fig,ax = S.show()


.. parsed-literal::

    Warning : no furniture file loaded

.. image:: DOC-RayTracing2_files/_fig_05.png

The different object of the simulation cans be accessed to obtain
different information. Below the number of transmitter and receiver.


.. code-block:: python

    print 'number of Tx :',len(S.tx.points.keys())
    print 'number of rx :',len(S.rx.points.keys())


.. parsed-literal::

    number of Tx : 302
    number of rx : 4

The decomposition of the layout in a set of disjoint cycles is
represented below. Not all cycles are rooms.


.. code-block:: python

    figsize(10,10)
    fig =plt.figure(figsize=(10,10))
    fig,ax=S.L.showG('t',fig=fig)
    plt.axis('off')


.. parsed-literal::

    (-40.0, 40.0, 2.0, 18.0)


.. image:: DOC-RayTracing2_files/_fig_09.png


.. code-block:: python

    figsize(10,10)
    fig =plt.figure(figsize=(10,10))
    fig,ax=S.L.showG('t',fig=fig)
    plt.axis('off')


.. parsed-literal::

    (-40.0, 40.0, 2.0, 18.0)


.. image:: DOC-RayTracing2_files/_fig_12.png

Signatures, rays and propagation and transmission channel
---------------------------------------------------------



.. code-block:: python

    # Choose Tx and Rx coordinates
    itx=10
    irx=2
    tx= S.tx.points[itx]
    rx= S.rx.points[irx]


.. code-block:: python

    tx


.. parsed-literal::

    array([-24.867 ,  12.3097,   1.2   ])


A signature is a sequence of layout objects (points and segments) which
are involved in a given optical ray, relating the transmiter and the
receiver. The signatutre is calculated from a layout cycle to an other
layout cycle. This means that is is required first to retrieve the cycle
number from point coordinates. This is done thanks to the **pt2cy**,
point to cycle function.


.. code-block:: python

    ctx=S.L.pt2cy(tx)
    crx=S.L.pt2cy(rx)
    print 'tx point belongs to cycle ',ctx
    print 'rx point belongs to cycle ',crx


.. parsed-literal::

    tx point belongs to cycle  5
    rx point belongs to cycle  4

Then the signature between cycle 5 and cycle 4 can be calculated. This
is done by instantiating a Signature object with a given layout and the
2 cycle number.

The representaion of a signature object provides information about the
number of signatures for each number of interactions.


.. code-block:: python

    %timeit
    Si = Signatures(S.L,ctx,crx)
    Si.run1(cutoff=3)
    Si


.. parsed-literal::

    Signatures : 
    ------------------
    248
    from : 5 to 4
    1 : 2
    2 : 40
    3 : 264
    4 : 1274



Once the signature has been obtained, 2D rays are calculated with the
``rays()`` method of the signature **Si**. The coordinates of a
transmitter and a receiver should be parameters of the function. **r2d**
object has a ``show`` and ``show3`` method


.. code-block:: python

    r2d = Si.rays(tx,rx)
    S.L.display['ednodes']=False
    r2d.show(S.L)


.. parsed-literal::

    12 [4, 5]

.. image:: DOC-RayTracing2_files/_fig_18.png


.. code-block:: python

    r2d.show3(strucname='WHERE1')

Then, the **r2d** object is transformed in 3D ray, taking into account
the reflection on ceil and floor.


.. code-block:: python

    r3d=r2d.to3D()
    r3d.show3(strucname='WHERE1')

Once the 3D rays are obtained the local basis are determined


.. code-block:: python

    r3d.locbas(S.L)

and the the interaction matrices are filled.


.. code-block:: python

    r3d.fillinter(S.L)

Below ``ni`` is the number of interactions


.. code-block:: python

    r3d


.. parsed-literal::

    1 / 1 : [0]
    2 / 5 : [1 2 3 4 5]
    3 / 13 : [ 6  7  8  9 10 11 12 13 14 15 16 17 18]
    4 / 20 : [19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38]
    5 / 18 : [39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56]
    6 / 8 : [57 58 59 60 61 62 63 64]
    -----
    ni : 268
    nl : 601




.. code-block:: python

    6*8+5*18+20*4+13*3+5*2+1


.. parsed-literal::

    268


Calulating the Propagation Channel 
-----------------------------------

The propagation channel is a ``Ctilde`` object. This object can be
evaluated for different frequency point thanks to the ``eval()`` method
with a frequency array as argument.


.. code-block:: python

    S.fGHz


.. parsed-literal::

    array([  2.  ,   2.05,   2.1 ,   2.15,   2.2 ,   2.25,   2.3 ,   2.35,
             2.4 ,   2.45,   2.5 ,   2.55,   2.6 ,   2.65,   2.7 ,   2.75,
             2.8 ,   2.85,   2.9 ,   2.95,   3.  ,   3.05,   3.1 ,   3.15,
             3.2 ,   3.25,   3.3 ,   3.35,   3.4 ,   3.45,   3.5 ,   3.55,
             3.6 ,   3.65,   3.7 ,   3.75,   3.8 ,   3.85,   3.9 ,   3.95,
             4.  ,   4.05,   4.1 ,   4.15,   4.2 ,   4.25,   4.3 ,   4.35,
             4.4 ,   4.45,   4.5 ,   4.55,   4.6 ,   4.65,   4.7 ,   4.75,
             4.8 ,   4.85,   4.9 ,   4.95,   5.  ,   5.05,   5.1 ,   5.15,
             5.2 ,   5.25,   5.3 ,   5.35,   5.4 ,   5.45,   5.5 ,   5.55,
             5.6 ,   5.65,   5.7 ,   5.75,   5.8 ,   5.85,   5.9 ,   5.95,
             6.  ,   6.05,   6.1 ,   6.15,   6.2 ,   6.25,   6.3 ,   6.35,
             6.4 ,   6.45,   6.5 ,   6.55,   6.6 ,   6.65,   6.7 ,   6.75,
             6.8 ,   6.85,   6.9 ,   6.95,   7.  ,   7.05,   7.1 ,   7.15,
             7.2 ,   7.25,   7.3 ,   7.35,   7.4 ,   7.45,   7.5 ,   7.55,
             7.6 ,   7.65,   7.7 ,   7.75,   7.8 ,   7.85,   7.9 ,   7.95,
             8.  ,   8.05,   8.1 ,   8.15,   8.2 ,   8.25,   8.3 ,   8.35,
             8.4 ,   8.45,   8.5 ,   8.55,   8.6 ,   8.65,   8.7 ,   8.75,
             8.8 ,   8.85,   8.9 ,   8.95,   9.  ,   9.05,   9.1 ,   9.15,
             9.2 ,   9.25,   9.3 ,   9.35,   9.4 ,   9.45,   9.5 ,   9.55,
             9.6 ,   9.65,   9.7 ,   9.75,   9.8 ,   9.85,   9.9 ,   9.95,
            10.  ,  10.05,  10.1 ,  10.15,  10.2 ,  10.25,  10.3 ,  10.35,
            10.4 ,  10.45,  10.5 ,  10.55,  10.6 ,  10.65,  10.7 ,  10.75,
            10.8 ,  10.85,  10.9 ,  10.95,  11.  ])



.. code-block:: python

    print "fmin : ",S.fGHz.min()
    print "fmax : ",S.fGHz.max()
    print "Nf : ", len(S.fGHz)


.. parsed-literal::

    fmin :  2.0
    fmax :  11.0
    Nf :  181


.. code-block:: python

    r3d


.. parsed-literal::

    1 / 1 : [0]
    2 / 5 : [1 2 3 4 5]
    3 / 13 : [ 6  7  8  9 10 11 12 13 14 15 16 17 18]
    4 / 20 : [19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38]
    5 / 18 : [39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56]
    6 / 8 : [57 58 59 60 61 62 63 64]
    -----
    ni : 268
    nl : 601




.. code-block:: python

    r3d


.. parsed-literal::

    1 / 1 : [0]
    2 / 5 : [1 2 3 4 5]
    3 / 13 : [ 6  7  8  9 10 11 12 13 14 15 16 17 18]
    4 / 20 : [19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38]
    5 / 18 : [39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56]
    6 / 8 : [57 58 59 60 61 62 63 64]
    -----
    ni : 268
    nl : 601




.. code-block:: python

    Ct = r3d.eval(S.fGHz)


.. parsed-literal::

    Rays evaluation


.. code-block:: python

    Eco,Ecross = Ct.energy()
    plot(Ct.tauk,10*np.log10(Eco),'ob')
    plot(Ct.tauk,10*np.log10(Ecross),'or')
    xlabel('delay(ns)')
    ylabel('path energy (dB)')
    legend(('Co-pol','X-pol'))
    axis((0,80,-60,20))


.. parsed-literal::

    (0, 80, -60, 20)


.. image:: DOC-RayTracing2_files/_fig_28.png

The multipath doa/dod diagram can be obtained via the method ``doadod``.
The colorbar corresponds to the total energy of the path.


.. code-block:: python

    Ct.doadod()

.. image:: DOC-RayTracing2_files/_fig_30.png


.. code-block:: python

    Ct.info()


.. parsed-literal::

    Nf   : 181
    Nray : 130
    shape Ctt : (130, 181)
    shape Ctp : (130, 181)
    shape Cpt : (130, 181)
    shape Cpp : (130, 181)

Apply waveform
--------------


Once the propagation channel is obtained the transmission channel is
calculated with the method ``prop2tran``


.. code-block:: python

    Ct.freq = S.fGHz
    sco = Ct.prop2tran(a='theta',b='theta')
    sca = Ct.prop2tran(a=S.tx.A,b=S.rx.A)

The applied waveform which is here loaded from a measurement file, and
compensated for a small time shift. It is important for the latter
treatment for the applied waveform to be centered on the middle of the
array as it is illustrated below.


.. code-block:: python

    wav = wvf.Waveform({'type':'W1compensate'})
    #wav = wvf.Waveform({'type' : 'generic','band': 0.499,'fc': 4.493, 'fe': 100, 'thresh': 3, 'tw': 30})
    wav.show()

.. image:: DOC-RayTracing2_files/_fig_33.png

Finally, the received UWB waveform can be synthesize in applyng the
waveform to the transmission channel.


.. code-block:: python

    ciro = sco.applywavB(wav.sfg)
    cira = sca.applywavB(wav.sfg)


.. code-block:: python

    subplot(121)
    ciro.plot()
    xlabel('delay(ns)')
    ylabel('voltage (V)')
    title('without antenna')
    axis((0,90,-0.0002,0.0002))
    subplot(122)
    cira.plot()
    xlabel('delay(ns)')
    ylabel('voltage (V)')
    title('with antenna')
    a=axis((0,90,-0.002,0.002))

.. image:: DOC-RayTracing2_files/_fig_35.png


.. code-block:: python

    

