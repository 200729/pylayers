import h5py
import os
import ipdb
import numpy as np
from pylayers.antprop.channel import *
from pylayers.util.project import *
import pylayers.util.pyutil as pyu
import ConfigParser

"""

Module to handle scanner data stored and exploited
in hdf5 format.

Authors : M.D.BALDE

.. currentmodule:: pylayers.measures.exploith5

.. autosummary::
    :toctree: generated

mesh5 Class
===========

.. autosummary::
    :toctree: generated/

    mesh5.__init__
    mesh5.__repr__
    mesh5.readcal
    mesh5.read
    mesh5.calibrate
    mesh5.saveini

"""


class Mesh5(PyLayers):
    """ Class handling hdf5 measurement files
    """
    def __init__(self,_filename=''):
        """
        """
        if _filename!='':
            if '.h5' not in _filename:
                _filename = _filename+'.h5'
            filename = pyu.getlong(_filename,pstruc['DIRMES'])
            if os.path.isfile(filename):
                self._filename = _filename
                self.filename = filename

    def dir(self):
        path = pyu.getlong('',pstruc['DIRMES'])
        fileh5 = [ f for f in os.listdir(path) if os.path.isfile(os.path.join(path,f)) ]
        for k in fileh5:
            if '.h5' in k:
                print k

    def __repr__(self):
        """
        """
        if "filename" in self.__dict__:
            st = ''
            st = st + '-------------------------------------\n'
            st = st + '              Parameters             \n'
            st = st + '-------------------------------------\n'
            st = st + 'Directory  : '+ str(self.filename) +'\n'
            st = st + '-------------------------------------\n'


            if 'mes' not in self.__dict__:
                st = st +'\n No measurement loaded \n'
            else:
                st = st + 'Index : '+ str(self.ix)+'\n'
                st = st + 'Position : '+str(self.pt)+'\n'
                if self.mes.calibrated:
                    st = st+'\n Measurement calibrated : Yes\n'
                else:
                    st = st+'\n Measurement calibrated : No\n'

            f  = h5py.File(self.filename,'r')
            ke = f.keys()


            for k in ke:
                st = st + k + '\n'
                for ja in f[k].attrs.keys():
                    st = st + ' ' + ja + ' : ' +  str(f[k].attrs[ja])+ '\n'
                st = st+'\n'
                if 'mes' not in k:
                    try:
                        for jb in f[k]:
                            st = st +'\t\t' + jb + '\t'
                            for jba in f[k][jb].attrs.keys():
                                st = st + str(f[k][jb].attrs[jba])+ '\t'
                            st = st+'\n'
                            try:
                                for jc in f[k][jb]:
                                    st = st +'\t\t' + jb + '\t' + jc + '\t'
                                    for jca in f[k][jb][jc].attrs.keys():
                                        st = st + str(f[k][jb][jc].attrs[jca])+ '\t'
                                    st = st+'\n'
                            except:
                                st = st+'\n'
                    except:
                        st = st+'\n'
            f.close()
            #st = st + 'File  : '+ str(self.f) +'\n'
        else:
            st = 'file  not set'

        return(st)

    def get_dcal(self,gcal=1,ical=None):
        """ get calibration dictionnary

        Parameters
        ----------

        gcal : calibration group
        ical : calibration index in group
            if ==None all calibration are provided in the dict

        """
        self.f  = h5py.File(self.filename,'r')
        k = "cal"+str(gcal)
        #pdb.set_trace()
        dcal={}
        #dcal  = dict(zip(self.f[k].attrs.keys(),self.f[k].attrs.values()))
        if ical==None:
            for ical in self.f[k].keys():
                di = dict(zip(self.f[k][ical].attrs.keys(),self.f[k][ical].attrs.values()))
                dcal[ical]=di
        else:
            ical=str(ical)
            dcal[ical]=dict(zip(self.f[k][ical].attrs.keys(),self.f[k][ical].attrs.values()))
        self.f.close()

        return dcal

    def readcal(self,gcal=1,ical=1):
        """ read calibration files

        Parameters
        ----------

        gcal : int
            calibration group index
        ical : int
            calibration index

        """

        # calibration dictionnary
        self.dcal = self.get_dcal(gcal,ical)

        # fmin,fmax,Nf
        fminGHz = self.dcal[str(ical)]['fminghz']
        fmaxGHz = self.dcal[str(ical)]['fmaxghz']
        Nf = self.dcal[str(ical)]['nf']

        # get the mimo calibration file
        if '_filecalh5' in self.dcal[str(ical)]:
            _filecalh5 = self.dcal[str(ical)]['_filecalh5']
            # group of calibration mimo
            gcalm = self.dcal[str(ical)]['gcalm']
            filecalh5 = pyu.getlong(_filecalh5, pstruc['DIRMES'])+'.h5'
            self.fmimo  = h5py.File(filecalh5,'r')
            self.fsiso  = h5py.File(self.filename,'r')
            km = 'cal'+str(gcalm)
            ks = "cal"+str(gcal)

            Co   = np.array(self.fmimo[km][str(ical)])
            Co11 = Co[:,0,0,:]
            Cto  = Co/Co11[:,None,None,:]
            Cn11 = np.array(self.fsiso[ks][str(ical)])
            Cn   = Cn11*Cto
            self.fsiso.close()
        else:
            self.fmimo  = h5py.File(self.filename,'r')
            km = 'cal'+str(gcal)
            Cn  = np.array(self.fmimo[km][str(ical)])

        self.fmimo.close()
        self.fGHz = np.linspace(fminGHz,fmaxGHz,Nf)
        self.cal = Tchannel(x=self.fGHz,y=Cn)



    def read(self,k,ix=[0,0,0,0],calibrate=True):
        """ read measure

        Parameters
        ----------

        k : int
            index measure to read
        ix : [ix,iy,iz,ia] list
        calibrate : boolean

        Notes
        -----
        For the selected measurement

        + retrieve the corresponding calibration gcal/ical
        + load the corresponding calibration .cal member as a Tchannel

        """
        k = 'mes'+str(k)
        self.f = h5py.File(self.filename,'r')
        gcal = eval(self.f[k].attrs['gcal'].replace('cal',''))
        ical = eval(self.f[k].attrs['ical'])
        self.author = self.f[k].attrs['author']
        self.time = self.f[k].attrs['time']
        self.pAnt = self.f[k].attrs['pant']
        self.vAnt = self.f[k].attrs['vant']
        self.Nr = self.f[k].attrs['nr']
        self.Nt = self.f[k].attrs['nt']

        self.dmes = dict(zip(self.f[k].attrs.keys(),self.f[k].attrs.values()))
        self.f.close()
        self.readcal(gcal=gcal,ical=ical)

        self.f = h5py.File(self.filename,'r')

        self.mes = Tchannel(x=self.fGHz,y=np.array(self.f[k][str(ix[0])][str(ix[1])][str(ix[2])][str(ix[3])]))
        self.ix  = ix
        self.pt  = self.f[k][str(ix[0])][str(ix[1])][str(ix[2])][str(ix[3])].attrs['pt']
        if calibrate:
            self.caluncal()

    def caluncal(self):
        """ calibrate or uncalibrate the current loaded measurement

        """
        if 'mes' in self.__dict__:
            if self.mes.calibrated==False:
                self.mes.y = self.mes.y/np.mean(self.cal.y,axis=0)
                self.mes.calibrated=True
            else:
                self.mes.y = self.mes.y*np.mean(self.cal.y,axis=0)
                self.mes.calibrated=False
        else:
            print "read data first"



    def open(self,mode='r'):
        """

        Parameters
        ----------

        mode : string

        """
        filename = pyu.getlong(self._filename,pstruc['DIRMES'])
        self.f  = h5py.File(filename,mode)



    def close(self):
        """ close h5 file
        """
        self.f.close()

    def saveini(self,ical=1,_fileini='vna_config.ini'):
        """ save calibration parameters in .ini file

        Parameters
        ----------

        _fileini  : string
            calibration ini file
        ical : int
            calibration number
        """

        dcal = self.dcal[str(ical)]
        config = ConfigParser.ConfigParser()

        # stimulus section
        config.add_section("stimulus")
        config.set("stimulus",'fminghz',dcal['fminghz'])
        config.set("stimulus",'fmaxghz',dcal['fmaxghz'])
        config.set("stimulus",'nf',dcal['nf'])

        # response section
        config.add_section("response")
        config.set("response",'param',dcal['param'])
        config.set("response",'average','on')
        config.set("response",'navrg',dcal['navrg'])
        config.set("response",'ifbhz',dcal['ifbhz'])
        config.set("response",'win',1)

        fileini = pyu.getlong(_fileini,pstruc['DIRMES'])
        fd = open(fileini,"w")
        config.write(fd)
        fd.close()

    def plot(self,cmd='mes'):
        """show calibration from vna

        Parameters
        ----------
        mes : string
        lg  : list
        cmd : string
            mes | cal | ir

        """

        #self.read(mes,lg)
        plt.ion()

        if cmd == 'mes':
            if self.mes.calibrated:
                self.mes.plot()
                plt.suptitle("Measurement Calibrated Channel")
            else:
                plt.suptitle("Measurement Channel Not Calibrated")

        if cmd == 'cal':
            self.cal.plot()
            plt.suptitle("Calibration transfer function")

        if cmd == 'ir':
            cir = self.mes.ift(ffts=1)
            cir.plot()
            plt.suptitle("Impulse Response")
        plt.tight_layout()
        plt.show()

if __name__=='__main__':
    doctest.testmod()
    #mesh5(sdata.h5)
