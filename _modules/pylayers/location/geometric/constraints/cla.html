
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pylayers.location.geometric.constraints.cla &mdash; Python 1 documentation</title>
    
    <link rel="stylesheet" href="../../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <link rel="author" title="About these documents" href="../../../../../about.html" />
    <link rel="top" title="Python 1 documentation" href="../../../../../index.html" />
    <link rel="up" title="Module code" href="../../../../index.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34943220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body role="document">

    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../../../../../index.html">
            <img src="../../../../../_static/pylayers.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../../../../../download.html">Download</a></li>
            <li><a href="../../../../../notebook/TOC.html">User Guide</a></li>
            <li><a href="../../../../../modules/pylayers.html">Reference</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script>
  (function() {
       var cx = '004820205189002234612:sa15qzuf2ca';
           var gcse = document.createElement('script');
               gcse.type = 'text/javascript';
                   gcse.async = true;
                       gcse.src = (document.location.protocol == 'https:' ?
                           'https:' : 'http:') +
                               '//cse.google.com/cse.js?cx=' + cx;
                                   var s =
                                   document.getElementsByTagName('script')[0];
                                       s.parentNode.insertBefore(gcse, s);
                                         })();
</script>
<gcse:search></gcse:search>
</div>
</div> <!-- end navbar --></div>
    </div>

    <div class="content-wrapper">

      <div class="sphinxsidebar">
	<div class="sphinxsidebarwrapper">
	  <div class="rel">
	   
	<!-- rellinks[1:] is an ugly hack to avoid link to module
	    index  -->
	<div class="rellink">
	<a href="../../../../../py-modindex.html" title="Python Module Index"
	    >Modules
	    <br>
	    <span class="smallrellink">
	    Python Module...
	    </span>
	    <span class="hiddenrellink">
	    Python Module Index
	    </span>
	    
	    </a>
	</div>
	<!-- Ad a link to the 'up' page -->
	<div class="spacer">
	&nbsp;
	</div>
	<div class="rellink">
	<a href="../../../../index.html" title="Module code" >
	Up
	<br>
	<span class="smallrellink">
	Module code
	</span>
	<span class="hiddenrellink">
	Module code
	</span>
	
	</a>
	</div>
    </div>
    <p style="text-align: center; background-color: #BFFFFF">This documentation is

    for Python <strong>version 1</strong>
    &mdash; <a href="https://github.com/pylayers/pylayers/archive/master.zip">Other versions</a></p>
    
    <h3>Citing</h3>
    <p>If you use the software, please consider
    <a href="../../../../../about.html#citing-pylayers">citing pylayers</a>.</p>
    <h3>This page</h3>
	
    
    </div>
	  </div>


      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pylayers.location.geometric.constraints.cla</h1><div class="highlight"><pre>
<span></span><span class="c1">#-*- coding:Utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Constraint Layer Array (CLA) Class</span>
<span class="sd">==================================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   CLA.__init__</span>
<span class="sd">   CLA.__repr__</span>
<span class="sd">   CLA.info</span>
<span class="sd">   CLA.update</span>
<span class="sd">   CLA.compute</span>
<span class="sd">   CLA.rescale</span>
<span class="sd">   CLA.annulus_bound</span>
<span class="sd">   CLA.append</span>
<span class="sd">   CLA.remove</span>
<span class="sd">   CLA.setvcw</span>
<span class="sd">   CLA.merge2</span>
<span class="sd">   CLA.valid_v</span>
<span class="sd">   CLA.refine</span>
<span class="sd">   CLA.show3</span>
<span class="sd">   CLA.prob</span>
<span class="sd">   CLA.gapdetect</span>
<span class="sd">   CLA.gapdetect2</span>
<span class="sd">   CLA.min_dist</span>
<span class="sd">   CLA.estpos</span>
<span class="sd">   CLA.estpos2</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#####################################################################</span>
<span class="c1">#This file is part of RGPA.</span>

<span class="c1">#Foobar is free software: you can redistribute it and/or modify</span>
<span class="c1">#it under the terms of the GNU General Public License as published by</span>
<span class="c1">#the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#(at your option) any later version.</span>

<span class="c1">#Foobar is distributed in the hope that it will be useful,</span>
<span class="c1">#but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#GNU General Public License for more details.</span>

<span class="c1">#You should have received a copy of the GNU General Public License</span>
<span class="c1">#along with Foobar.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="c1">#-------------------------------------------------------------------</span>
<span class="c1">#authors :</span>
<span class="c1">#Nicolas AMIOT          : nicolas.amiot@univ-rennes1.fr</span>
<span class="c1">#Bernard UGUEN          : bernard.uguen@univ-rennes1.fr</span>
<span class="c1">#Mohamed LAARAIEDH      : mohamed.laaraiedh@univ-rennes1.fr</span>
<span class="c1">#####################################################################</span>
<span class="kn">from</span> <span class="nn">pylayers.util.project</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">pylayers.location.geometric.util.boxn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pylayers.location.geometric.util</span> <span class="kn">import</span> <span class="n">geomview</span> <span class="k">as</span> <span class="n">g</span>
<span class="kn">from</span> <span class="nn">pylayers.location.geometric.util.scene</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">interval</span> <span class="kn">import</span> <span class="n">interval</span><span class="p">,</span><span class="n">inf</span>
    <span class="n">pyinterval_installed</span><span class="o">=</span><span class="bp">True</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">pyinterval_installed</span><span class="o">=</span><span class="bp">False</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1">#__docformat__ = &#39;reStructuredText&#39;</span>


<span class="k">class</span> <span class="nc">CLA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  Constraint Layer Array class</span>
<span class="sd">    The Constraint Layer Array gather all constraints and process them.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    c  : list</span>
<span class="sd">            contraints contained in CLA</span>
<span class="sd">    type : list</span>
<span class="sd">            types of contraints contained in CLA</span>
<span class="sd">    std  : list</span>
<span class="sd">            standard deviation of constraints</span>
<span class="sd">    vcw   : list</span>
<span class="sd">            scale factor of constraints</span>
<span class="sd">    Nc : integer</span>
<span class="sd">            Layer number of current processing</span>
<span class="sd">    pe :  np.array</span>
<span class="sd">            Position estimated</span>
<span class="sd">    dlayer  : dictionnary</span>
<span class="sd">            key : Layer number</span>
<span class="sd">            value : list of Enclosed (0) and ambiguous (1) boxes.</span>
<span class="sd">    iter : integer</span>
<span class="sd">            current iteration of refine process</span>
<span class="sd">    erronous : list</span>
<span class="sd">            fills with number constraint which are not compatibleselfselfselfself.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>

<span class="sd">    info(self)                              : Give info</span>

<span class="sd">    compute(pe=True,mergeRSS=False,refineRSS=True, NBOXMAX=50, VOLMIN=0.001,HT=True,forceamb=False):</span>
<span class="sd">                                              compute the CLA to estimate the positon.</span>

<span class="sd">    rescale(self,f_vcw,cid=None)            : rescale Constraint Box</span>

<span class="sd">    annulus_bound(self,cid=None)            : rescale Constraint</span>

<span class="sd">    append(self,c)                          : Append a Constraint to CLA</span>

<span class="sd">    setvcw(self,vcw):                       : Set vcw for all constraint</span>

<span class="sd">    merge2(self,vcw_init=1.0)               : Merge all constraint from the CLA</span>

<span class="sd">    valid_v(self,lv,N)                      : Test vertexes with all constraints</span>

<span class="sd">    refine(self,l,NBOXMAX=100,VOLMIN=0.1)   : reduce the validity zone</span>

<span class="sd">    show3(self,l=-1,amb=False,sc=&#39;all&#39;)     : show3</span>

<span class="sd">    prob(self,c,d)                          : Compute DDP for the given vertexes</span>

<span class="sd">    gapdetect(self,l,dlindx)                : Gap detection for bimodal solution</span>

<span class="sd">    min_dist(self,a,b)                      : OBSOLETE</span>

<span class="sd">    estpos2(self,l=-1,amb=False)            : Position estimation</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#       MEMBERS</span>
<span class="c1">#               Nc        : number of constraints</span>
<span class="c1">#               c         : list of constraints                                  1 x Nc</span>
<span class="c1">#               std       : list of standard deviation of constraints            1 x Nc</span>
<span class="c1">#                          if std = 0 it means the constraint is hard and it force the</span>
<span class="c1">#                          the estimated point to belong to the bounding box of this</span>
<span class="c1">#                          constraint</span>
<span class="c1">#               w         : list of weight of constraints                        1 x Nc</span>
<span class="c1">#                          if w = 0 it means the constraint is hard and it force the</span>
<span class="c1">#                          the estimated point to belong to the bounding box of this</span>
<span class="c1">#                          constraint</span>
<span class="c1">#</span>
<span class="c1">#               validity  : validity array (N x Nc)</span>
<span class="c1">#               dlayer    : dictionnary containing a list of 2 elements :</span>
<span class="c1">#                               - the list of boxes that are inside the validity area (VA)</span>
<span class="c1">#                               - the list of boxes which at least an edge is inside the validity area(VA)</span>
<span class="c1">#               dpe       : dictionnary containing the estimated points</span>
<span class="c1">#       :Methods:</span>
<span class="c1">#               info()</span>
<span class="c1">#               append(c,std)</span>
<span class="c1">#               remove(c,k)</span>
<span class="c1">#               merge2()</span>
<span class="c1">#               layer(lbox,l=-1)</span>
<span class="c1">#               grid(l=-1,Msz=1000)</span>
<span class="c1">#               eval(Msz=1000)</span>
<span class="c1">#               show3()</span>
<span class="c1">#               estpos(amb=False)</span>

<span class="c1">#       List of elementary Constraints</span>

<div class="viewcode-block" id="CLA.__init__"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.__init__.html#pylayers.location.geometric.constraints.cla.CLA.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parmsh</span><span class="o">=</span><span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcw</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">erronous</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runable</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># does pe is known ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visible</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># does link physically exist ? aka 2 nodes are in visiblity ?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obsolete</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># is the ldp has been obtain a long time ago</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># constraints are usable = runable + visible</span>



        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parmsh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span> <span class="o">=</span> <span class="n">parmsh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>     <span class="c1"># launch geomview K</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>      <span class="c1"># display whole scene</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>       <span class="c1"># display constraint box</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;constr_boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>       <span class="c1"># display constraint box</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;estimated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># display estimated point</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span> <span class="o">=</span> <span class="n">parmsh</span></div>

<div class="viewcode-block" id="CLA.__repr__"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.__repr__.html#pylayers.location.geometric.constraints.cla.CLA.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;{0:4} | {1:6} |{2:4} | {3:4} | {4:15}| {5:9}| {6:5}| {7:7}| {8:6}|&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;node&#39;</span><span class="p">,</span><span class="s1">&#39;peer&#39;</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;wstd&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;runable&#39;</span> <span class="p">,</span> <span class="s1">&#39;usable&#39;</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
            <span class="n">peer</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="s1">&#39;link&#39;</span><span class="p">]</span>
            <span class="n">wstd</span>  <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="s1">&#39;wstd&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;TDOA&#39;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;{0:4} | {1:6} |{2:4} | {3:4} | {4:15}| {5:9}| {6:5}| {7:7}| {8:6}|&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">peer</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">type</span><span class="p">,</span><span class="n">wstd</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">usable</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;{0:4} | {1:6} |{2:4} | {3:4} | {4:15}| {5:9}| {6:5}| {7:7}| {8:6}|&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">peer</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">type</span><span class="p">,</span><span class="n">wstd</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">usable</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;                            &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># s = s + &#39;\n&#39; + &#39;{0:4} | {1:15}| {2:9}| {3:5}| {4:7}| {5:6}| {6:8}| {7:9}&#39;.format(c.type, c.p[0], c.value, c.std, c.runable, c.usable , c.obsolete , c.evaluated)</span>
                <span class="c1"># s = s + &#39;\n&#39; + &#39;       &#39;+str(c.p[1])</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;position evaluated by the CLA</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pe</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="CLA.info"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.info.html#pylayers.location.geometric.constraints.cla.CLA.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get information about constraint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">info</span><span class="p">()</span></div>


<div class="viewcode-block" id="CLA.update"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.update.html#pylayers.location.geometric.constraints.cla.CLA.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;update</span>
<span class="sd">                update all constraints of the CLA</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">update</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runable</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">runable</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obsolete</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">obsolete</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visible</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">visible</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">usable</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span></div>

<div class="viewcode-block" id="CLA.compute"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.compute.html#pylayers.location.geometric.constraints.cla.CLA.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pe</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">mergeRSS</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">refineRSS</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">NBOXMAX</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">VOLMIN</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span><span class="n">HT</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">forceamb</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute the cla to estimate the postion</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        pe : boolean</span>
<span class="sd">           set to True to compute the position estimation store into self.pe</span>
<span class="sd">        mergeRSS : boolean</span>
<span class="sd">            True  if there is RSS in cla, they are used to find the smallest merge</span>
<span class="sd">            False (default) even if there is RSS in cla, they are neglected during the merge process</span>
<span class="sd">        refineRSS :boolean</span>
<span class="sd">            True (default) if there is RSS in cla, they are used to decide if boxes are enclosed of ambiguous</span>
<span class="sd">                            during the refine process</span>
<span class="sd">            False if there is RSS in cla, they are ignore during the refine process</span>
<span class="sd">        NBOXMAX : integer</span>
<span class="sd">            Choose the maximum boxes generated during the refine process (escape value of the while and recursive function)</span>
<span class="sd">        NVOLMIN : float</span>
<span class="sd">            Choose the minimum volume of the boxes obtained  during the refine process (escape value of the while and recursive function)</span>
<span class="sd">        HT : boolean</span>
<span class="sd">            True  if a cluster ppears (2 sets of distinct boxes ) an hypthesis testuing method is applied</span>
<span class="sd">                    in estpos2 method</span>
<span class="sd">            False  no HT method is applied</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">            Description of the hypothesis testing (HT) method in:</span>

<span class="sd">        ..  [APLU2012]   N. Amiot, T. Pedersen, M. Laaraiedh, B. Uguen.</span>
<span class="sd">            A Hybrid Positioning Method Based on Hypothesis Testing</span>
<span class="sd">            ,Wireless Communications Letters, IEEE, vol.1, no.4, pp.348-351, August 2012 http://ieeexplore.ieee.org.passerelle.univ-rennes1.fr/stamp/stamp.jsp?tp=&amp;arnumber=6205594</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        return : boolean</span>
<span class="sd">            True if the position estimation has been performed.</span>

<span class="sd">        update a self.pe which contain the estimated position</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge2</span><span class="p">(</span><span class="n">RSS</span><span class="o">=</span><span class="n">mergeRSS</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nc</span><span class="p">,</span><span class="n">NBOXMAX</span><span class="o">=</span><span class="n">NBOXMAX</span><span class="p">,</span> <span class="n">VOLMIN</span><span class="o">=</span><span class="n">VOLMIN</span><span class="p">,</span><span class="n">RSS</span><span class="o">=</span><span class="n">refineRSS</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pe</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estpos2</span><span class="p">(</span><span class="n">HT</span><span class="o">=</span><span class="n">HT</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">forceamb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estpos2</span><span class="p">(</span><span class="n">HT</span><span class="o">=</span><span class="n">HT</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">False</span></div>



<span class="c1">#    def compute_amb(self,pe=True,HT=True):</span>

<span class="c1">#        self.merge2(RSS=False)</span>
<span class="c1">#        self.refine(self.Nc,RSS=False)</span>
<span class="c1">#        self.estpos2(HT=HT)</span>
<span class="c1">#        self.Nc=len(np.where(self.usable)[0])</span>
<span class="c1">#        return True</span>

<div class="viewcode-block" id="CLA.rescale"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.rescale.html#pylayers.location.geometric.constraints.cla.CLA.rescale">[docs]</a>    <span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_vcw</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;idem setvcw but update current vcw with a multiplier factor</span>

<span class="sd">        change vcw for all constraints of the CLA</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        f_vcw : a scale factor of the current vcw of the constraint.</span>
<span class="sd">        cid : a list of constraints for which the self.vcw will be applied. If cid=None, all constraints are updates. default=None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing but update vcw either for each constraints from cid list either for all contraints in the CLA list self.c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;rescale&quot;,vcw</span>

        <span class="k">if</span> <span class="n">cid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">f_vcw</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">f_vcw</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">Id</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">]</span></div>

<div class="viewcode-block" id="CLA.annulus_bound"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.annulus_bound.html#pylayers.location.geometric.constraints.cla.CLA.annulus_bound">[docs]</a>    <span class="k">def</span> <span class="nf">annulus_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; adapt cmin and cmax of constraints</span>

<span class="sd">        Update cmin and cmax of constraints for a given self.vcw</span>




<span class="sd">        :Parameters:</span>
<span class="sd">                cid : a list of constraints for which the self.vcw will be applied. If cid=None, all constraints are updates. default=None</span>

<span class="sd">        :Returns:</span>
<span class="sd">                Nothing but update boxe size either for each constraints from cid list either for all contraints in the CLA list self.c.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;rescale&quot;,vcw</span>
        <span class="k">if</span> <span class="n">cid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">annulus_bound</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">annulus_bound</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">Id</span> <span class="ow">in</span> <span class="n">cid</span><span class="p">]</span></div>

<div class="viewcode-block" id="CLA.append"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.append.html#pylayers.location.geometric.constraints.cla.CLA.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add a constraint into the CLA</span>

<span class="sd">        add a constraint into the CLA</span>




<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">                c       : any constraint wichi heritates from Constraint object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">                Nothing but fills self.c list of constraints</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obsolete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">obsolete</span><span class="p">)</span>
        <span class="c1"># by default, if a constraint is runable, it will be used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">runable</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">visible</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">obsolete</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Reevaluate weights</span>
        <span class="c1">#</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># std &gt;0</span>
        <span class="n">sumstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)[</span><span class="n">u</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)</span> <span class="o">/</span> <span class="n">sumstd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">lbox</span><span class="o">.</span><span class="n">ndim</span></div>

<div class="viewcode-block" id="CLA.remove"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.remove.html#pylayers.location.geometric.constraints.cla.CLA.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;OBSOLETE/ TO BE DEVELOPPED</span>



<span class="sd">        remove(k) : remove a constraint to cla</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">std</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">sumstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)[</span><span class="n">u</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1">#</span>
        <span class="c1"># Reevaluate weights</span>
        <span class="c1">#</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># std &gt;0</span>
        <span class="n">sumstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)[</span><span class="n">u</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">)</span> <span class="o">/</span> <span class="n">sumstd</span></div>

<div class="viewcode-block" id="CLA.setvcw"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.setvcw.html#pylayers.location.geometric.constraints.cla.CLA.setvcw">[docs]</a>    <span class="k">def</span> <span class="nf">setvcw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;update scale factor of all constraint</span>

<span class="sd">        rescale all the constraints&#39;s boxes according to the given vcw</span>


<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        vcw     : a vcw value</span>
<span class="sd">        RSS : boolean</span>
<span class="sd">            True : RSS are considered in merging</span>
<span class="sd">            False : RSS are excluded from merging</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing but update all constraint from the CLA</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">vcw</span><span class="p">)</span></div>


<div class="viewcode-block" id="CLA.merge2"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.merge2.html#pylayers.location.geometric.constraints.cla.CLA.merge2">[docs]</a>    <span class="k">def</span> <span class="nf">merge2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcw_init</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">RSS</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge all constraints from the CLA2_reduc2</span>

<span class="sd">        Inteligent merging of  constraints in the CLA and look for the smallest intersection box of all the constraints through a dichotomous process.</span>

<span class="sd">        - if the result of this merging is empty (no common intersections between all the boxes), all the constraints&#39;s vcw are increased (x2) and this processing is operated until an intersection exists (physically intersection MUST exist)</span>
<span class="sd">        - if the result of this merging is not empty (intersection exists between all the boxes), all the constraints&#39;s vcw are decreased and this processing is operated until no intersection exists. the previous value of vcw is thus used for all constraints.</span>

<span class="sd">        This method ensure to find the smallest instersection box satisfaying all the constraints</span>


<span class="sd">        Also here is initialized self.dlayer.</span>
<span class="sd">        use of dlayer dictionnary:</span>

<span class="sd">        self.dlayer[Layer][type of boxes]</span>

<span class="sd">        Layer = number of intersecting constraints</span>
<span class="sd">        type of boxes : 0 = enclose boxes (EB)</span>
<span class="sd">                        1 = ambiguous boxes (AB)</span>

<span class="sd">        After the merging, all constraints boxes are store as AB list. EB list is void.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        vcw_init : float</span>
<span class="sd">            intial value of scale factor vcw. This value is updated during the process and affect all constraints ! default =1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Nothing but fills self.dlayer[Nc][0] (with a void list)  and self.dlayer[Nc][1] (with the intial restricted box). Nc is the number of intersecting constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="c1">#        Nc = self.Nc - len(np.nonzero(np.array(self.type) == &#39;RSS&#39;)[0]) - len(np.nonzero(np.array(self.runable) == False)[0]) </span>
<span class="c1">#        Nc = self.Nc - len(np.nonzero(np.array(self.runable) == False)[0]) </span>

        <span class="n">Nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="c1">#self.Nc - len(np.nonzero(np.array(self.usable) == False)[0]) </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">=</span> <span class="n">Nc</span>
        <span class="n">vcwmin</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># max(self.vcw)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">vcw1</span> <span class="o">=</span> <span class="n">vcwmin</span> <span class="o">+</span> <span class="n">step</span>

        <span class="n">onlyRSS</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="s1">&#39;RSS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;TOA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;TDOA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                    <span class="n">onlyRSS</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="s1">&#39;TDOA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;TOA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                    <span class="n">onlyRSS</span> <span class="o">=</span> <span class="bp">True</span>


        <span class="k">while</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">vcw1</span> <span class="o">==</span> <span class="n">vcwmin</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">setvcw</span><span class="p">(</span><span class="n">vcw1</span><span class="p">)</span>
                <span class="c1">#constraints vcw set to current value</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">tlb</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>                <span class="c1"># find intersection between all constraints for the current vcw</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;Exclude&#39;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;RSS&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">onlyRSS</span> <span class="ow">or</span> <span class="n">RSS</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">usable</span><span class="p">:</span>
                            <span class="n">lb</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">lbox</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">tlb</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="n">tlb</span> <span class="o">=</span> <span class="n">lb</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ex</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tlb</span> <span class="o">=</span> <span class="n">tlb</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">lbox</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlb</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>             <span class="c1"># if the list is empty (no intersection ) vcw1 is increased</span>
                <span class="n">vcw1</span> <span class="o">=</span> <span class="n">vcw1</span> <span class="o">+</span> <span class="n">step</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="mf">1.2</span>
                <span class="c1">#print step, vcw1</span>
            <span class="k">else</span><span class="p">:</span>                           <span class="c1"># if the list is not empty (intersection exist) vcw1 is decreased</span>
                <span class="n">vcw1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">vcw1</span> <span class="o">-</span> <span class="n">step</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">vcwmin</span><span class="p">)</span>  <span class="c1"># vcw &gt; vcwmin</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">step</span> <span class="o">/</span> <span class="mf">4.</span>
                <span class="c1">#print step, vcw1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tlb</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tlb</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setvcw</span><span class="p">(</span><span class="n">vcw1</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
<span class="c1">#        try:</span>
<span class="c1">#            tlb = tlb.intersect(ex.lbox)</span>

<span class="c1">#        except:</span>
<span class="c1">#            pass</span>
<span class="c1">#        pdb.set_trace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcw_init</span> <span class="o">=</span> <span class="n">vcw_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">Nc</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">LBoxN</span><span class="p">([]),</span> <span class="n">tlb</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">Nc</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span></div>

<div class="viewcode-block" id="CLA.valid_v"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.valid_v.html#pylayers.location.geometric.constraints.cla.CLA.valid_v">[docs]</a>    <span class="k">def</span> <span class="nf">valid_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lv</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">RSS</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;test a vertex list with constraints</span>

<span class="sd">        Each vertexes from boxes pass into the list are tested to determine if the box is out (OB), ambiguous (AB) or enclosed (EB)</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        lv : a vertex list from BOXN.octants</span>
<span class="sd">        N  : number of constraints aka layer number</span>
<span class="sd">        RSS : boolean</span>
<span class="sd">            True : RSS constraints are kept as any other constraints for boxes evaluation (ambigous /enclosed)</span>
<span class="sd">            False : RSS constraints are ignored in boxes evaluation (ambigous /enclosed)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        AB : a list with the numerous of Ambiguous Boxes</span>
<span class="sd">        EB : a list with the numerous of Enclosed Boxes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span><span class="p">,</span> <span class="s2">&quot; N &gt; Number of Constraints &quot;</span>

        <span class="n">Nmiss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">-</span> <span class="n">N</span>
        <span class="n">miss_cpt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">f_flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">o_flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pndim</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">sDDB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lv</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">sT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="o">/</span> <span class="n">pndim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">sTAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="o">/</span> <span class="n">pndim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

        <span class="n">TT</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Ds</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">RSS</span><span class="p">:</span>
            <span class="n">loop_condition</span><span class="o">=</span><span class="s2">&quot;(c.type != &#39;Exclude&#39;) &amp; (c.usable)&quot;</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">loop_condition</span><span class="o">=</span><span class="s2">&quot;(c.type != &#39;RSS&#39;) &amp; (c.type != &#39;Exclude&#39;) &amp; (c.usable)&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>                <span class="c1"># for each constraints</span>
            <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">loop_condition</span><span class="p">):</span>

                <span class="n">DDB</span><span class="p">,</span> <span class="n">TB</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">valid_v</span><span class="p">(</span>
                    <span class="n">lv</span><span class="p">)</span>  <span class="c1"># .reshape(2,len(lv)/4,pow(2,self.ndim))</span>
                <span class="n">TT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TB</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">DDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> <span class="o">|</span> <span class="p">(</span><span class="n">DDB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>         <span class="c1"># if all  boxes  are out</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">erro</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">Id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erro</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">Id</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="n">sDDB</span> <span class="o">=</span> <span class="n">DDB</span> <span class="o">*</span> <span class="n">sDDB</span>
                <span class="c1"># ERROR CHECKER</span>
                <span class="n">AA</span> <span class="o">=</span> <span class="n">TB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">BB</span> <span class="o">=</span> <span class="n">TB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">CC</span> <span class="o">=</span> <span class="n">TB</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">DD</span> <span class="o">=</span> <span class="n">TB</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">TAB</span> <span class="o">=</span> <span class="p">(((</span><span class="o">~</span><span class="n">AA</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">BB</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">DD</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">BB</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">CC</span><span class="p">)</span>
                                                 <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">DD</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">AA</span> <span class="o">*</span> <span class="n">BB</span> <span class="o">*</span> <span class="p">(</span><span class="o">~</span><span class="n">CC</span><span class="p">)))</span>

                <span class="n">sTAB</span> <span class="o">=</span> <span class="p">(</span><span class="n">sTAB</span> <span class="o">*</span> <span class="n">TAB</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sDDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sDDB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
            <span class="n">sB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">EB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">sB</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">sB</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sB</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># error checker</span>
            <span class="n">ABt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sTAB</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">AB</span><span class="p">,</span> <span class="n">ABt</span><span class="p">)))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">EB</span><span class="p">,</span> <span class="n">AB</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">sDDB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sDDB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">sB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">EB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">sB</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">AB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">sB</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sB</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># error checker</span>
            <span class="n">ABt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sTAB</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">AB</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">AB</span><span class="p">,</span><span class="n">ABt</span><span class="p">)))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">EB</span><span class="p">,</span> <span class="n">AB</span><span class="p">)</span></div>

<div class="viewcode-block" id="CLA.refine"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.refine.html#pylayers.location.geometric.constraints.cla.CLA.refine">[docs]</a>    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">NBOXMAX</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">VOLMIN</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span><span class="n">RSS</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;refine the l layer of the CLA</span>

<span class="sd">        Refine the l layer of the CLA  until the maximum number of boxes (NBOXMAX) or the minimal volume of boxes (VOLMIN) has been reached.</span>

<span class="sd">        Once the CLA has been merged, this method aims to enclose the solution thanks to an octree/quadtreee process</span>

<span class="sd">        self.dlayer[l][0] : LBox which contains boxes inside of the validity area (VA)</span>
<span class="sd">        self.dlayer[l][1] : LBox which contains ambiguous boxes (partially inside of the VA == at least 1 edge inside the VA)</span>
<span class="sd">        All boxes partially inside of the VA are divided into octants. Each octants are tested into the self.valid.</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        l : the layer number</span>
<span class="sd">        NBOXMAX : the maximum number of obtained boxes</span>
<span class="sd">        VOLMIN :  the minimum volume achievable by the obtained boxes</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing, but fills self.dlayer[l][0] and self.dlayer[l][1] respectively with enclosed boxes and ambiguous boxes</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">Nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print NBOXMAX</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FINISHED</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">erro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nc</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1">#        print &#39;iter&#39;, self.iter</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">octant</span><span class="p">()</span>

        <span class="n">lv</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">bd2coord</span><span class="p">()</span>

        <span class="n">EB</span><span class="p">,</span> <span class="n">AB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_v</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">RSS</span><span class="o">=</span><span class="n">RSS</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">lv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">erronous</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">erro</span><span class="p">)</span>

        <span class="n">nbox</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">EB</span><span class="p">)</span>
        <span class="n">nboxamb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AB</span><span class="p">)</span>

<span class="c1">#        print nbox</span>
<span class="c1">#        print nboxamb</span>
        <span class="c1"># if all boxes are out of the VA</span>
<span class="c1">#               if  ((nboxamb==0)&amp;(nbox==0)) and len(self.dlayer[l][0].box) == 0:</span>

        <span class="k">if</span>  <span class="p">((</span><span class="n">nboxamb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nbox</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">:</span>

                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">erro</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="c1">#                    print &quot;specific size up&quot;, pb</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annulus_bound</span><span class="p">(</span><span class="n">pb</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>

<span class="c1">#                    print &#39;all contraints size up &#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annulus_bound</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">NBOXMAX</span><span class="p">,</span> <span class="n">VOLMIN</span><span class="p">,</span><span class="n">RSS</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                    <span class="c1"># unstack to a lower the layer</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="k">assert</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">NBOXMAX</span><span class="p">,</span> <span class="n">VOLMIN</span><span class="p">,</span><span class="n">RSS</span><span class="p">)</span>

        <span class="c1"># if it exists at least a box ambiguous or not in the VA</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">nbox</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nboxamb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FINISHED</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Update EB</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">EB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append_l</span><span class="p">(</span><span class="n">LBoxN</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">EB</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

            <span class="c1"># Update AB</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBoxN</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">AB</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

            <span class="c1"># check if it remains is more AB to refine</span>
            <span class="k">if</span> <span class="n">nboxamb</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lv</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># while the max number of boxes (NBOXMAX) is not reached or the elementary volume of boxes (VOLMIN) is not reached</span>
            <span class="c1"># self.refine is executed.</span>
            <span class="c1"># else  self.refine is over.</span>

            <span class="k">if</span> <span class="p">(((</span><span class="n">nboxamb</span> <span class="o">+</span> <span class="n">nbox</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NBOXMAX</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vol</span> <span class="o">&gt;</span> <span class="n">VOLMIN</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">FINISHED</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">NBOXMAX</span><span class="p">,</span> <span class="n">VOLMIN</span><span class="p">,</span><span class="n">RSS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span> <span class="o">=</span> <span class="n">l</span></div>

<div class="viewcode-block" id="CLA.show3"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.show3.html#pylayers.location.geometric.constraints.cla.CLA.show3">[docs]</a>    <span class="k">def</span> <span class="nf">show3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">amb</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Display constraints and theirs boxes through geomview.</span>


<span class="sd">        geomview parameters are the following</span>

<span class="sd">        self.parmsh[&#39;display&#39;]=False            # launch geomview interactively</span>
<span class="sd">        self.parmsh[&#39;scene&#39;]=True               # display whole scene</span>
<span class="sd">        self.parmsh[&#39;boxes&#39;]=True               # display constraint box</span>
<span class="sd">        self.parmsh[&#39;constr_boxes&#39;]=False       # display constraint box</span>
<span class="sd">        self.parmsh[&#39;estimated&#39;]=True           # display estimated point</span>

<span class="sd">        </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        l       : layer number to observe. If -1 estimation is made on the highest available layer. default = -1</span>
<span class="sd">        amb     : display ambiguous boxes. default = false</span>
<span class="sd">        sc      : display all constraint or give a list with the constrinat number to observe ex: [0,1,3]. default &#39;all&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------        </span>

<span class="sd">        Nothing but calls a geomview instance</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nc</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">basename</span> <span class="o">+</span> <span class="s2">&quot;/geom/cla.list&quot;</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;LIST</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parmsh</span>
        

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sc</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="c1"># if constrinat boxes has to be displayed </span>
                        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;constr_boxes&#39;</span><span class="p">]:</span>
                            <span class="n">c</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="n">c</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">fname</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">show3</span><span class="p">()</span>
                        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;.list}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">vsc</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">vsc</span><span class="p">]</span><span class="o">.</span><span class="n">runable</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">vsc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">vsc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;constr_boxes&#39;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">vsc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">vsc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">vsc</span><span class="p">]</span><span class="o">.</span><span class="n">show3</span><span class="p">()</span>
                            <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;.list}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">runable</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;constr_boxes&#39;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">show3</span><span class="p">()</span>
                        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;.list}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">runable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;dispay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">show3</span><span class="p">()</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;.list}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>



        <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;scene&#39;</span><span class="p">]:</span>
            <span class="n">an</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">runable</span><span class="p">:</span>
                    <span class="n">an</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">an</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">Scene</span><span class="p">(</span><span class="n">an</span><span class="o">=</span><span class="n">an</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="p">)</span>
            <span class="n">sce</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;estimated&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sce</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">cloud</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pe</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;scene&#39;</span><span class="p">,</span>
                              <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">dice</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">)</span>
                <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">sce</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;boxes&#39;</span><span class="p">]:</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parmsh</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">show3</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">[</span><span class="n">Nc</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">Id</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">if</span> <span class="n">amb</span><span class="p">:</span>
                    <span class="n">coco</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">show3</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">[</span><span class="n">Nc</span> <span class="o">-</span> <span class="n">l</span><span class="p">],</span> <span class="n">Id</span><span class="o">=</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">#                                       fname = self.dlayer[l][1].show3(col=coco,Id=l+1)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">fd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="n">chaine</span> <span class="o">=</span> <span class="s2">&quot;geomview  -nopanel  -b 1 1 1 &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot; 2&gt;/dev/null &amp;&quot;</span>

        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">chaine</span><span class="p">)</span></div>

<div class="viewcode-block" id="CLA.prob"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.prob.html#pylayers.location.geometric.constraints.cla.CLA.prob">[docs]</a>    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine probability of list of vertex</span>

<span class="sd">        Return the probability of each vertex from an array in regard of the constraint origin, standard deviation and vcw</span>

<span class="sd">        </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        c       : contraint number in the self.c list</span>
<span class="sd">        d       : an array of vertex</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        v       : probability of each vertex</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TDOA&#39;</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">sstd</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">sstd</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TOA&#39;</span><span class="p">:</span>

            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">sstd</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">sstd</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">vcw</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
<span class="c1">#</span>
<span class="c1">#                       v = (1/(((self.c[c].sstd)*self.c[c].vcw)*np.sqrt(2*np.pi)))*np.exp(-(d-self.c[c].value*0.3)**2/(2*(self.c[c].sstd)*self.c[c].vcw)**2)</span>
<span class="c1">#                       v=v[0]</span>
            <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">sstd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">rssnp</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">PL0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">rssnp</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="o">-</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="n">M</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))))</span>

<span class="c1">#                       std = self.c[c].sstd#10**(self.c[c].model[&#39;RSSnp&#39;]/20.)</span>
<span class="c1">##                      mean = self.c[c].range</span>
<span class="c1">#                       mean = np.log(self.c[c].range)+std**2</span>
<span class="c1">#                       v = 1/(d*np.sqrt(2*np.pi))*np.exp(-(np.log(d)-mean)**2/(2*std**2))</span>
        <span class="k">return</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

<span class="c1">#    def gapdetect(self, l, dlindx):</span>
<span class="c1">#        &quot;&quot;&quot;basic gap detection</span>

<span class="c1">#        Detects if separated clusters of boxes are observables. his situation is usual in under determined estimation.</span>
<span class="c1">#        This only test on each axis if all boxes are contiguous. If not, a gap is declared and clusters are created.</span>


<span class="c1">#        </span>


<span class="c1">#        Parameters</span>
<span class="c1">#        ----------</span>
<span class="c1">#                l       : layer numbero</span>
<span class="c1">#                dlindx  : select the boxes type ( from self.dlayer) for gap detection 0=enclose or 1=ambigous boxes</span>

<span class="c1">#        Return</span>
<span class="c1">#        ------</span>
<span class="c1">#                clust   : a list of array. each array contains boxes from the same cluster</span>
<span class="c1">#                axis    : axis/axes where gap has/have been detectes</span>

<span class="c1">#        &quot;&quot;&quot;</span>

<span class="c1">#        gcoord = []</span>
<span class="c1">#        axis = np.zeros(self.ndim, dtype=&#39;int8&#39;)</span>
<span class="c1">#        clust = []</span>
<span class="c1">##        c2={}</span>
<span class="c1">#        for i in range(self.ndim):</span>
<span class="c1">#            uni, inv, idd = np.unique(self.dlayer[l][dlindx]</span>
<span class="c1">#                                      .bd[:, i], return_inverse=True, return_index=True)</span>
<span class="c1">##                       uni,inv,idd =np.unique(self.dlayer[l][dlindx].ctr[:,i],return_inverse=True,return_index=True)</span>

<span class="c1">#            slope = np.diff(np.diff(uni))</span>

<span class="c1">##            if len(slope) != 0:</span>
<span class="c1">#            if len(slope) &gt;1:</span>
<span class="c1">#                if abs(np.min(slope)) &gt; 1e-9:</span>
<span class="c1">##                    c2[i]=[]</span>
<span class="c1">#                    gidx = np.nonzero(np.min(slope) == slope)[0]</span>
<span class="c1">##                                       print &#39;GAP DETECTED in AXIS&#39;,i</span>
<span class="c1">#                    axis[i] = 1</span>

<span class="c1">#                    try:</span>
<span class="c1">#                        # divis par 2 pour pouvoir aveir les index  de cluster comme les centre des box</span>
<span class="c1">#                        clust.append(np.nonzero(uni[gidx[0]] &lt; self.dlayer[l]</span>
<span class="c1">#                                                [dlindx].bd[:, i])[0] / 2)</span>
<span class="c1">#                        clust.append(np.nonzero(uni[gidx[0]] &gt; self.dlayer[l]</span>
<span class="c1">#                                                [dlindx].bd[:, i])[0] / 2)</span>
<span class="c1">##                        c2[i].append(np.nonzero(uni[gidx[0]] &lt; self.dlayer[l]</span>
<span class="c1">##                                                [dlindx].bd[:, i])[0] / 2)</span>
<span class="c1">##                        c2[i].append(np.nonzero(uni[gidx[0]] &lt; self.dlayer[l]</span>
<span class="c1">##                                                [dlindx].bd[:, i])[0] / 2)</span>
<span class="c1">#                    except:</span>
<span class="c1">#                        pdb.set_trace()</span>
<span class="c1">#            else:</span>
<span class="c1">#                clust = []</span>
<span class="c1">#        if clust !=[]:</span>
<span class="c1">#            pdb.set_trace()</span>
<span class="c1">#        return clust, axis</span>


<div class="viewcode-block" id="CLA.gapdetect"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.gapdetect.html#pylayers.location.geometric.constraints.cla.CLA.gapdetect">[docs]</a>    <span class="k">def</span> <span class="nf">gapdetect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">dlindx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;basic gap detection</span>

<span class="sd">        Detects if separated clusters of boxes are observables. his situation is usual in under determined estimation.</span>
<span class="sd">        This only test on each axis if all boxes are contiguous. If not, a gap is declared and clusters are created.</span>


<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        l       : layer number</span>
<span class="sd">        dlindx  : select the boxes type ( from self.dlayer) for gap detection 0=enclose or 1=ambigous boxes</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>

<span class="sd">        clust   : a list of array. each array contains boxes from the same cluster</span>
<span class="sd">        axis    : axis/axes where gap has/have been detectes</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.location.geometric.constraints.cla import *</span>
<span class="sd">        &gt;&gt;&gt; from pylayers.location.geometric.constraints.toa import *</span>
<span class="sd">        &gt;&gt;&gt; from pylayers.location.geometric.constraints.exclude import *</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        &gt;&gt;&gt; a=np.array(([1,0,0]))</span>
<span class="sd">        &gt;&gt;&gt; b=np.array(([10,0,0]))</span>
<span class="sd">        &gt;&gt;&gt; nodes=np.array(([-10,10],[-10,10],[-1,1]))</span>
<span class="sd">        &gt;&gt;&gt; n= np.array((5,5,0))</span>
<span class="sd">        &gt;&gt;&gt; d1=np.sqrt(np.sum((a-n)**2))</span>
<span class="sd">        &gt;&gt;&gt; d2=np.sqrt(np.sum((b-n)**2))</span>
<span class="sd">        &gt;&gt;&gt; T1=TOA(id=1,value=d1/0.3,std=0.5,p=a)</span>
<span class="sd">        &gt;&gt;&gt; T2=TOA(id=2,value=d2/0.3,std=0.5,p=b)</span>
<span class="sd">        &gt;&gt;&gt; E=Exclude(nodes.T)</span>
<span class="sd">        &gt;&gt;&gt; T1.runable=True</span>
<span class="sd">        &gt;&gt;&gt; T2.runable=True</span>
<span class="sd">        &gt;&gt;&gt; C=CLA()</span>
<span class="sd">        &gt;&gt;&gt; C.append(T1)</span>
<span class="sd">        &gt;&gt;&gt; C.append(T2)</span>
<span class="sd">        &gt;&gt;&gt; C.append(E)</span>
<span class="sd">        &gt;&gt;&gt; C.merge2()</span>
<span class="sd">        &gt;&gt;&gt; C.refine(C.Nc)</span>
<span class="sd">        &gt;&gt;&gt; C.gapdetect(C.Nc,1)</span>
<span class="sd">        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gcoord</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>
        <span class="n">clust</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c2</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="c1"># find all begining point on axis i</span>
            <span class="n">uA</span><span class="p">,</span><span class="n">iuA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">],</span><span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c1"># find all ending point on axis i</span>
            <span class="n">uB</span><span class="p">,</span><span class="n">iuB</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">],</span><span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c1"># remove 1st point in uA</span>
            <span class="n">uAA</span> <span class="o">=</span> <span class="n">uA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">iuAA</span> <span class="o">=</span> <span class="n">iuA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># remove last point in uA</span>
            <span class="n">uBB</span> <span class="o">=</span> <span class="n">uB</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">iuBB</span> <span class="o">=</span> <span class="n">iuB</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1">#            u=[]</span>
<span class="c1">#            # find center of all these segment  </span>
<span class="c1">#            [u.append((uA[k]+uA[k+1])/2) for k in range(len(uA)-1) ]</span>

<span class="c1">#            # get all center of the boxes</span>
<span class="c1">#            C=self.dlayer[l][dlindx].ctr[:,i]</span>
<span class="c1">#            v=np.unique(C)</span>


            <span class="c1"># if no gap, all begining point must also be ending point, otherwise,</span>
            <span class="c1"># a gap exists</span>
            <span class="n">igap</span><span class="o">=</span><span class="p">[]</span>
<span class="c1">#            [igap.append(ik) for ik,k in enumerate(u) if k not in v]</span>
            <span class="p">[</span><span class="n">igap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uAA</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uBB</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">igap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">igap</span><span class="o">=</span><span class="p">[</span><span class="n">igap</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># if a segment has a center which is not a box center , there is a gap</span>
            <span class="c1"># indexes are split into 2 set</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">igap</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>

                <span class="c1"># in a futur version it will be more convenient to stock each </span>
                <span class="c1"># detected cluster in a given axis with a dictionary as the given</span>
                <span class="c1"># axis as a key.</span>
<span class="c1">#               c2[i].append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&lt;=cm[igap]))</span>
<span class="c1">#               c2[i].append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&gt;cm[igap]))</span>
<span class="c1">#                clust.append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&lt;=gap)[0]/2)</span>
<span class="c1">#                clust.append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&gt;gap)[0]/2)</span>

                <span class="n">clust</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">uA</span><span class="p">[</span><span class="n">igap</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">clust</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">uA</span><span class="p">[</span><span class="n">igap</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="c1">#            else :</span>
<span class="c1">#                clust = []</span>
        <span class="k">return</span> <span class="n">clust</span><span class="p">,</span><span class="n">axis</span></div>


<div class="viewcode-block" id="CLA.gapdetect2"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.gapdetect2.html#pylayers.location.geometric.constraints.cla.CLA.gapdetect2">[docs]</a>    <span class="k">def</span> <span class="nf">gapdetect2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">dlindx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;basic gap detection</span>

<span class="sd">        Detects if separated clusters of boxes are observables. his situation is usual in under determined estimation.</span>
<span class="sd">        This only test on each axis if all boxes are contiguous. If not, a gap is declared and clusters are created.</span>
<span class="sd">        requiere  pyinterval class </span>

<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        l       : layer number</span>
<span class="sd">        dlindx  : select the boxes type ( from self.dlayer) for gap detection 0=enclose or 1=ambigous boxes</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>

<span class="sd">        clust   : a list of array. each array contains boxes from the same cluster</span>
<span class="sd">        axis    : axis/axes where gap has/have been detectes</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.location.geometric.constraints.cla import *</span>
<span class="sd">        &gt;&gt;&gt; from pylayers.location.geometric.constraints.toa import *</span>
<span class="sd">        &gt;&gt;&gt; from pylayers.location.geometric.constraints.exclude import *</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        &gt;&gt;&gt; a=np.array(([1,0,0]))</span>
<span class="sd">        &gt;&gt;&gt; b=np.array(([10,0,0]))</span>
<span class="sd">        &gt;&gt;&gt; nodes=np.array(([-10,10],[-10,10],[-1,1]))</span>
<span class="sd">        &gt;&gt;&gt; n= np.array((5,5,0))</span>
<span class="sd">        &gt;&gt;&gt; d1=np.sqrt(np.sum((a-n)**2))</span>
<span class="sd">        &gt;&gt;&gt; d2=np.sqrt(np.sum((b-n)**2))</span>
<span class="sd">        &gt;&gt;&gt; T1=TOA(id=1,value=d1/0.3,std=np.array((0.5)),p=a)</span>
<span class="sd">        &gt;&gt;&gt; T2=TOA(id=2,value=d2/0.3,std=np.array((0.5)),p=b)</span>
<span class="sd">        &gt;&gt;&gt; E=Exclude(nodes.T)</span>
<span class="sd">        &gt;&gt;&gt; T1.runable=True</span>
<span class="sd">        &gt;&gt;&gt; T2.runable=True</span>
<span class="sd">        &gt;&gt;&gt; C=CLA()</span>
<span class="sd">        &gt;&gt;&gt; C.append(T1)</span>
<span class="sd">        &gt;&gt;&gt; C.append(T2)</span>
<span class="sd">        &gt;&gt;&gt; C.append(E)</span>
<span class="sd">        &gt;&gt;&gt; C.merge2()</span>
<span class="sd">        &gt;&gt;&gt; C.refine(C.Nc)</span>
<span class="sd">        &gt;&gt;&gt; C.gapdetect2(C.Nc,1)</span>
<span class="sd">        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gcoord</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>
        <span class="n">clust</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c2</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="c1"># reshape boxes to be compliant with interval</span>
            <span class="n">Z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">Zr</span><span class="o">=</span><span class="n">Z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># create intervals</span>
            <span class="n">I</span><span class="o">=</span><span class="p">[</span><span class="n">interval</span><span class="p">(</span><span class="n">Zr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Zr</span><span class="p">))]</span>
            <span class="n">ii</span><span class="o">=</span><span class="n">interval</span><span class="p">()</span>

            <span class="c1"># gather interval</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">I</span><span class="p">:</span>
                <span class="n">ii</span><span class="o">=</span><span class="n">ii</span><span class="o">|</span><span class="n">j</span>
            <span class="c1"># if a gap appears (more than a unique interval) </span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>

                <span class="c1"># in a futur version it will be more convenient to stock each </span>
                <span class="c1"># detected cluster in a given axis with a dictionary as the given</span>
                <span class="c1"># axis as a key.</span>
<span class="c1">#               c2[i].append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&lt;=cm[igap]))</span>
<span class="c1">#               c2[i].append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&gt;cm[igap]))</span>
<span class="c1">#                clust.append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&lt;=gap)[0]/2)</span>
<span class="c1">#                clust.append(np.nonzero(self.dlayer[l][dlindx].bd[:,i]&gt;gap)[0]/2)</span>

                <span class="n">clust</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">clust</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>


        <span class="k">return</span> <span class="n">clust</span><span class="p">,</span><span class="n">axis</span></div>


<div class="viewcode-block" id="CLA.min_dist"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.min_dist.html#pylayers.location.geometric.constraints.cla.CLA.min_dist">[docs]</a>    <span class="k">def</span> <span class="nf">min_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        OBSOLETE</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s1">&#39;min dist&#39;</span>
        <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="c1"># recherche distance entre barycentre et les centres des boites distance2barycentre(d2b)</span>
        <span class="n">d2b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># on retourne pe comme etant le centre de la boite ayant le plus faible distrance avec barycentre</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">d2b</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">d2b</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">indx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="CLA.estpos"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.estpos.html#pylayers.location.geometric.constraints.cla.CLA.estpos">[docs]</a>    <span class="k">def</span> <span class="nf">estpos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">amb</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        DEPRECATED !</span>
<span class="sd">        estpos(l,amb=True) : estimate position</span>

<span class="sd">        l : layer number</span>
<span class="sd">        amb : if True include ambigous boxes of VA in gravity center computation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">PP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveP</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">dlindx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">)):</span>
                <span class="n">poids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;Exclude&#39;</span><span class="p">:</span>

                        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)))</span>

                        <span class="n">poids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

                <span class="n">P</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">poids</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poids</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">saveP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

                <span class="n">PP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">PP</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saveP</span><span class="p">)</span></div>

<div class="viewcode-block" id="CLA.estpos2"><a class="viewcode-back" href="../../../../../modules/generated/pylayers.location.geometric.constraints.cla.CLA.estpos2.html#pylayers.location.geometric.constraints.cla.CLA.estpos2">[docs]</a>    <span class="k">def</span> <span class="nf">estpos2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">amb</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">HT</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Position estimation</span>

<span class="sd">        estimate position from the enclosed or/and ambibuous boxes</span>

<span class="sd">        </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        l       : Layer of the estimation. If -1 estimation is made on the highest available layer</span>
<span class="sd">        amb     : Use ambiguous boxes (if available) to perform the position estimation. default = False</span>
<span class="sd">        HT      : boolean</span>
<span class="sd">                True : if a cluster ppears (2 sets of distinct boxes ) an hypthesis testuing method is applied</span>
<span class="sd">                        in estpos2 method </span>
<span class="sd">                False : no HT methos is applied </span>

<span class="sd">                Hybrid positioning based on hypothesis thesting</span>
<span class="sd">                N. Amiot, T. Pedersen, M. Laaraiedh, B. Uguen. </span>
<span class="sd">                A Hybrid Positioning Method Based on Hypothesis Testing</span>
<span class="sd">                ,Wireless Communications Letters, IEEE, vol.1, no.4, pp.348-351, August 2012</span>

<span class="sd">        Returns </span>
<span class="sd">        -------</span>

<span class="sd">        Nothing but fills self.pe with an array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">PP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">poids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># si enclosed box exists</span>
            <span class="n">dlindx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1">#            print &#39;Enclosed pos estim&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dlindx</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">#            print &#39;Amiguous pos estim&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">pyinterval_installed</span><span class="p">:</span>
            <span class="n">clust</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gapdetect2</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">dlindx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clust</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gapdetect</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">dlindx</span><span class="p">)</span>

        <span class="n">box_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span>
        <span class="n">uc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        
        <span class="c1"># proba computation for all center of each boxes</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">uc</span><span class="p">:</span><span class="c1">#range(len(self.c)):</span>
            <span class="c1">#if self.c[j].type != &#39;Exclude&#39;:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;Exclude&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">usable</span><span class="p">):</span>
                <span class="c1"># compute distance between contraint center and all vertexes</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TOA&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;RSS&#39;</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">box_center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">box_center</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;TDOA&#39;</span><span class="p">:</span>
                    <span class="n">F1v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_center</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_center</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">F2v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_center</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_center</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">F1v</span> <span class="o">-</span> <span class="n">F2v</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">poids</span> <span class="o">=</span> <span class="p">(</span><span class="n">poids</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>
                    <span class="n">poids</span> <span class="o">=</span> <span class="p">(</span><span class="n">poids</span> <span class="o">*</span> <span class="n">poids</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span>

                <span class="k">except</span><span class="p">:</span>
                    <span class="n">poids</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                    <span class="n">poids</span> <span class="o">=</span> <span class="p">(</span><span class="n">poids</span> <span class="o">*</span> <span class="n">poids</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span>
<span class="c1">#                                       poids.append(self.prob(j,d))</span>

<span class="c1">#                       pdb.set_trace()</span>
<span class="c1">#                       P=sum(np.array(poids)*np.array(poids))/(len(poids))</span>
<span class="c1">#                       self.saveP[i]=P</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveP</span> <span class="o">=</span> <span class="n">poids</span>
<span class="c1">#                       PP.append(P*self.dlayer[l][dlindx].box[i].ctr)</span>
<span class="c1">##########################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pecluster</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="n">clust</span> <span class="o">!=</span> <span class="p">[]:</span>



            <span class="c1"># print &#39;cluster&#39;</span>
            <span class="n">lclust</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mps</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
            <span class="n">saxis</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">saxis</span> <span class="o">-</span> <span class="n">p</span><span class="p">)),</span> <span class="n">p</span><span class="p">)))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                                          <span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">saxis</span> <span class="o">-</span> <span class="n">p</span><span class="p">)),</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">T</span>
            <span class="n">lpc</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">clusters</span> <span class="o">=</span> <span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">count</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">clust</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">clust</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                <span class="n">clust_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span>
                    <span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">vol</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clusters</span><span class="p">)])</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saveP</span><span class="p">[</span><span class="n">clusters</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">mps</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="p">:</span>
                        <span class="n">mps</span> <span class="o">=</span> <span class="n">mp</span>
                        <span class="n">estclu</span> <span class="o">=</span> <span class="n">clusters</span>


                <span class="n">itoas</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;TOA&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clust_vol</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">itoas</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">lclust</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
                    <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clusters</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clusters</span><span class="p">))</span>
                    <span class="n">lpc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span>
                    <span class="c1"># verifier que les contraintes utilises sont les bonne ( ce n&#39;est pas le cas)</span>
                    <span class="c1"># ne marche que si 2 constriantes genere le cluster ( a robustifier)   </span>
                    <span class="n">pu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">usable</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># try:</span>
                    <span class="c1">#     dd.append(np.sqrt(np.sum((pc - self.c[itoas[0]].p) ** 2)))</span>
                    <span class="c1"># except:</span>
                    <span class="c1">#     dd.append(np.sqrt(np.sum((pc - self.c[itoas[1]].p) ** 2)))</span>
                    <span class="c1"># print pc</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">itoas</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">itoas</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
                    <span class="k">print</span> <span class="n">pc</span>
            <span class="c1">#                       try:</span>
<span class="c1">#                               vmax=[]</span>
<span class="c1">#                               for i in range(len(lclust)):</span>
<span class="c1">#                                       vmax.append(np.max(poids[np.unique(lclust[i])]))</span>
<span class="c1">#                               peindx = np.nonzero(poids==max(vmax))[0][0]</span>
<span class="c1">#                               self.pe = self.dlayer[l][dlindx].ctr[peindx]</span>

            <span class="k">if</span> <span class="n">HT</span><span class="p">:</span>

                <span class="c1">#print &quot;enter in HT processing&quot;</span>
                <span class="k">try</span><span class="p">:</span>

                    <span class="c1"># for now, it is supposed that all RSS share the same model</span>
                    <span class="n">rssvalues</span><span class="o">=</span><span class="p">[]</span>
                    <span class="n">icr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;RSS&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">irss</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">icr</span><span class="p">)):</span>
                        <span class="n">d0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="n">irss</span><span class="p">]]</span><span class="o">.</span><span class="n">p</span><span class="o">-</span><span class="n">lpc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                        <span class="n">d1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="n">irss</span><span class="p">]]</span><span class="o">.</span><span class="n">p</span><span class="o">-</span><span class="n">lpc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                        <span class="n">rssvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="n">irss</span><span class="p">]]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">drss</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">drss</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">))))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">drss</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">drss</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">drss</span><span class="o">=</span><span class="n">drss</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>    

                    <span class="n">M</span> <span class="o">=</span> <span class="p">(((</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">PL0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">10.</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">rssnp</span><span class="p">))</span>
                    <span class="n">PL0</span><span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">PL0</span> 
                    <span class="n">NP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">rssnp</span>
                    
                    <span class="n">mu1</span><span class="o">=</span><span class="n">PL0</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">NP</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">drss</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">mu2</span><span class="o">=</span><span class="n">PL0</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">NP</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">drss</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">sig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">icr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sigrss</span>
                    <span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">rssvalues</span><span class="p">))</span>
                    <span class="n">LT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">sig</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mu2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">mu1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">RT</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">sig</span><span class="p">))</span><span class="o">*</span><span class="n">values</span><span class="o">*</span><span class="p">(</span><span class="n">mu1</span><span class="o">-</span><span class="n">mu2</span><span class="p">))</span>


                    <span class="c1"># LL = np.log(dd[1] / dd[0]) * (1 + np.log(dd[0] * dd[1]) - 2 * M)</span>


                    <span class="c1"># if LL &gt; 0:</span>
                    <span class="k">if</span> <span class="n">LT</span><span class="o">&gt;</span><span class="n">RT</span><span class="p">:</span>
    <span class="c1">#                                       vmax = np.max(poids[np.unique(lclust[0])])</span>
    <span class="c1">#                                       peindx=np.nonzero(poids[vmax]==poids)[0][0]</span>
    <span class="c1">#                                       self.pe = self.dlayer[l][dlindx].ctr[np.unique(lclust[0])[peindx]]</span>

                        <span class="c1">#if LL&gt;0  cluster 0 is selctionned and tits centroids is chosen as position estimation</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lclust</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                       <span class="c1"># print &quot;HT processing done&quot;</span>
                        <span class="n">pestdmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span>
                            <span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lclust</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
                        <span class="n">pestdmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span>
                            <span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lclust</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pestd</span> <span class="o">=</span> <span class="n">pestdmax</span> <span class="o">-</span> <span class="n">pestdmin</span>


                    <span class="k">else</span><span class="p">:</span>


                        <span class="c1">#if LL&lt;0  cluster 1 is selctionned and tits centroids is chosen as position estimation</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lclust</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">pestdmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span>
                            <span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lclust</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
                        <span class="n">pestdmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span>
                            <span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lclust</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pestd</span> <span class="o">=</span> <span class="n">pestdmax</span> <span class="o">-</span> <span class="n">pestdmin</span>


                <span class="c1"># if HT fail for some reasons , a classical position estimation  is performed </span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="c1"># print &quot;!!!!! HT FAIL !!!!!!!&quot;</span>
                    <span class="c1"># print &quot;2 first constraint of CLA have to be TOA and others RSS in order to use HT&quot;</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span>
                            <span class="o">.</span><span class="n">ctr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> \
                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">)</span>
                    <span class="n">pestdmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">pestdmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pestd</span> <span class="o">=</span> <span class="n">pestdmax</span> <span class="o">-</span> <span class="n">pestdmin</span>

 



            <span class="c1"># if no HT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">ctr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> \
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">)</span>
                <span class="n">pestdmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">pestdmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pestd</span> <span class="o">=</span> <span class="n">pestdmax</span> <span class="o">-</span> <span class="n">pestdmin</span>


            <span class="c1"># store the centroid of clusters into self.peclsuter</span>
            <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">lclust</span><span class="p">:</span>	
                <span class="bp">self</span><span class="o">.</span><span class="n">pecluster</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cl</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>


        <span class="c1"># if not cluster</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span>
                    <span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">,</span>
                                 <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">ctr</span><span class="p">)</span>
            <span class="n">pestdmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pestdmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlayer</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">dlindx</span><span class="p">]</span><span class="o">.</span><span class="n">bd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pestd</span> <span class="o">=</span> <span class="n">pestdmax</span> <span class="o">-</span> <span class="n">pestdmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pecluster</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pe</span><span class="p">]</span></div>

</pre></div>

          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>
  

    <div class="footer">
        &copy; 2015, PyLayers developer team.
      Last updated on mai 16, 2016.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.5. Design by <a href="http://desgrana.es">Desgrana</a>.
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../../../../../py-modindex.html">
        Previous
      </a>  
    </div>
    
     </div>
     <script type="text/javascript">
       $("div.buttonNext, div.buttonPrevious").hover(
           function () {
               $(this).css('background-color', '#AFFFFF');
           },
           function () {
               $(this).css('background-color', '#AFFFFF');
           }
       );
     </script>
  </body>
</html>