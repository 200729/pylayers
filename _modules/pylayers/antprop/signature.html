
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pylayers.antprop.signature &mdash; Python 1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="Python 1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34943220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body>

    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../../../index.html">
            <img src="../../../_static/pylayers.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../../../download.html">Download</a></li>
            <li><a href="../../../notebook/TOC.html">User Guide</a></li>
            <li><a href="../../../modules/pylayers.html">Reference</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">
  google.load('search', '1', {language : 'en'});
  google.setOnLoadCallback(function() {
    var customSearchControl = new google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
    customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
    var options = new google.search.DrawOptions();
    options.setAutoComplete(true);
    customSearchControl.draw('cse', options);
  }, true);
</script>

</div>
</div> <!-- end navbar --></div>
    </div>

<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
    PyLayers
<!--
<a href="../../../index.html"><img src="../../../_static/logo.png" height="200" border="0"
    alt="pylayers"/></a>
-->
</div>


    <div class="content-wrapper">

      <div class="sphinxsidebar">
	<div class="sphinxsidebarwrapper">
	  <div class="rel">
	   
	<!-- rellinks[1:] is an ugly hack to avoid link to module
	    index  -->
	<div class="rellink">
	<a href="../../../py-modindex.html" title="Python Module Index"
	    >Modules
	    <br>
	    <span class="smallrellink">
	    Python Module In...
	    </span>
	    <span class="hiddenrellink">
	    Python Module Index
	    </span>
	    
	    </a>
	</div>
	<!-- Ad a link to the 'up' page -->
	<div class="spacer">
	&nbsp;
	</div>
	<div class="rellink">
	<a href="../../index.html" title="Module code" >
	Up
	<br>
	<span class="smallrellink">
	Module code
	</span>
	<span class="hiddenrellink">
	Module code
	</span>
	
	</a>
	</div>
    </div>
    <p style="text-align: center; background-color: #BFFFFF">This documentation is

    for Python <strong>version 1</strong>
    &mdash; <a href="https://github.com/pylayers/pylayers/archive/master.zip">Other versions</a></p>
    
    <h3>Citing</h3>
    <p>If you use the software, please consider
    <a href="../../../about.html#citing-pylayers">citing pylayers</a>.</p>
    <h3>This page</h3>
	
    
    </div>
	  </div>


      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pylayers.antprop.signature</h1><div class="highlight"><pre>
<span class="c">#-*- coding:Utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class Signatures</span>
<span class="sd">================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Signatures.__init__</span>
<span class="sd">    Signatures.__repr__</span>
<span class="sd">    Signatures.__len__</span>
<span class="sd">    Signatures.num</span>
<span class="sd">    Signatures.info</span>
<span class="sd">    Signatures.saveh5</span>
<span class="sd">    Signatures.loadh5</span>
<span class="sd">    Signatures._saveh5</span>
<span class="sd">    Signatures._loadh5</span>
<span class="sd">    Signatures.load</span>
<span class="sd">    Signatures.save</span>
<span class="sd">    Signatures.sp</span>
<span class="sd">    Signatures.procone</span>
<span class="sd">    Signatures.propaths</span>
<span class="sd">    Signatures.short_propath</span>
<span class="sd">    Signatures.propaths2</span>
<span class="sd">    Signatures.propaths3</span>
<span class="sd">    Signatures.propaths2015_2</span>
<span class="sd">    Signatures.procone2</span>
<span class="sd">    Signatures.calsig</span>
<span class="sd">    Signatures.exist</span>
<span class="sd">    Signatures.run2015</span>
<span class="sd">    Signatures.run2015_2</span>
<span class="sd">    Signatures.dido</span>
<span class="sd">    Signatures.run</span>
<span class="sd">    Signatures.run1</span>
<span class="sd">    Signatures.run2</span>
<span class="sd">    Signatures.run3</span>
<span class="sd">    Signatures.run4</span>
<span class="sd">    Signatures.run5</span>
<span class="sd">    Signatures.run6</span>
<span class="sd">    Signatures.run7</span>
<span class="sd">    Signatures.run7mt</span>
<span class="sd">    Signatures.meta</span>
<span class="sd">    Signatures.lineofcycle</span>
<span class="sd">    Signatures.cones</span>
<span class="sd">    Signatures.unfold</span>
<span class="sd">    Signatures.show</span>
<span class="sd">    Signatures.showi</span>
<span class="sd">    Signatures.rays</span>
<span class="sd">    Signatures.raysv</span>
<span class="sd">    Signatures.image</span>
<span class="sd">    Signatures.image2</span>

<span class="sd">Class Signature</span>
<span class="sd">===============</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Signature.__init__</span>
<span class="sd">    Signature.__repr__</span>
<span class="sd">    Signature.info</span>
<span class="sd">    Signature.split</span>
<span class="sd">    Signature.ev2</span>
<span class="sd">    Signature.evf</span>
<span class="sd">    Signature.ev</span>
<span class="sd">    Signature.unfold</span>
<span class="sd">    Signature.evtx</span>
<span class="sd">    Signature.image</span>
<span class="sd">    Signature.backtrace</span>
<span class="sd">    Signature.sig2beam</span>
<span class="sd">    Signature.sig2ray</span>

<span class="sd">Utility functions</span>
<span class="sd">=================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    showsig</span>
<span class="sd">    gidl</span>
<span class="sd">    frontline</span>
<span class="sd">    edgeout2</span>
<span class="sd">    edgeout</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="c">#import scipy as sp</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="kn">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="kn">as</span> <span class="nn">shg</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">pylayers.gis.layout</span> <span class="kn">as</span> <span class="nn">layout</span>
<span class="kn">import</span> <span class="nn">pylayers.util.geomutil</span> <span class="kn">as</span> <span class="nn">geu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.cone</span> <span class="kn">as</span> <span class="nn">cone</span>
<span class="c">#import pylayers.util.graphutil as gph</span>
<span class="kn">import</span> <span class="nn">pylayers.util.pyutil</span> <span class="kn">as</span> <span class="nn">pyu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.plotutil</span> <span class="kn">as</span> <span class="nn">plu</span>
<span class="kn">from</span> <span class="nn">pylayers.antprop.rays</span> <span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span> <span class="nn">pylayers.util.project</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="c">#from numba import autojit</span>

<div class="viewcode-block" id="showsig"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.showsig.html#pylayers.antprop.signature.showsig">[docs]</a><span class="k">def</span> <span class="nf">showsig</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">tx</span><span class="o">=</span><span class="p">[],</span><span class="n">rx</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot; show signature</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L  : Layout</span>
<span class="sd">    s  :</span>
<span class="sd">    tx :</span>
<span class="sd">    rx :</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;thin&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">showGs</span><span class="p">()</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;thin&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;edlabel&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">L</span><span class="o">.</span><span class="n">showGs</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">edlist</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tx</span> <span class="o">!=</span><span class="p">[]:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rx</span> <span class="o">!=</span><span class="p">[]:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;edlabel&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">False</span>

</div>
<div class="viewcode-block" id="gidl"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.gidl.html#pylayers.antprop.signature.gidl">[docs]</a><span class="k">def</span> <span class="nf">gidl</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; gi without diffraction</span>

<span class="sd">   Returns</span>
<span class="sd">   -------</span>

<span class="sd">   gr</span>

<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">edlist</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pos</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">edlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">gr</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edlist</span><span class="p">)</span>
    <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">g</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edlist</span><span class="p">}</span>
    <span class="n">gr</span><span class="o">.</span><span class="n">pos</span><span class="o">=</span><span class="n">dpos</span>
    <span class="k">return</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="frontline"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.frontline.html#pylayers.antprop.signature.frontline">[docs]</a><span class="k">def</span> <span class="nf">frontline</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">nc</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; determine cycle frontline</span>

<span class="sd">    This function calculates the scalar product of the normals of a cycle</span>
<span class="sd">    and returns the indev of segments whith are facing the given direction v.</span>
<span class="sd">    scalar product &lt; 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L : Layout</span>
<span class="sd">    nc : cycle number</span>
<span class="sd">    v : direction vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    nsegf : list</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">    &gt;&gt;&gt; L = Layout()</span>
<span class="sd">    &gt;&gt;&gt; L.dumpr()</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([1,1])</span>
<span class="sd">    &gt;&gt;&gt; frontline(L,0,v)</span>
<span class="sd">    [3, 4]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    run3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npt</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>  <span class="c"># points</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span> <span class="c"># segments</span>
    <span class="n">pt</span>  <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">npt</span> <span class="p">:</span> <span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="n">npt</span><span class="p">)</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>   <span class="c"># convert in ndarray</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Lr2n</span><span class="p">(</span><span class="n">pt1</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c"># get the normals of the cycle</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">v</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c"># scalar product with vector v</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ps</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>   <span class="c"># keep segment if scalar product &lt;0</span>
    <span class="n">nsegf</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">nseg</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nsegf</span>

</div>
<div class="viewcode-block" id="edgeout2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.edgeout2.html#pylayers.antprop.signature.edgeout2">[docs]</a><span class="k">def</span> <span class="nf">edgeout2</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; filter authorized Gi edges output</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L : Layout</span>
<span class="sd">    g : Digraph Gi</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">    This function checks that this sequence is feasible</span>
<span class="sd">    , whatever the type of nstr0 and nstr1.</span>
<span class="sd">    The feasible outputs from nstr0 to nstr1 are stored in an output field of</span>
<span class="sd">    edge (nstr0,nstr1)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># loop over all edges of Gi</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="c"># extract  both termination interactions nodes</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># list of authorized outputs, initialized void</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># nstr1 : segment number of final interaction</span>
        <span class="k">if</span> <span class="n">nstr1</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">pseg1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">nstr1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nstr0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">pseg0</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">nstr0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="c"># test if nstr0 and nstr1 are connected segments</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">nstr0</span><span class="p">),</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">nstr1</span><span class="p">)))</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                    <span class="c"># not connected</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># connected</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">from2csegs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr0</span><span class="p">])</span>
                <span class="n">cn</span><span class="o">.</span><span class="n">fromptseg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>

            <span class="c"># list all potential successor of interaction i1</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
            <span class="n">ipoints</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">,</span><span class="n">i2</span><span class="p">)</span>
            <span class="c">#istup = filter(lambda x : type(eval(x))==tuple,i2)</span>
            <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="n">i2</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isegments</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">isegments</span><span class="p">)</span>
                <span class="n">pta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span>
                <span class="n">phe</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">:,:]</span>
                <span class="c">#print points</span>
                <span class="c">#print segments</span>
                <span class="c">#cn.show()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="n">bs</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span><span class="n">phe</span><span class="p">)</span>
                    <span class="c">#if bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                    <span class="c">#if ~bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;k&#39;)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">Mpta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">Mphe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">bs</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">Mpta</span><span class="p">,</span><span class="n">Mphe</span><span class="p">)</span>
                    <span class="c">#print i0,i1</span>
                    <span class="c">#if ((i0 == (6, 0)) &amp; (i1 == (7, 0))):</span>
                    <span class="c">#    pdb.set_trace()</span>
                    <span class="c">#if bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                    <span class="c">#if ~bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;m&#39;)</span>
                    <span class="c">#    plt.show()</span>
                    <span class="c">#    pdb.set_trace()</span>

                <span class="n">isegkeep</span> <span class="o">=</span> <span class="n">isegments</span><span class="p">[</span><span class="n">bs</span><span class="p">]</span>
                <span class="n">output</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isegkeep</span> <span class="p">,</span><span class="n">i2</span><span class="p">)</span>
                <span class="c"># keep all segment above nstr1 and in Cone if T</span>
                <span class="c"># keep all segment below nstr1 and in Cone if R</span>

        <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">g</span><span class="p">)</span></div>
<div class="viewcode-block" id="edgeout"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.edgeout.html#pylayers.antprop.signature.edgeout">[docs]</a><span class="k">def</span> <span class="nf">edgeout</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; filter authorized Gi edges output</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L : Layout</span>
<span class="sd">    g : Digraph Gi</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">    This function checks that this sequence is feasible</span>
<span class="sd">    , whatever the type of nstr0 and nstr1.</span>
<span class="sd">    The feasible outputs from nstr0 to nstr1 are stored in an output field of</span>
<span class="sd">    edge (nstr0,nstr1)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># loop over all edges of Gi</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="c"># extract  both termination interactions nodes</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Transmission</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">typ</span><span class="o">=</span><span class="mi">2</span>
            <span class="c"># Reflexion</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">typ</span><span class="o">=</span><span class="mi">1</span>
        <span class="c"># Diffraction</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="c"># list of authorized outputs, initialized void</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># nstr1 : segment number of final interaction</span>
        <span class="k">if</span> <span class="n">nstr1</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c">#cn = cone.Cone()</span>
            <span class="c">#cn.from2segs(pseg0,pseg1)</span>
            <span class="c"># segment unitary vector</span>
            <span class="c"># l1 : unitary vector along structure segments</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seguv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nstr1</span><span class="p">]))</span>
            <span class="c">#</span>
            <span class="c"># unitary vector along the ray (nstr0,nstr1)</span>
            <span class="c">#</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr0</span><span class="p">])</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr1</span><span class="p">])</span>
            <span class="n">v01</span>  <span class="o">=</span> <span class="n">p1</span><span class="o">-</span><span class="n">p0</span>
            <span class="n">v01m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v01</span><span class="p">,</span><span class="n">v01</span><span class="p">))</span>
            <span class="n">v01n</span> <span class="o">=</span> <span class="n">v01</span><span class="o">/</span><span class="n">v01m</span>
            <span class="n">v10n</span> <span class="o">=</span> <span class="o">-</span><span class="n">v01n</span>
            <span class="c"># next interaction</span>
            <span class="c"># considering all neighbors of i1 in Gi</span>
            <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">i1</span><span class="p">)):</span>

                <span class="n">i2</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
                    <span class="n">nstr2</span> <span class="o">=</span> <span class="n">i2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nstr2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr2</span><span class="p">])</span>
                <span class="n">v12</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-</span><span class="n">p1</span>
                <span class="n">v12m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span><span class="n">v12</span><span class="p">))</span>
                <span class="n">v12n</span> <span class="o">=</span> <span class="n">v12</span><span class="o">/</span><span class="n">v12m</span>

                <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v01n</span><span class="p">,</span><span class="n">l1</span><span class="p">)</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">v12n</span><span class="p">)</span>

                <span class="c"># if (reflexion is forward) or (reflexion return to its origin)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">d1</span><span class="o">*</span><span class="n">d2</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nstr0</span> <span class="o">==</span> <span class="n">nstr2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">typ</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
<span class="c">#                elif d1*d2&gt;=-0.2 and typ ==2:</span>
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&lt;</span><span class="mf">0.9</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span> <span class="o">&lt;</span><span class="mf">0.9</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="n">d1</span><span class="o">*</span><span class="n">d2</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">:</span>
                            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i0</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span><span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</div>
<span class="k">class</span> <span class="nc">Signatures</span><span class="p">(</span><span class="n">PyLayers</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; set of Signature given 2 Gt cycle (convex) indices</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    L : gis.Layout</span>
<span class="sd">    source : int</span>
<span class="sd">        source convex cycle</span>
<span class="sd">    target : int</span>
<span class="sd">        target convex cycle</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Signatures.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__init__.html#pylayers.antprop.signature.Signatures.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        source : int</span>
<span class="sd">            cycle number</span>
<span class="sd">        target : int</span>
<span class="sd">            cycle index</span>
<span class="sd">        cutoff : int</span>
<span class="sd">            limiting depth level in graph exploration (default 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>
</div>
<div class="viewcode-block" id="Signatures.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__repr__.html#pylayers.antprop.signature.Signatures.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">fun1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s">&#39;D&#39;</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39;----------&#39;</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="c">#s = s + str(self.__sizeof__())+&#39;\n&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;from cycle : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; to cycle &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># nl x 2 x nsig</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;   &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;   &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.__len__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__len__.html#pylayers.antprop.signature.Signatures.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nsig</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span><span class="p">(</span><span class="n">nsig</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.num"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.num.html#pylayers.antprop.signature.Signatures.num">[docs]</a>    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine the number of signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsig</span> <span class="o">+=</span> <span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nint</span> <span class="o">+=</span> <span class="n">size</span><span class="o">*</span><span class="n">k</span>
</div>
<div class="viewcode-block" id="Signatures.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.info.html#pylayers.antprop.signature.Signatures.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># print &quot;Signatures for scenario defined by :&quot;</span>
        <span class="c"># print &quot;Layout&quot;</span>
        <span class="c"># print &quot;======&quot;</span>
        <span class="c"># L = self.L.info()</span>
        <span class="c"># print &quot;================================&quot;</span>
        <span class="c"># print &quot;source : &quot;, self.source</span>
        <span class="c"># print &quot;target : &quot;, self.target</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39;----------&#39;</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="c">#s = s + str(self.__sizeof__())+&#39;\n&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">print</span> <span class="s">&#39;from cycle : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; to cycle &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s">&#39;Reflection&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">BLUE</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;  &#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s">&#39;Transmission&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">GREEN</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;  &#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s">&#39;Diffraction&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;  </span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># nl x 2 x nsig</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>

                <span class="n">nstr</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">typ</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="k">print</span> <span class="s">&#39;[&#39;</span><span class="p">,</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">BLUE</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">GREEN</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;]&#39;</span>
            <span class="k">print</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="c"># s = s + &#39;   &#39;+ str(a[i,0,:]) + &#39;\n&#39;</span>

                <span class="c"># s = s + &#39;   &#39;+ str(a[i,1,:]) + &#39;\n&#39;</span>
</div>
<div class="viewcode-block" id="Signatures.saveh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.saveh5.html#pylayers.antprop.signature.Signatures.saveh5">[docs]</a>    <span class="k">def</span> <span class="nf">saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save signatures in hdf5 format</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>

        <span class="c"># try/except to avoid loosing the h5 file if</span>
        <span class="c"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;source&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when writting h5py file&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.loadh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.loadh5.html#pylayers.antprop.signature.Signatures.loadh5">[docs]</a>    <span class="k">def</span> <span class="nf">loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; load signatures hdf5 format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>

        <span class="c"># try/except to avoid loosing the h5 file if</span>
        <span class="c"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][:]})</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when reading h5py file&#39;</span><span class="p">)</span>


        <span class="n">_fileL</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.ini&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">_fileL</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Signatures._saveh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures._saveh5.html#pylayers.antprop.signature.Signatures._saveh5">[docs]</a>    <span class="k">def</span> <span class="nf">_saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save in hdf5 compliant with Links</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c"># if grpname == &#39;&#39;:</span>
        <span class="c">#     grpname = str(self.source) +&#39;_&#39;+str(self.target) +&#39;_&#39;+ str(self.cutoff)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># file management</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grpname</span> <span class="ow">in</span> <span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">grpname</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span> <span class="o">+</span><span class="s">&#39;already exists in &#39;</span><span class="o">+</span><span class="n">filenameh5</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span><span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>

            <span class="c"># write data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;source&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when writting h5py file&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures._loadh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures._loadh5.html#pylayers.antprop.signature.Signatures._loadh5">[docs]</a>    <span class="k">def</span> <span class="nf">_loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load signatures in hdf5 format compliant with class Links</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filenameh5 : string</span>
<span class="sd">            filename of the h5py file (from Links Class)</span>
<span class="sd">        grpname : string</span>
<span class="sd">            groupname of the h5py file (from Links Class)</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.links</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c"># if grpname ==&#39;&#39;:</span>
        <span class="c">#     grpname = str(self.source) +&#39;_&#39;+str(self.target) +&#39;_&#39;+ str(self.cutoff)</span>

        <span class="c"># try/except to avoid loosing the h5 file if</span>
        <span class="c"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span><span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][:]})</span>
            <span class="n">Lname</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when reading h5py file&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">Lname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Signatures.save"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.save.html#pylayers.antprop.signature.Signatures.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
          <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">L</span>
</div>
<div class="viewcode-block" id="Signatures.load"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.load.html#pylayers.antprop.signature.Signatures.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; load signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">sitmp</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span><span class="s">&#39; does not exist&#39;</span><span class="p">)</span>


        <span class="c"># to load a dictionary, use update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sitmp</span><span class="p">)</span>


        <span class="n">_fileL</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.ini&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">_fileL</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Signatures.sp"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.sp.html#pylayers.antprop.signature.Signatures.sp">[docs]</a>    <span class="k">def</span> <span class="nf">sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; algorithm for signature determination</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : Graph</span>
<span class="sd">        source : tuple or int</span>
<span class="sd">        target : tuple or int</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.antprop.signature.run3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">source</span><span class="p">])):</span>
                        <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                    <span class="c"># yield visited +[target]</span>
                <span class="k">elif</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">source</span><span class="p">])):</span>
                        <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>


</div>
<div class="viewcode-block" id="Signatures.procone"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.procone.html#pylayers.antprop.signature.Signatures.procone">[docs]</a>    <span class="k">def</span> <span class="nf">procone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target looking backward</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c">#print &quot;child : &quot;,child</span>
            <span class="c">#print &quot;visited :&quot;,visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span> <span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point - YIELD A SIGNATURE</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="c"># output signature</span>
                <span class="k">else</span><span class="p">:</span>
                <span class="c">#elif child not in visited: # else visit other node - CONTINUE APPEND CHILD</span>
                    <span class="c"># getting signature until last point</span>
                    <span class="n">diff</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span>
                    <span class="c"># looking backward with a cone</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                        <span class="c"># warning visited is also appended visited[-2] is the</span>
                        <span class="c"># last node</span>
                        <span class="n">brin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">evf</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                        <span class="n">ta</span><span class="p">,</span><span class="n">he</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
                        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                        <span class="n">segchild</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">segvm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">segchild</span><span class="p">,</span><span class="n">segvm1</span><span class="p">)</span>
                        <span class="n">typ</span><span class="p">,</span><span class="n">proba</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">ta</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="c">#fig,ax = plu.displot(ta,he)</span>
                        <span class="c">#fig,ax = cn.show(fig=fig,ax=ax)</span>
                        <span class="c">#plt.show()</span>
                        <span class="c">#pdb.set_trace()</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c"># child no valid (do nothing)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c"># child valid (append child to visited and go forward)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Signatures.short_propath"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.short_propath.html#pylayers.antprop.signature.Signatures.short_propath">[docs]</a>    <span class="k">def</span> <span class="nf">short_propath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; updated dijkstra</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">==</span><span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">({</span><span class="n">source</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]})</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># dictionary of final distances</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]}</span>  <span class="c"># dictionary of paths</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">fringe</span><span class="o">=</span><span class="p">[]</span> <span class="c"># use heapq with (distance,label) tuples</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">fringe</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="n">source</span><span class="p">))</span>
        <span class="n">firstloop</span><span class="o">=</span><span class="bp">True</span>
        <span class="k">while</span> <span class="n">fringe</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="n">oldv</span> <span class="o">=</span> <span class="n">v</span>
            <span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">=</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">fringe</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dist</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># already searched this node.</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c">#for ignore,w,edgedata in G.edges_iter(v,data=True):</span>
            <span class="c">#is about 30% slower than the following</span>
            <span class="k">if</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="n">edata</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">edata</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">oldv</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">edgedata</span> <span class="ow">in</span> <span class="n">edata</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weight</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                        <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">edgedata</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="c">#+ edgedata.get(weight,1) #&lt;= proba should be add here</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vw_dist</span><span class="o">&gt;</span><span class="n">cutoff</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vw_dist</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Contradictory paths found:&#39;</span><span class="p">,</span>
                                         <span class="s">&#39;negative weights?&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">or</span> <span class="n">vw_dist</span> <span class="o">&lt;</span> <span class="n">seen</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">seen</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">vw_dist</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">fringe</span><span class="p">,(</span><span class="n">vw_dist</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">firstloop</span><span class="o">=</span><span class="bp">False</span>


        <span class="k">if</span> <span class="n">paths</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dout</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])):</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">]])</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">dout</span>

</div>
<div class="viewcode-block" id="Signatures.propaths"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths.html#pylayers.antprop.signature.Signatures.propaths">[docs]</a>    <span class="k">def</span> <span class="nf">propaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="c"># import ipdb</span>
        <span class="c"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c"># update number of useful segments</span>
            <span class="c"># if there is airwall in visited</span>
            <span class="c">#</span>

            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="c"># output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                    <span class="c"># only visit output nodes except if bt</span>
                    <span class="c">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="c"># check if child (current segment) is an airwall</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="Signatures.propaths3"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths3.html#pylayers.antprop.signature.Signatures.propaths3">[docs]</a>    <span class="k">def</span> <span class="nf">propaths3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek shortest path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Gi : graph of interactions</span>
<span class="sd">        source : source interaction</span>
<span class="sd">        target : target interaction</span>
<span class="sd">        cutoff : cutoff</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nextlevel</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="n">Gi</span><span class="p">[</span><span class="n">source</span><span class="p">]}</span>   <span class="c"># list of nodes to check at next level</span>
        <span class="n">paths</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]}</span>         <span class="c"># paths dictionary  (paths to key from source)</span>

        <span class="k">while</span> <span class="n">nextlevel</span><span class="p">:</span>
            <span class="n">thislevel</span> <span class="o">=</span> <span class="n">nextlevel</span>
            <span class="n">nextlevel</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="c"># reach a node which is not in paths</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                        <span class="n">nextlevel</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                        <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">cutoff</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">):</span>  <span class="k">break</span>

</div>
<div class="viewcode-block" id="Signatures.propaths2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths2.html#pylayers.antprop.signature.Signatures.propaths2">[docs]</a>    <span class="k">def</span> <span class="nf">propaths2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dout : dictionnary</span>
<span class="sd">            key : int</span>
<span class="sd">               number of interactions</span>
<span class="sd">            values : list</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>


        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="c"># import ipdb</span>
        <span class="c"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>

            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c"># update number of useful segments</span>
            <span class="c"># if there is airwall in visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="c">#yield visited + [target] # output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                    <span class="c"># only visit output nodes except if bt</span>
                    <span class="c">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="c"># check if child (current segment) is an airwall</span>
                    <span class="c"># warning not efficient if many airwalls</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">dout</span>



    <span class="c"># def propaths2015(self,G, source, target,dout={}, cutoff=1):</span>
    <span class="c">#     &quot;&quot;&quot; seek all simple_path from source to target</span>

    <span class="c">#     Parameters</span>
    <span class="c">#     ----------</span>

    <span class="c">#     G : networkx Graph Gi</span>
    <span class="c">#     dout : dictionnary</span>
    <span class="c">#         ouput dictionnary</span>
    <span class="c">#     source : tuple</span>
    <span class="c">#         interaction (node of Gi)</span>
    <span class="c">#     target : tuple</span>
    <span class="c">#         interaction (node of Gi)</span>
    <span class="c">#     cutoff : int</span>
    <span class="c">#     bt : bool</span>
    <span class="c">#         allow backtrace (visite nodes already visited)</span>

    <span class="c">#     Returns</span>
    <span class="c">#     -------</span>

    <span class="c">#     dout : dictionnary</span>
    <span class="c">#         key : int</span>
    <span class="c">#            number of interactions</span>
    <span class="c">#         values : list of numpy array</span>



    <span class="c">#     Notes</span>
    <span class="c">#     -----</span>

    <span class="c">#     adapted from all_simple_path of networkx</span>

    <span class="c">#     1- Determine all nodes connected to Gi</span>

    <span class="c">#     &quot;&quot;&quot;</span>
    <span class="c">#     #print &quot;source :&quot;,source</span>
    <span class="c">#     #print &quot;target :&quot;,target</span>

    <span class="c">#     if cutoff &lt; 1:</span>
    <span class="c">#         return</span>


    <span class="c">#     visited = [source]</span>
    <span class="c">#     # stack is a list of iterators</span>
    <span class="c">#     stack = [iter(G[source])]</span>
    <span class="c">#     # lawp = list of airwall position in visited</span>
    <span class="c">#     lawp = []</span>

    <span class="c">#     # while the list of iterators is not void</span>
    <span class="c">#     # import ipdb</span>
    <span class="c">#     # ipdb.set_trace()</span>
    <span class="c">#     while stack: #</span>
    <span class="c">#         # children is the last iterator of stack</span>

    <span class="c">#         children = stack[-1]</span>
    <span class="c">#         # next child</span>

    <span class="c">#         child = next(children, None)</span>

    <span class="c">#         # update number of useful segments</span>
    <span class="c">#         # if there is airwall in visited</span>
    <span class="c">#         if child is None  : # if no more child</span>
    <span class="c">#             stack.pop()   # remove last iterator</span>
    <span class="c">#             visited.pop() # remove from visited list</span>
    <span class="c">#             try:</span>
    <span class="c">#                 lawp.pop()</span>
    <span class="c">#             except:</span>
    <span class="c">#                 pass</span>

    <span class="c">#         elif (len(visited) &lt; (cutoff + sum(lawp))):# if visited list length is less than cutoff</span>
    <span class="c">#             if child == target:  # if child is the target point</span>
    <span class="c">#                 #print visited + [target]</span>
    <span class="c">#                 path = visited + [target]</span>

    <span class="c">#                 try:</span>
    <span class="c">#                     dout[len(path)][0]=np.vstack((dout[len(path)][0],np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)))</span>
    <span class="c">#                 except:</span>
    <span class="c">#                     dout[len(path)]=[np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)]</span>

    <span class="c">#                 #yield visited + [target] # output signature</span>

    <span class="c">#             elif (child not in visited): # else visit other node</span>
    <span class="c">#                 # only visit output nodes except if bt</span>
    <span class="c">#                 #pdb.set_trace()</span>
    <span class="c">#                 try:</span>
    <span class="c">#                     dintpro = G[visited[-1]][child][&#39;output&#39;]</span>
    <span class="c">#                 except:</span>
    <span class="c">#                     dintpro ={}</span>
    <span class="c">#                 stack.append(iter(dintpro.keys()))</span>
    <span class="c">#                 #stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
    <span class="c">#                 visited.append(child)</span>
    <span class="c">#                 if child[0] in self.L.name[&#39;AIR&#39;]:</span>
    <span class="c">#                     lawp.append(1)</span>
    <span class="c">#                 else:</span>
    <span class="c">#                     lawp.append(0)</span>




    <span class="c">#         else: #len(visited) == cutoff (visited list is too long)</span>
    <span class="c">#             if child == target or target in children:</span>
    <span class="c">#                 path = visited + [target]</span>

    <span class="c">#                 try:</span>
    <span class="c">#                     dout[len(path)][0]=np.vstack((dout[len(path)][0],np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)))</span>
    <span class="c">#                 except:</span>
    <span class="c">#                     dout[len(path)]=[np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)]</span>

    <span class="c">#                 #print visited + [target]</span>
    <span class="c">#                 #yield visited + [target]</span>

    <span class="c">#             stack.pop()</span>
    <span class="c">#             visited.pop()</span>
    <span class="c">#             try:</span>
    <span class="c">#                 lawp.pop()</span>
    <span class="c">#             except:</span>
    <span class="c">#                 pass</span>
    <span class="c">#     return dout</span>

</div>
<div class="viewcode-block" id="Signatures.propaths2015_2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths2015_2.html#pylayers.antprop.signature.Signatures.propaths2015_2">[docs]</a>    <span class="k">def</span> <span class="nf">propaths2015_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span><span class="n">M</span><span class="o">=</span><span class="p">{},</span><span class="n">Mmap</span><span class="o">=</span><span class="p">[],</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dout : dictionnary</span>
<span class="sd">            key : int</span>
<span class="sd">               number of interactions</span>
<span class="sd">            values : list of numpy array</span>



<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>


        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># while the list of iterators is not void</span>
        <span class="c"># import ipdb</span>
        <span class="c"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>

            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c"># update number of useful segments</span>
            <span class="c"># if there is airwall in visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>


            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="c"># M = np.zeros((1,NGs),dtype=&#39;bool&#39;)</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

                    <span class="k">if</span> <span class="n">Mmap</span> <span class="o">!=</span><span class="p">[]:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">out</span><span class="p">]]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="n">M</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">out</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int16&#39;</span><span class="p">)))</span>
                        <span class="c"># dnvi[len(path)].append([[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()])</span>
                        <span class="c"># out = [i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]</span>
                        <span class="c"># M[path[-2][0],path[-1][0],out]=True</span>
                        <span class="c"># dnvi[len(path)]=np.vstack((dnvi[len(path)],M))</span>

                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int16&#39;</span><span class="p">)</span>
                        <span class="c"># dnvi[len(path)]=[[[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]</span>
                        <span class="c"># dnvi[len(path)]=M</span>

                    <span class="c">#yield visited + [target] # output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span> <span class="c"># else visit other node</span>
                    <span class="c"># only visit output nodes except if bt</span>
                    <span class="c">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="c"># if child == (56, 8, 14):</span>
                <span class="c">#     import ipdb</span>
                <span class="c">#     ipdb.set_trace()</span>
                <span class="c"># print list(children)</span>
                <span class="c"># print ((child == target) or (target in children))</span>

                <span class="n">CC</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">CC</span><span class="p">)):</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>

                    <span class="c"># M = np.zeros((1,NGs),dtype=&#39;bool&#39;)</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                    <span class="k">if</span> <span class="n">Mmap</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">out</span><span class="p">]]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">out</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int16&#39;</span><span class="p">)))</span>
                        <span class="c"># dnvi[len(path)].append([[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()])</span>
                        <span class="c"># dnvi[len(path)].append(np.unique([i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]))</span>
                        <span class="c"># M[:,[i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]=True</span>
                        <span class="c"># dnvi[len(path)]=np.vstack((dnvi[len(path)],M))</span>

                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int16&#39;</span><span class="p">)</span>
                        <span class="c"># dnvi[len(path)]=[[[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]</span>
                        <span class="c"># dnvi[len(path)]=[np.unique([i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()])]</span>
                        <span class="c"># M[:,[i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]=True</span>
                        <span class="c"># dnvi[len(path)]=M</span>

                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">dout</span>
</div>
<div class="viewcode-block" id="Signatures.procone2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.procone2.html#pylayers.antprop.signature.Signatures.procone2">[docs]</a>    <span class="k">def</span> <span class="nf">procone2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target looking backward</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c">#print &quot;child : &quot;,child</span>
            <span class="c">#print &quot;visited :&quot;,visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span> <span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point - YIELD A SIGNATURE</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target] # output signature</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                <span class="c">#elif child not in visited: # else visit other node - CONTINUE APPEND CHILD</span>
                    <span class="c"># getting signature until last point</span>
                    <span class="n">diff</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span>
                    <span class="c"># looking backward with a cone</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                        <span class="c"># warning visited is also appended visited[-2] is the</span>
                        <span class="c"># last node</span>
                        <span class="n">brin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">evf</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                        <span class="n">ta</span><span class="p">,</span><span class="n">he</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
                        <span class="n">segchild</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">segvm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">segchild</span><span class="p">,</span><span class="n">segvm1</span><span class="p">)</span>
                        <span class="n">typ</span><span class="p">,</span><span class="n">proba</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">ta</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">proba</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c"># child no valid (do nothing)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c"># child valid (append child to visited and go forward)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dout</span>

    <span class="c"># def propaths(self,G, source, target, cutoff=1, cutprob =0.5):</span>
    <span class="c">#     &quot;&quot;&quot; seek all simple_path from source to target</span>

    <span class="c">#     Parameters</span>
    <span class="c">#     ----------</span>

    <span class="c">#     G : networkx Graph Gi</span>
    <span class="c">#     source : tuple</span>
    <span class="c">#         interaction (node of Gi)</span>
    <span class="c">#     target : tuple</span>
    <span class="c">#         interaction (node of Gi)</span>
    <span class="c">#     cutoff : int</span>

    <span class="c">#     Notes</span>
    <span class="c">#     -----</span>

    <span class="c">#     adapted from all_simple_path of networkx</span>

    <span class="c">#     1- Determine all nodes connected to Gi</span>

    <span class="c">#     &quot;&quot;&quot;</span>
    <span class="c">#     #print &quot;source :&quot;,source</span>
    <span class="c">#     #print &quot;target :&quot;,target</span>

    <span class="c">#     if cutoff &lt; 1:</span>
    <span class="c">#         return</span>

    <span class="c">#     visited = [source]</span>
    <span class="c">#     # stack is a list of iterators</span>
    <span class="c">#     stack = [iter(G[source])]</span>
    <span class="c">#     ps = [iter([1.0]*len((G[source])))]</span>
    <span class="c">#     # lawp = list of airwall position in visited</span>
    <span class="c">#     lawp = []</span>

    <span class="c">#     # while the list of iterators is not void</span>
    <span class="c">#     # import ipdb</span>
    <span class="c">#     # ipdb.set_trace()</span>
    <span class="c">#     while stack: #</span>
    <span class="c">#         # children is the last iterator of stack</span>

    <span class="c">#         children = stack[-1]</span>
    <span class="c">#         pcd = ps[-1]</span>
    <span class="c">#         # next child</span>
    <span class="c">#         child = next(children, None)</span>
    <span class="c">#         pc = next(pcd,None)</span>
    <span class="c">#         # update number of useful segments</span>
    <span class="c">#         # if there is airwall in visited</span>
    <span class="c">#         #</span>

    <span class="c">#         if child is None  : # if no more child</span>
    <span class="c">#             stack.pop()   # remove last iterator</span>
    <span class="c">#             ps.pop()</span>
    <span class="c">#             visited.pop() # remove from visited list</span>
    <span class="c">#             try:</span>
    <span class="c">#                 lawp.pop()</span>
    <span class="c">#             except:</span>
    <span class="c">#                 pass</span>

    <span class="c">#         elif (pc&gt;cutprob): # check proba</span>
    <span class="c">#             if (len(visited) &lt; (cutoff + sum(lawp))):# if visited list length is less than cutoff</span>
    <span class="c">#                 if child == target:  # if child is the target point</span>
    <span class="c">#                     #print visited + [target]</span>
    <span class="c">#                     yield visited + [target] # output signature</span>
    <span class="c">#                 elif child not in visited: # else visit other node</span>
    <span class="c">#                     # only visit output nodes</span>
    <span class="c">#                     #pdb.set_trace()</span>
    <span class="c">#                     try:</span>
    <span class="c">#                         dintpro = G[visited[-1]][child][&#39;output&#39;]</span>
    <span class="c">#                     except:</span>
    <span class="c">#                         dintpro ={}</span>

    <span class="c">#                     # pnc : probability of next children</span>
    <span class="c">#                     # pc : proba of current parent</span>
    <span class="c">#                     # spnc : sum of proba of next children</span>

    <span class="c">#                     # spnc = sum(dintpro.values())</span>
    <span class="c">#                     pnc = [(v*pc) for v in dintpro.values()]</span>

    <span class="c">#                     stack.append(iter(dintpro.keys()))</span>
    <span class="c">#                     ps.append(iter(pnc))</span>
    <span class="c">#                     #stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
    <span class="c">#                     visited.append(child)</span>
    <span class="c">#                     # check if child (current segment) is an airwall</span>
    <span class="c">#                     if self.L.di[child][0] in self.L.name[&#39;AIR&#39;]:</span>
    <span class="c">#                         lawp.append(1)</span>
    <span class="c">#                     else:</span>
    <span class="c">#                         lawp.append(0)</span>


    <span class="c">#             else :</span>
    <span class="c">#                 stack.pop()</span>
    <span class="c">#                 ps.pop()</span>
    <span class="c">#                 visited.pop()</span>
    <span class="c">#                 lawp.pop()</span>

    <span class="c">#         else: #len(visited) == cutoff (visited list is too long)</span>
    <span class="c">#             if child == target or target in children:</span>
    <span class="c">#                 #print visited + [target]</span>
    <span class="c">#                 yield visited + [target]</span>

    <span class="c">#             stack.pop()</span>
    <span class="c">#             ps.pop()</span>
    <span class="c">#             visited.pop()</span>
    <span class="c">#             lawp.pop()</span>
</div>
<div class="viewcode-block" id="Signatures.calsig"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.calsig.html#pylayers.antprop.signature.Signatures.calsig">[docs]</a>    <span class="k">def</span> <span class="nf">calsig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="p">{},</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculates signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G   : graph</span>
<span class="sd">        dia : dictionnary of interactions</span>
<span class="sd">        cutoff : integer</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">di</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dia</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s">&#39;Tx&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s">&#39;Rx&#39;</span>
        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
<span class="c">#            pdb.set_trace()</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">lot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
<span class="c">#                    yield visited + [target]</span>
                <span class="k">elif</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
<span class="c">#                    yield visited + [target]</span>
                    <span class="n">lot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="Signatures.exist"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.exist.html#pylayers.antprop.signature.Signatures.exist">[docs]</a>    <span class="k">def</span> <span class="nf">exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; verifies if seq exists in signatures</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        seq : list or np.array()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span><span class="n">lf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="Signatures.run2015"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run2015.html#pylayers.antprop.signature.Signatures.run2015">[docs]</a>    <span class="k">def</span> <span class="nf">run2015</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoffbound</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; EXPERIMENTAL</span>
<span class="sd">            Vectorized approach of signature search</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        source: int (-1)</span>
<span class="sd">            source cycle .</span>
<span class="sd">            If =-1 =&gt; self.source used</span>
<span class="sd">        target: int (-1)</span>
<span class="sd">            target cycle .</span>
<span class="sd">            If =-1 =&gt; self.target used</span>
<span class="sd">        cutoff= int (1)</span>
<span class="sd">            max number of interactions per cycle</span>
<span class="sd">            except 1st and last cycle</span>
<span class="sd">        cutoffbound= int (1)</span>
<span class="sd">            max number of interactions in 1st and last cycle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing, fill self</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.simul.link import *</span>
<span class="sd">        &gt;&gt;&gt; L=Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; DL=DLink(L=L)</span>
<span class="sd">        &gt;&gt;&gt; DL.ca=8</span>
<span class="sd">        &gt;&gt;&gt; DL.Cb=13</span>
<span class="sd">        &gt;&gt;&gt; DL.eval(force=[&#39;sig&#39;,&#39;ray&#39;,&#39;Ct&#39;,&#39;H&#39;],alg=2015,si_reverb=3,cutoff=2,ra_vectorized=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="c"># list of cycle to reach source -&gt; target. this will be imporve next</span>
        <span class="n">lcil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="n">llcil</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="c"># G=nx.Graph(self.L.Gt)</span>

        <span class="c"># G.remove_node(0)</span>
        <span class="c"># lcil = nx.dijkstra_path(G,source,target)</span>
        <span class="c"># llcil=len(lcil)</span>

        <span class="c"># 2 determine input signatures for each cycles</span>
        <span class="c"># di key = [input seg, input room, output seg, output room]</span>
        <span class="n">di</span><span class="o">=</span><span class="p">{}</span>
        <span class="c"># number of points and seg of layout</span>
        <span class="n">NGs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Ns</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Np</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NGs</span><span class="p">,</span><span class="n">NGs</span><span class="p">,</span><span class="n">NGs</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>

        <span class="c">###</span>
        <span class="c">### Find interactions per cycles</span>
        <span class="c">###</span>
        <span class="k">if</span> <span class="n">llcil</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&#39;Signatures.run2015 doesn</span><span class="se">\&#39;</span><span class="s">t work when source==target&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">icy</span><span class="p">,</span><span class="n">cy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lcil</span><span class="p">):</span>

            <span class="n">vinT</span><span class="o">=</span><span class="p">[]</span>
            <span class="c"># valid &#39;out&#39; interatcion</span>
            <span class="n">voutT</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;merged&#39;</span><span class="p">):</span>
                <span class="n">cym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gc</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cym</span><span class="p">][</span><span class="s">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
                <span class="p">[</span><span class="n">inter</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="n">cy</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
            <span class="n">sGi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">inter</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">icy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># the interactions of 1st cycle are kept appart</span>
                <span class="c"># di0 = {}</span>

                <span class="n">outR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">outD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                <span class="n">vinT</span> <span class="o">=</span> <span class="n">outR</span> <span class="o">+</span> <span class="n">outD</span>

                <span class="n">kdi0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">voutT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">voutT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">voutT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

                <span class="c"># for each reverb/diffract interaction,</span>
                <span class="c"># inside 1st cycle, search the output interactions</span>

                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">voutT</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vinT</span><span class="p">:</span>
                        <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                    <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                    <span class="c"># add direct signature</span>
                    <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="c"># import ipdb</span>
                <span class="c"># ipdb.set_trace()</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&lt;</span><span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

                <span class="c"># valid &#39;in&#39; interatcion</span>

                <span class="c"># select input signatures in regard of selected</span>
                <span class="n">inR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">inD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>
                <span class="n">outR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">outD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>


                <span class="c"># keep only interactions in identified interesting cycles</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>

                <span class="c"># for each (identified interesting ) input interactions of the cycle</span>
                <span class="c"># find all path to each (identified interesting) output interactions</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vinT</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">voutT</span><span class="p">:</span>
                        <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                            <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                            <span class="c"># dni[i[0],i[1],i[2],o[0],o[1],o[2]] = ino</span>

            <span class="c"># the interactions of last cycle are kept appart</span>
            <span class="k">elif</span> <span class="n">icy</span> <span class="o">==</span> <span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="n">inR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">inD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">fcy</span><span class="p">)</span>
                <span class="n">voutT</span> <span class="o">=</span> <span class="n">inR</span> <span class="o">+</span> <span class="n">inD</span>
                <span class="n">kdif</span> <span class="o">=</span> <span class="p">(</span><span class="n">vinT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">vinT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">vinT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="c"># keep trace of last segments</span>
                <span class="n">sinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vinT</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vinT</span><span class="p">))])</span>
                <span class="c"># for each (identified interesting ) input interactions,</span>
                <span class="c"># find path to each reverb/diffract interaction of last cycle</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vinT</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">voutT</span><span class="p">:</span>
                        <span class="n">io</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                    <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
                    <span class="c"># add direct signature</span>
                    <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

                <span class="c"># dni[i[0],i[1],i[2],0,0,0] = ino</span>


        <span class="c"># dictionnary of interactions id keys</span>
        <span class="c"># interaction id key are build as tuple Transmission inter in ,</span>
        <span class="c"># Transmission interaction id input ,  Transmission interaction id output</span>
        <span class="c"># e.g. (34, 13, 12, 36, 12, 11).</span>
        <span class="c"># (0,0,0,X,X,X) stands for all interactions from the source</span>
        <span class="c"># (X,X,X,0,0,0) stands for all interactions from the target</span>
        <span class="n">kdi</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c"># Create 2 arrays with</span>
        <span class="c"># input and output interactions id respectively</span>
        <span class="n">adi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdi0</span><span class="p">)</span>
        <span class="n">adif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdif</span><span class="p">)</span>
        <span class="n">adi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">adii</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">adio</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">lsig</span><span class="o">=</span><span class="p">{}</span>

        <span class="c"># initialize loop on the 1st interaction id(0,0,0,X,X,X)</span>

        <span class="c"># uinit = np.unique(np.where(adi[:,:3]==0)[0])</span>
        <span class="n">uinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">oldout</span><span class="o">=</span><span class="n">uinit</span>
        <span class="n">stop</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">dsigiosave</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">dsigiosave</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]:</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uinit</span><span class="p">})</span>

        <span class="k">def</span> <span class="nf">filldinda</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d0</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kd1</span><span class="p">):</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">],</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span>

        <span class="n">firstloop</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>

            <span class="c"># for all detected valid output</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldout</span><span class="p">:</span>

                <span class="n">us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">adii</span><span class="o">-</span><span class="n">adio</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">keep</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">iuus</span><span class="p">,</span><span class="n">uus</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="p">:</span>
                    <span class="n">bue</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span><span class="o">==</span><span class="n">adi</span><span class="p">[</span><span class="n">out</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span>
                    <span class="n">ue</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bue</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ue</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iuus</span><span class="p">)</span>
                <span class="n">us</span> <span class="o">=</span> <span class="n">us</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

                <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="c">#     print ue</span>
                <span class="c">#     if len(ue) == 0:</span>
                <span class="c">#         keep.append(ue)</span>
                <span class="c">#</span>
                <span class="c">#     else:</span>
                <span class="c">#         pass</span>
                <span class="c"># import ipdb</span>
                <span class="c"># ipdb.set_trace()</span>
                <span class="c"># us=us[keep]</span>
                <span class="k">for</span> <span class="n">uus</span> <span class="ow">in</span> <span class="n">us</span><span class="p">:</span>
                    <span class="c"># 1st input interactions to all identified a outputs</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lsig</span><span class="o">=</span><span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:]]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">lsig</span> <span class="o">=</span> <span class="n">dsigiosave</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:]]</span>
                    <span class="c"># lni=dni[kdi[k]]</span>
                    <span class="n">sigio</span><span class="o">=</span><span class="p">{}</span>
                    <span class="c"># loop on input interactions</span>
                    <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">lsig</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c"># loop on output interactions</span>
                        <span class="k">for</span> <span class="n">ko</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                            <span class="c"># remove impossible signature in terms of cones</span>
                            <span class="n">lin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
                            <span class="n">lout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">])</span>
                            <span class="c"># manage case 1st interaction with no previous</span>

                            <span class="k">if</span> <span class="n">ki</span> <span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ko</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">uso</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">uout</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][:,</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],:][:,</span><span class="n">uout</span><span class="p">]</span>

                                <span class="n">suvi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uvi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">lin</span><span class="p">,</span><span class="n">lout</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
                                <span class="n">suvi</span> <span class="o">=</span> <span class="n">lin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lout</span><span class="p">)</span>

                            <span class="k">for</span> <span class="n">uv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lout</span><span class="p">):</span>
                                <span class="n">ri</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">uvi</span><span class="p">[:,</span><span class="n">uv</span><span class="p">]]</span>
                                <span class="n">ro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][</span><span class="n">uv</span><span class="p">],(</span><span class="n">suvi</span><span class="p">[</span><span class="n">uv</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

                                <span class="c"># ri = np.repeat(lsig[ki][uvi[:,uv]],suvi[uv],axis=0)</span>
                                <span class="c"># ro = np.tile(di[kdi[uus]][ko],(lin,1,1))</span>

                                <span class="c"># uvi=uvi.reshape(lin*lout,order=&#39;F&#39;)</span>

                                <span class="c"># ri=ri[uvi]</span>
                                <span class="c"># ro=ro[uvi]</span>

                                <span class="n">asig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ri</span><span class="p">,</span><span class="n">ro</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]))</span>

                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">asig</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">asig</span>

                            <span class="c"># ri = np.repeat(lsig[ki],lout,axis=0)</span>
                            <span class="c"># ro = np.tile(di[kdi[uus]][ko],(lin,1,1))</span>

                            <span class="c"># uvi=uvi.reshape(lin*lout,order=&#39;F&#39;)</span>

                            <span class="c"># ri=ri[uvi]</span>
                            <span class="c"># ro=ro[uvi]</span>

                            <span class="c"># asig=np.hstack((ri,ro[:,1:]))</span>

                            <span class="c"># try:</span>
                            <span class="c">#     sigio[ki+ko-1]=np.vstack((sigio[ki+ko-1],asig))</span>
                            <span class="c"># except:</span>
                            <span class="c">#     sigio[ki+ko-1]=asig</span>
                    <span class="c"># key is the output segment</span>
                    <span class="k">if</span> <span class="n">dsigio</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]):</span>
                        <span class="n">filldinda</span><span class="p">(</span><span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]],</span><span class="n">sigio</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]]</span><span class="o">=</span><span class="n">sigio</span>

            <span class="n">dsigiosave</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dsigio</span><span class="p">)</span>
            <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">firstloop</span><span class="o">=</span><span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">adi</span><span class="p">[</span><span class="n">out</span><span class="p">][:,</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">stop</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">break</span>

            <span class="n">oldout</span><span class="o">=</span><span class="n">out</span>
            <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span>



            <span class="c"># # attempt to limit the combinatory</span>
            <span class="n">survive1</span><span class="o">=</span><span class="n">adi</span><span class="p">[</span><span class="n">oldout</span><span class="p">][:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">survive2</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[</span><span class="n">oldout</span><span class="p">][:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># survive2 = np.ones((len(oldout)),dtype=bool)</span>
            <span class="n">survive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">survive1</span><span class="o">&amp;</span><span class="n">survive2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">oldout</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">oldout</span><span class="p">)[</span><span class="n">survive</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>




        <span class="n">sig</span><span class="o">=</span><span class="n">dsigiosave</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="c"># reshaping to be compliant with signatures format</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">}</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig2</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sig2</span><span class="p">)</span>
        <span class="c">#for debug</span>
        <span class="k">return</span> <span class="n">sig2</span>

</div>
<div class="viewcode-block" id="Signatures.run2015_2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run2015_2.html#pylayers.antprop.signature.Signatures.run2015_2">[docs]</a>    <span class="k">def</span> <span class="nf">run2015_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoffbound</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; EXPERIMENTAL</span>
<span class="sd">            Vectorized approach of signature search</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        source: int (-1)</span>
<span class="sd">            source cycle .</span>
<span class="sd">            If =-1 =&gt; self.source used</span>
<span class="sd">        target: int (-1)</span>
<span class="sd">            target cycle .</span>
<span class="sd">            If =-1 =&gt; self.target used</span>
<span class="sd">        cutoff= int (1)</span>
<span class="sd">            max number of interactions per cycle</span>
<span class="sd">            except 1st and last cycle</span>
<span class="sd">        cutoffbound= int (1)</span>
<span class="sd">            max number of interactions in 1st and last cycle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing, fill self</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.simul.link import *</span>
<span class="sd">        &gt;&gt;&gt; L=Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; DL=DLink(L=L)</span>
<span class="sd">        &gt;&gt;&gt; DL.ca=8</span>
<span class="sd">        &gt;&gt;&gt; DL.Cb=13</span>
<span class="sd">        &gt;&gt;&gt; DL.eval(force=[&#39;sig&#39;,&#39;ray&#39;,&#39;Ct&#39;,&#39;H&#39;],alg=2015,si_reverb=3,cutoff=2,ra_vectorized=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&#39;Signatures.run2015 doesn</span><span class="se">\&#39;</span><span class="s">t work when source==target&#39;</span><span class="p">)</span>
        <span class="c"># # approach 1</span>
        <span class="c"># # list of cycle to reach source -&gt; target. this will be imporve next</span>
        <span class="n">lcil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="n">llcil</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="c"># # approach 2</span>
        <span class="c"># # 2.1- make a shortest path from source to target cycles</span>
        <span class="c"># G=nx.Graph(self.L.Gt)</span>
        <span class="c"># G.remove_node(0)</span>
        <span class="c"># lcil = nx.dijkstra_path(G,source,target)</span>
        <span class="c"># llcil=len(lcil)</span>
        <span class="c"># nlcil=[]</span>
        <span class="c"># # 2.2- for all cycle in the shortest path, find cycle intersected</span>
        <span class="c"># for ll in range(llcil-1) :</span>
        <span class="c">#     nlcil.extend(self.L.cycleinline(lcil[ll],lcil[ll+1])[:-1])</span>
        <span class="c"># # add target exclued in the loop above</span>
        <span class="c"># nlcil.extend([target])</span>
        <span class="c"># lcil = nlcil</span>
        <span class="n">llcil</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="c"># 2 determine input signatures for each cycles</span>
        <span class="c"># di key = [input seg, input room, output seg, output room]</span>
        <span class="n">di</span><span class="o">=</span><span class="p">{}</span>
        <span class="c"># number of points and seg of layout</span>
        <span class="n">allpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span> <span class="p">))</span>
        <span class="c"># mapping segemnts</span>
        <span class="n">segmapp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span>
        <span class="c"># mapping diffraction</span>
        <span class="n">diffmapp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int16&#39;</span><span class="p">)</span>
        <span class="n">diffmapp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Ns</span><span class="o">+</span><span class="mi">1</span>
        <span class="c"># common mapping diff and segments</span>
        <span class="n">mapp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">segmapp</span><span class="p">,</span><span class="n">diffmapp</span><span class="p">))</span>
        <span class="n">lapt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">allpt</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lapt</span><span class="p">,</span><span class="n">lapt</span><span class="p">,</span><span class="n">lapt</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>

        <span class="c">###</span>
        <span class="c">### Find interactions per cycles</span>
        <span class="c">###</span>
        
        <span class="k">def</span> <span class="nf">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Difraction In Diffraction Out</span>
<span class="sd">                determine, for merged cycles, which diffrxtion</span>
<span class="sd">                points get out / in of a cycle</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">                cy : integer</span>
<span class="sd">                    cycle to investigate</span>
<span class="sd">                lcy : list</span>
<span class="sd">                    list of original cycles before merge ( in Gc)</span>

<span class="sd">            Return</span>
<span class="sd">            ------</span>
<span class="sd">                insideD: listr of diffraction inside cy</span>
<span class="sd">                inD: list of diffraction points in going in cy</span>
<span class="sd">                outD: list of diffraction points out going from cy</span>
<span class="sd">                ddin : a dcitionnary for naming ingoing diff poitns (points,cy in , cy out)</span>
<span class="sd">                dd : a dcitionnary for naming outgoing diff poitns (points,cy in , cy out)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lcy</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                <span class="n">lcy</span><span class="o">=</span><span class="p">[</span><span class="n">lcy</span><span class="p">]</span>

            <span class="n">outR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
            <span class="c"># keep diff points</span>
            <span class="n">D</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">ddin</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">ddout</span><span class="o">=</span><span class="p">{}</span>
            <span class="c"># outgoing diffraction</span>
            <span class="n">outD</span><span class="o">=</span><span class="p">[]</span>
            <span class="c"># ingoing diffraction</span>
            <span class="n">inD</span><span class="o">=</span><span class="p">[]</span>
            <span class="c"># inside cycle diffraction</span>
            <span class="n">insideD</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                <span class="c"># get cycles involved in diff point d</span>
                <span class="n">dcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ptGs2cy</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="c"># keep only current cycle and its merged neighbords in Gc</span>
                <span class="n">dcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">,</span><span class="n">dcy</span><span class="p">)</span>
                <span class="c"># remove the current cycle</span>
                <span class="n">dcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">cy</span><span class="p">,</span><span class="n">dcy</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span> <span class="p">(</span><span class="n">dcy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">outD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>
                    <span class="n">inD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>
                    <span class="k">for</span> <span class="n">ud</span> <span class="ow">in</span> <span class="n">dcy</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ddout</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">ud</span><span class="p">))</span>
                            <span class="n">ddin</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">ud</span><span class="p">,</span><span class="n">cy</span><span class="p">))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">ddout</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">=</span><span class="p">[(</span><span class="n">d</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">ud</span><span class="p">)]</span>
                            <span class="n">ddin</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">=</span><span class="p">[(</span><span class="n">d</span><span class="p">,</span><span class="n">ud</span><span class="p">,</span><span class="n">cy</span><span class="p">)]</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">insideD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span>

        <span class="k">for</span> <span class="n">icy</span><span class="p">,</span><span class="n">cy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lcil</span><span class="p">):</span>

            <span class="n">vinT</span><span class="o">=</span><span class="p">[]</span>
            <span class="c"># valid &#39;out&#39; interatcion</span>
            <span class="n">voutT</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;merged&#39;</span><span class="p">):</span>
                <span class="n">cym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gc</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cym</span><span class="p">][</span><span class="s">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
                <span class="p">[</span><span class="n">inter</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="n">cy</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
            <span class="n">sGi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">inter</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">icy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># the interactions of 1st cycle are kept appart</span>
                <span class="c"># di0 = {}</span>

                <span class="n">insideR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span><span class="o">=</span><span class="n">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">)</span>


                <span class="c"># outgoing inter</span>
                <span class="n">vout</span><span class="o">=</span><span class="n">voutT</span><span class="o">+</span><span class="n">outD</span>
                <span class="c"># inside inter</span>
                <span class="n">insideRD</span> <span class="o">=</span> <span class="n">insideR</span> <span class="o">+</span> <span class="n">insideD</span>
                <span class="c"># for each reverb/diffract interaction,</span>
                <span class="c"># inside 1st cycle, search the output interactions</span>

                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">vout</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">insideRD</span><span class="p">:</span>
                        <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                        <span class="c"># add direct signature</span>
                        <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="k">for</span> <span class="n">oo</span> <span class="ow">in</span> <span class="n">ddout</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                            <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                            <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&lt;</span><span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

                <span class="c"># valid &#39;in&#39; interatcion</span>

                <span class="c"># select input signatures in regard of selected</span>
                <span class="n">insideR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>
                <span class="n">insideR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>

                <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span><span class="o">=</span><span class="n">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">)</span>


                <span class="c"># keep only interactions in identified interesting cycles</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>

                <span class="c"># forbiden interactions</span>

                <span class="n">dfi</span><span class="o">=</span><span class="p">{}</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">inD</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dfi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dfi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

                <span class="c"># incoming Transmission and diffraction</span>
                <span class="n">vin</span> <span class="o">=</span> <span class="n">vinT</span> <span class="o">+</span> <span class="n">inD</span>
                <span class="c"># outgoing Transmission and diffraction</span>
                <span class="n">vout</span> <span class="o">=</span> <span class="n">voutT</span> <span class="o">+</span> <span class="n">outD</span>
                <span class="c"># for each (identified interesting ) input interactions of the cycle</span>
                <span class="c"># find all path to each (identified interesting) output interactions</span>
                
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vin</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">vout</span><span class="p">:</span>
                        <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                        <span class="c"># no difraction</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="c"># no backward</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">!=</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">!=</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                        <span class="c"># input diffraction</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dfi</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ddin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                    <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                        <span class="c"># output diffraction</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dfi</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                                <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">oo</span> <span class="ow">in</span> <span class="n">ddout</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                                    <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                        <span class="c"># input and output diffraction</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">!=</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">:</span>
                                <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ddin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                    <span class="k">for</span> <span class="n">oo</span> <span class="ow">in</span> <span class="n">ddout</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                                        <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                                <span class="c"># dni[i[0],i[1],i[2],o[0],o[1],o[2]] = ino</span>

            <span class="c"># the interactions of last cycle are kept appart</span>
            <span class="k">elif</span> <span class="n">icy</span> <span class="o">==</span> <span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="n">insideR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>
                
                <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span><span class="o">=</span><span class="n">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">)</span>


                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="c"># fcy = filter(lambda x: (cycle == x[2]) and (x[1] in lcil),inT)</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">fcy</span><span class="p">)</span>


                <span class="n">insideRD</span> <span class="o">=</span> <span class="n">insideR</span> <span class="o">+</span> <span class="n">insideD</span>
                <span class="n">vin</span> <span class="o">=</span> <span class="n">vinT</span> <span class="o">+</span> <span class="n">inD</span>

                <span class="c"># for each (identified interesting ) input interactions,</span>
                <span class="c"># find path to each reverb/diffract interaction of last cycle</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vin</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">insideRD</span><span class="p">:</span>
                            <span class="n">io</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                        <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
                        <span class="c"># add direct signature</span>
                        <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">:</span> 
                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">insideRD</span><span class="p">:</span>
                            <span class="n">io</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ddin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
                            <span class="c"># add direct signature</span>
                            <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="c"># dni[i[0],i[1],i[2],0,0,0] = ino</span>

        <span class="c"># dictionnary of interactions id keys</span>
        <span class="c"># interaction id key are build as tuple Transmission inter in ,</span>
        <span class="c"># Transmission interaction id input ,  Transmission interaction id output</span>
        <span class="c"># e.g. (34, 13, 12, 36, 12, 11).</span>
        <span class="c"># (0,0,0,X,X,X) stands for all interactions from the source</span>
        <span class="c"># (X,X,X,0,0,0) stands for all interactions from the target</span>
        <span class="n">kdi</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c"># Create 2 arrays with</span>
        <span class="c"># input and output interactions id respectively</span>
        <span class="n">adi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">adii</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">adio</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">lsig</span><span class="o">=</span><span class="p">{}</span>

        <span class="c"># initialize loop on the 1st interaction id(0,0,0,X,X,X)</span>

        <span class="c"># uinit = np.unique(np.where(adi[:,:3]==0)[0])</span>
        <span class="n">uinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">oldout</span><span class="o">=</span><span class="n">uinit</span>
        <span class="n">stop</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">dsigiosave</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">dsigiosave</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]:</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uinit</span><span class="p">})</span>

        <span class="k">def</span> <span class="nf">filldinda</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d0</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kd1</span><span class="p">):</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">],</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">filldinda2</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d0</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kd1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">kkd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kkd1</span><span class="p">):</span>
                            <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">],</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span>

        <span class="n">lastloop</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">outall</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="c"># for all detected valid output</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldout</span><span class="p">:</span>

                <span class="c"># if not last loop, </span>
                <span class="c"># find all the output interaction with a given in interaction (adi[k])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                    <span class="n">us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">adii</span><span class="o">-</span><span class="n">adio</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">keep</span><span class="o">=</span><span class="p">[]</span>
                    <span class="c"># remove output interaction already visited</span>
                    <span class="c"># for lightned computation</span>
                    <span class="k">for</span> <span class="n">iuus</span><span class="p">,</span><span class="n">uus</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">uus</span> <span class="ow">in</span> <span class="n">outall</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="n">adi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">lastloop</span><span class="p">:</span>
                                <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iuus</span><span class="p">)</span>
                                <span class="n">outall</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uus</span><span class="p">)</span>

                    <span class="n">us</span> <span class="o">=</span> <span class="n">us</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="c"># else output interaction is the inner interactions</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">us</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">uus</span> <span class="ow">in</span> <span class="n">us</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                        <span class="n">lsig</span> <span class="o">=</span> <span class="n">dsigiosave</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:]]</span>
                    <span class="k">else</span> <span class="p">:</span> 
                        <span class="n">lsig</span> <span class="o">=</span> <span class="n">dsigiosave</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="mi">3</span><span class="p">]]</span>
                    <span class="n">sigio</span><span class="o">=</span><span class="p">{}</span>
                    <span class="c"># loop on input interactions</span>
                    <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">lsig</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c"># loop on output interactions</span>
                        <span class="k">for</span> <span class="n">ko</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                          <span class="c"># remove impossible signature in terms of cones</span>
                            <span class="n">lin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
                            <span class="n">lout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">])</span>
                            <span class="c"># manage case 1st interaction with no previous</span>
                            <span class="k">if</span> <span class="n">ki</span> <span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ko</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">uso</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">uout</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][:,</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>

                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">mapp</span><span class="p">[</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]],</span><span class="n">mapp</span><span class="p">[</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],:][:,</span><span class="n">mapp</span><span class="p">[</span><span class="n">uout</span><span class="p">]]</span>
                                <span class="n">suvi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uvi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">lin</span><span class="p">,</span><span class="n">lout</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
                                <span class="n">suvi</span> <span class="o">=</span> <span class="n">lin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lout</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">uv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lout</span><span class="p">):</span>
                                <span class="n">ri</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">uvi</span><span class="p">[:,</span><span class="n">uv</span><span class="p">]]</span>
                                <span class="n">ro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][</span><span class="n">uv</span><span class="p">],(</span><span class="n">suvi</span><span class="p">[</span><span class="n">uv</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                                <span class="n">asig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ri</span><span class="p">,</span><span class="n">ro</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]))</span>

                                    <span class="c"># ri = lsig[ki][uvi[:,uv]]</span>
                                    <span class="c"># ro = np.tile(di[kdi[uus]][ko][uv],(suvi[uv],1,1))</span>

                                <span class="c"># ri = np.repeat(lsig[ki][uvi[:,uv]],suvi[uv],axis=0)</span>
                                <span class="c"># ro = np.tile(di[kdi[uus]][ko],(lin,1,1))</span>

                                <span class="c"># uvi=uvi.reshape(lin*lout,order=&#39;F&#39;)</span>

                                <span class="c"># ri=ri[uvi]</span>
                                <span class="c"># ro=ro[uvi]</span>


                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">asig</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">asig</span>

                    <span class="c"># key is the output segment</span>
                    <span class="k">if</span> <span class="n">dsigio</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]):</span>
                        <span class="n">filldinda</span><span class="p">(</span><span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]],</span><span class="n">sigio</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]]</span><span class="o">=</span><span class="n">sigio</span>

            <span class="n">filldinda2</span><span class="p">(</span><span class="n">dsigiosave</span><span class="p">,</span><span class="n">dsigio</span><span class="p">)</span>
            <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>


            <span class="k">if</span> <span class="n">lastloop</span><span class="p">:</span>
                <span class="n">stop</span><span class="o">=</span><span class="bp">True</span>
                <span class="k">break</span>

            <span class="n">oldout</span><span class="o">=</span><span class="n">out</span>
            <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span>

            <span class="k">if</span> <span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">lcil</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">lastloop</span><span class="o">=</span><span class="bp">True</span>

            <span class="c"># filtering for avoiding computing extra </span>
            <span class="c"># interaction in/out couples</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">adi</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">adi</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
            <span class="c"># input cycle interaction must be in the already visited list of cycles (lcil)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">|</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ii</span><span class="p">)</span>
            <span class="c"># output cycle interaction must be in the remaining list of cycles (lcil)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ii</span><span class="p">)</span>
            <span class="c"># output cycle interaction must bethe next cycle in  list of cycles (lcil)</span>
            <span class="c"># or code 0 for inner interaction of last cycle</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span> <span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">|</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ii</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">|</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">&amp;</span> <span class="n">tmp</span>
            <span class="c"># consider only insteraction from the current cycle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">adi</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="n">oldout</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>



        <span class="n">sig</span><span class="o">=</span><span class="n">dsigiosave</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="c"># reshaping to be compliant with signatures format</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">}</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sig2</span><span class="p">)</span>
        <span class="c">#for debug</span>
        <span class="k">return</span> <span class="n">sig2</span>
</div>
<div class="viewcode-block" id="Signatures.run"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run.html#pylayers.antprop.signature.Signatures.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; run signature calculation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">        dcut : int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lcil</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;run1&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run1</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;run2&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run2</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="n">dcut</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures.run1"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run1.html#pylayers.antprop.signature.Signatures.run1">[docs]</a>    <span class="k">def</span> <span class="nf">run1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dGi</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">buildGi2</span><span class="p">()</span>
        <span class="c"># all the vnodes &gt;0  from the room</span>
        <span class="c">#</span>
        <span class="c">#NroomTx = self.L.pt2ro(tx)</span>
        <span class="c">#NroomRx = self.L.pt2ro(rx)</span>
        <span class="c">#print NroomTx,NroomRx</span>

        <span class="c">#if not self.L.Gr.has_node(NroomTx) or not self.L.Gr.has_node(NroomRx):</span>
        <span class="c">#    raise AttributeError(&#39;Tx or Rx is not in Gr&#39;)</span>

        <span class="c"># list of interaction in roomTx</span>
        <span class="c"># list of interaction in roomRx</span>
        <span class="c">#ndt = self.L.Gt.node[self.L.Gr.node[NroomTx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
        <span class="c">#ndr = self.L.Gt.node[self.L.Gr.node[NroomRx][&#39;cycle&#39;]][&#39;inter&#39;]</span>

        <span class="n">metasig</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">metasig</span> <span class="o">+</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">metasig</span><span class="p">)))</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">metasig</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>

        <span class="c">#print &quot;metasig&quot;,metasig</span>

        <span class="c"># add cycles separated by air walls</span>
        <span class="n">lca</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">metasig</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lca</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">metasig</span> <span class="o">+</span> <span class="n">lca</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">metasig</span><span class="p">)))</span>

        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># source</span>
        <span class="c">#ndt1 = filter(lambda l: len(eval(l))&gt;2,ndt) # Transmission</span>
        <span class="c">#ndt2 = filter(lambda l: len(eval(l))&lt;3,ndt) # Reflexion</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">lisR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># target</span>
        <span class="c"># ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr) # Transmission</span>
        <span class="c"># ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr) # Reflexion</span>

        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">litR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># tx,rx : attaching rule</span>
        <span class="c">#</span>
        <span class="c"># tx attachs to out transmisision point</span>
        <span class="c"># rx attachs to in transmission point</span>

        <span class="c">#</span>
        <span class="c"># WARNING : room number &lt;&gt; cycle number</span>
        <span class="c">#</span>

        <span class="c">#ncytx = self.L.Gr.node[NroomTx][&#39;cycle&#39;]</span>
        <span class="c">#ncyrx = self.L.Gr.node[NroomRx][&#39;cycle&#39;]</span>

        <span class="c">#ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;ncytx,ndt1)</span>
        <span class="c">#ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;ncyrx,ndr1)</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>

        <span class="c">#ndt = ndt1 + ndt2</span>
        <span class="c">#ndr = ndr1 + ndr2</span>
        <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>
        <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>

        <span class="c">#ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        li = np.intersect1d(lis, lit)</span>

        <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">metasig</span><span class="p">:</span>
            <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ms</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">li</span><span class="p">)))</span>

        <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">li</span><span class="p">}</span>

        <span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">li</span><span class="p">)</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">dpos</span>
<span class="c">#        for meta in metasig:</span>
<span class="c">#        Gi = nx.DiGraph()</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi = nx.compose(Gi,self.L.dGi[cycle])</span>

<span class="c">#        # facultative update positions</span>
<span class="c">#        Gi.pos = {}</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi.pos.update(self.L.dGi[cycle].pos)</span>
<span class="c">#        pdb.set_trace()</span>
        <span class="c">#</span>
        <span class="c">#</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="c">#Gi = edgeout(self.L,Gi)</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">edgeout2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="c">#for interaction source  in list of source interaction</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">:</span>
            <span class="c">#for target interaction in list of target interaction</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lit</span><span class="p">:</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="c">#paths = list(nx.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="c">#paths = list(self.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>

                    <span class="c">#paths = [nx.shortest_path(Gi,source=s,target=t)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#paths = [[nt]]</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]]</span>
                <span class="c">### supress the followinfg loops .</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>

                    <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>

                        <span class="n">it</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#reflexion</span>
                                <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c">#transmission</span>
                                <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">2</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                        <span class="k">elif</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#diffraction</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                    <span class="c">#print sigarr</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">sigarr</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sigarr</span>
</div>
<div class="viewcode-block" id="Signatures.run4"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run4.html#pylayers.antprop.signature.Signatures.run4">[docs]</a>    <span class="k">def</span> <span class="nf">run4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo : string</span>
<span class="sd">            &#39;old&#39; | &#39;new&#39;</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># Determine meta signature</span>
        <span class="c"># this limits the number of cycles</span>

        <span class="c">#metasig = nx.neighbors(self.L.Gt,self.source)</span>
        <span class="c">#metasig = metasig + nx.neighbors(self.L.Gt,self.target)</span>
        <span class="c">#metasig = list(np.unique(np.array(metasig)))</span>
        <span class="c">#metasig = metasig + [self.source] + [self.target]</span>
        <span class="c"># add cycles separated by air walls</span>
        <span class="c">#lca=[]</span>
        <span class="c">#for cy in metasig:</span>
        <span class="c">#    try:</span>
        <span class="c">#        lca.extend(self.L.dca[cy])</span>
        <span class="c">#    except:</span>
        <span class="c">#        pass</span>
        <span class="c">#metasig = metasig + lca</span>
        <span class="c">#metasig = list(np.unique(np.array(metasig)))</span>

        <span class="c"># list of interaction source</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="c"># list of interaction target</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># source</span>
        <span class="c">#ndt1 = filter(lambda l: len(eval(l))&gt;2,ndt) # Transmission</span>
        <span class="c">#ndt2 = filter(lambda l: len(eval(l))&lt;3,ndt) # Reflexion</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">lisR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># target</span>
        <span class="c"># ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr) # Transmission</span>
        <span class="c"># ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr) # Reflexion</span>

        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">litR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># tx,rx : attaching rule</span>
        <span class="c">#</span>
        <span class="c"># tx attachs to out transmisision point</span>
        <span class="c"># rx attachs to in transmission point</span>

        <span class="c">#</span>
        <span class="c"># WARNING : room number &lt;&gt; cycle number</span>
        <span class="c">#</span>

        <span class="c">#ncytx = self.L.Gr.node[NroomTx][&#39;cycle&#39;]</span>
        <span class="c">#ncyrx = self.L.Gr.node[NroomRx][&#39;cycle&#39;]</span>

        <span class="c">#ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;ncytx,ndt1)</span>
        <span class="c">#ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;ncyrx,ndr1)</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>

        <span class="c">#ndt = ndt1 + ndt2</span>
        <span class="c">#ndr = ndr1 + ndr2</span>
        <span class="c"># list of interaction visible from source</span>
        <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>
        <span class="c"># list of interaction visible from target</span>
        <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>

        <span class="c">#ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        li = np.intersect1d(lis, lit)</span>

        <span class="c"># list of all interactions</span>
        <span class="c">#li = []</span>
        <span class="c">#for ms in metasig:</span>
        <span class="c">#    li = li + self.L.Gt.node[ms][&#39;inter&#39;]</span>
        <span class="c">#li = list(np.unique(np.array(li)))</span>
        <span class="c">#</span>
        <span class="c"># dictionnary interaction:position</span>
        <span class="c">#dpos = {k:self.L.Gi.pos[k] for k in li}</span>
        <span class="c"># extracting sub graph of Gi corresponding to metasiganture</span>
        <span class="c">#Gi = nx.subgraph(self.L.Gi,li)</span>
        <span class="c">#Gi.pos = dpos</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
<span class="c">#        for meta in metasig:</span>
<span class="c">#        Gi = nx.DiGraph()</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi = nx.compose(Gi,self.L.dGi[cycle])</span>

<span class="c">#        # facultative update positions</span>
<span class="c">#        Gi.pos = {}</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi.pos.update(self.L.dGi[cycle].pos)</span>
<span class="c">#        pdb.set_trace()</span>
        <span class="c">#</span>
        <span class="c"># TODO : This has to be changed for handling diffraction</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="c">#Gi = edgeout(self.L,Gi)</span>
        <span class="c">#Gi = edgeout2(self.L,Gi)</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interaction</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interaction</span>
            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="c">#paths = list(nx.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="c">#paths = list(self.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s">&#39;new&#39;</span><span class="p">:</span>
                        <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">procone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="p">))</span>

                    <span class="c">#paths = [nx.shortest_path(Gi,source=s,target=t)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#paths = [[nt]]</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]]</span>
                <span class="c">### suppress the following loops .</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>

                    <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="c">#print interaction + &#39;-&gt;&#39;,</span>
                        <span class="n">it</span> <span class="o">=</span> <span class="n">interaction</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#reflexion</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c">#transmission</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">2</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#diffraction</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                    <span class="c">#print sigarr</span>
                    <span class="c">#print &#39;&#39;</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">sigarr</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sigarr</span>

</div>
<div class="viewcode-block" id="Signatures.run5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run5.html#pylayers.antprop.signature.Signatures.run5">[docs]</a>    <span class="k">def</span> <span class="nf">run5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c"># lis=lis+lit</span>
        <span class="c"># lit=lis+lit</span>
        <span class="c">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s">&#39;new&#39;</span><span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">procone2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s">&#39;old&#39;</span> <span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s">&#39;dij&#39;</span><span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">short_propath</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                        <span class="c"># dout = self.short_propath(Gi,source=t,target=s,dout=dout,cutoff=cutoff)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dout</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">adout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">shad</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">adout</span><span class="p">)</span>
            <span class="c"># manage the case of signatures with only 1 interaction</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">adout</span> <span class="o">=</span> <span class="n">adout</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="n">shad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">adout</span><span class="p">)</span>
            <span class="c"># rehape (rays * 2 , interaction)</span>
            <span class="c"># the 2 dimensions come from the signature definition :</span>
            <span class="c"># 1st row = segment index</span>
            <span class="c"># 2nd row = type of interaction</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">adout</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shad</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">shad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>




</div>
<div class="viewcode-block" id="Signatures.run7mt"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run7mt.html#pylayers.antprop.signature.Signatures.run7mt">[docs]</a>    <span class="k">def</span> <span class="nf">run7mt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>
<span class="sd">            multithreaded version</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interactions</span>

        <span class="k">def</span> <span class="nf">pathfinder</span><span class="p">(</span><span class="n">dsig</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Gi</span><span class="p">):</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="c"># stack is a list of iterators</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">])]</span>
            <span class="c"># lawp = list of airwall position in visited</span>
            <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c"># while the list of iterators is not void</span>
            <span class="c"># import ipdb</span>
            <span class="c"># ipdb.set_trace()</span>
            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
                <span class="c"># children is the last iterator of stack</span>
                <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c"># next child</span>

                <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                <span class="c"># update number of useful segments</span>
                <span class="c"># if there is airwall in visited</span>
                <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>



                <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">)))</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">5</span>  <span class="p">:</span><span class="c"># if visited list length is less than cutoff</span>

                    <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                        <span class="c">#print visited + [target]</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                        <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dsig</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dsig</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">dsig</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                        <span class="c">#try:</span>
                        <span class="c">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                        <span class="c">#except:</span>
                        <span class="c">#    dout[len(path)]=[]</span>
                        <span class="c">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                        <span class="c">#yield visited + [target] # output signature</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                        <span class="c"># only visit output nodes except if bt</span>
                        <span class="c">#pdb.set_trace()</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">nexti</span>  <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="c">#prob  = Gi[visited[-1]][child][&#39;output&#39;].values()</span>
                            <span class="c">#nexti = map(lambda x:x[0]</span>
                            <span class="c">#               ,filter(lambda x</span>
                            <span class="c">#                       :x[1]&gt;threshold,zip(out,prob)))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">nexti</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nexti</span><span class="p">))</span>
                        <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="c"># check if child (current segment) is an airwall</span>
                        <span class="c"># warning not efficient if many airwalls</span>
                        <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                            <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



                <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                    <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                        <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dsig</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dsig</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                            <span class="n">dsig</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                        <span class="c">#print visited + [target]</span>
                        <span class="c">#yield visited + [target]</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>


        <span class="c"># import multiprocessing as mpc</span>
        <span class="kn">import</span> <span class="nn">threading</span> <span class="kn">as</span> <span class="nn">thg</span>

        <span class="c"># manager = mpc.Manager()</span>
        <span class="c"># dsig = manager.dict()</span>
        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="c"># p = mpc.Process(target=pathfinder, args=(dsig,s,t,Gi))</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">thg</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">pathfinder</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">Gi</span><span class="p">))</span>
                    <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># s==t</span>
                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>







</div>
<div class="viewcode-block" id="Signatures.run7"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run7.html#pylayers.antprop.signature.Signatures.run7">[docs]</a>    <span class="k">def</span> <span class="nf">run7</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>

                    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                    <span class="c"># stack is a list of iterators</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">])]</span>
                    <span class="c"># lawp = list of airwall position in visited</span>
                    <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c"># while the list of iterators is not void</span>
                    <span class="c"># import ipdb</span>
                    <span class="c"># ipdb.set_trace()</span>
                    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
                        <span class="c"># children is the last iterator of stack</span>
                        <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c"># next child</span>

                        <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                        <span class="c"># update number of useful segments</span>
                        <span class="c"># if there is airwall in visited</span>
                        <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>



                        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">)))</span> <span class="p">:</span><span class="c"># if visited list length is less than cutoff</span>
                            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                                <span class="c">#print visited + [target]</span>
                                <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                                <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="c">#try:</span>
                                <span class="c">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                                <span class="c">#except:</span>
                                <span class="c">#    dout[len(path)]=[]</span>
                                <span class="c">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                                <span class="c">#yield visited + [target] # output signature</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                                <span class="c"># only visit output nodes except if bt</span>
                                <span class="c">#pdb.set_trace()</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">nexti</span>  <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                    <span class="c"># keyprob  = Gi[visited[-1]][child][&#39;output&#39;].items()</span>
                                    <span class="c"># nexti = map(lambda x:x[0]</span>
                                    <span class="c">#               ,filter(lambda x</span>
                                    <span class="c">#                       :x[1]&gt;threshold,keyprob))</span>

                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">nexti</span> <span class="o">=</span> <span class="p">[]</span>

                                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nexti</span><span class="p">))</span>
                                <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                                <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                                <span class="c"># check if child (current segment) is an airwall</span>
                                <span class="c"># warning not efficient if many airwalls</span>
                                <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                                    <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



                        <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                                <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                                <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="c">#print visited + [target]</span>
                                <span class="c">#yield visited + [target]</span>

                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                <span class="k">else</span><span class="p">:</span> <span class="c"># s==t</span>
                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Signatures.run6"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run6.html#pylayers.antprop.signature.Signatures.run6">[docs]</a>    <span class="k">def</span> <span class="nf">run6</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="k">print</span> <span class="s">&quot;source,lis :&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">lis</span>
        <span class="k">print</span> <span class="s">&quot;target,lit :&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">nextlevel</span><span class="o">=</span><span class="p">{</span><span class="n">s</span><span class="p">:</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">]}</span>   <span class="c"># list of nodes to check at next level</span>
                    <span class="n">paths</span><span class="o">=</span><span class="p">{</span><span class="n">s</span><span class="p">:[</span><span class="n">s</span><span class="p">]}</span>         <span class="c"># paths dictionary  (paths to key from source)</span>

                    <span class="n">getout</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">while</span> <span class="n">nextlevel</span><span class="p">:</span>
                        <span class="n">thislevel</span> <span class="o">=</span> <span class="n">nextlevel</span>
                        <span class="n">nextlevel</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                                <span class="c"># reach a node which is not in paths</span>
                                <span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                                <span class="n">out</span>  <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                <span class="n">prob</span> <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                                <span class="n">nextlevel</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                                   <span class="p">,</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span>
                                                           <span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.6</span><span class="p">,</span><span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">prob</span><span class="p">)))</span>
                                <span class="c"># get to target</span>
                                <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                                    <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                                    <span class="n">getout</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="c">#del(paths[w])</span>
                                    <span class="k">try</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                    <span class="k">except</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                        <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">cutoff</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">):</span>  <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="c">#try:</span>
                    <span class="c">#    if [s[0],len(s)] not in dout[1]:</span>
                    <span class="c">#        dout[1].append([s[0],len(s)])</span>
                    <span class="c">#except:</span>
                    <span class="c">#    dout[1]=[]</span>
                    <span class="c">#    dout[1].append([s[0],len(s)])</span>
</div>
<div class="viewcode-block" id="Signatures.run2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run2.html#pylayers.antprop.signature.Signatures.run2">[docs]</a>    <span class="k">def</span> <span class="nf">run2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            cutoff : limit the exploration of all_simple_path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">            sigslist = numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="c">#        try:</span>
<span class="c">#            self.L.dGi</span>
<span class="c">#        except:</span>
<span class="c">#            self.L.buildGi2()</span>

        <span class="c"># all the vnodes &gt;0  from the room</span>
        <span class="c">#</span>
        <span class="c">#NroomTx = self.L.pt2ro(tx)</span>
        <span class="c">#NroomRx = self.L.pt2ro(rx)</span>
        <span class="c">#print NroomTx,NroomRx</span>

        <span class="c">#if not self.L.Gr.has_node(NroomTx) or not self.L.Gr.has_node(NroomRx):</span>
        <span class="c">#    raise AttributeError(&#39;Tx or Rx is not in Gr&#39;)</span>

        <span class="c"># list of interaction in roomTx</span>
        <span class="c"># list of interaction in roomRx</span>
        <span class="c">#ndt = self.L.Gt.node[self.L.Gr.node[NroomTx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
        <span class="c">#ndr = self.L.Gt.node[self.L.Gr.node[NroomRx][&#39;cycle&#39;]][&#39;inter&#39;]</span>


<span class="c">#        lisT = filter(lambda l: len(eval(l))&gt;2,lis) # Transmission</span>
<span class="c">#        lisR = filter(lambda l: len(eval(l))&lt;3,lis) # Reflexion</span>

<span class="c">#        # target</span>
<span class="c">#        # ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr) # Transmission</span>
<span class="c">#        # ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr) # Reflexion</span>

<span class="c">#        litT = filter(lambda l: len(eval(l))&gt;2,lit) # Transmission</span>
<span class="c">#        litR = filter(lambda l: len(eval(l))&lt;3,lit) # Reflexion</span>

<span class="c">#        # tx,rx : attaching rule</span>
<span class="c">#        #</span>
<span class="c">#        # tx attachs to out transmisision point</span>
<span class="c">#        # rx attachs to in transmission point</span>

<span class="c">#        #</span>
<span class="c">#        # WARNING : room number &lt;&gt; cycle number</span>
<span class="c">#        #</span>

<span class="c">#        #ncytx = self.L.Gr.node[NroomTx][&#39;cycle&#39;]</span>
<span class="c">#        #ncyrx = self.L.Gr.node[NroomRx][&#39;cycle&#39;]</span>

<span class="c">#        #ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;ncytx,ndt1)</span>
<span class="c">#        #ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;ncyrx,ndr1)</span>

<span class="c">#        lisT = filter(lambda l: eval(l)[2]&lt;&gt;self.source,lisT)</span>
<span class="c">#        litT = filter(lambda l: eval(l)[1]&lt;&gt;self.target,litT)</span>

<span class="c">#        #ndt = ndt1 + ndt2</span>
<span class="c">#        #ndr = ndr1 + ndr2</span>
<span class="c">#        lis  = lisT + lisR</span>
<span class="c">#        lit  = litT + litR</span>

<span class="c">#        #ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        li = np.intersect1d(lis, lit)</span>


<span class="c">#        for meta in metasig:</span>
<span class="c">#            Gi = nx.DiGraph()</span>
<span class="c">#            for cycle in meta:</span>
<span class="c">#                Gi = nx.compose(Gi,self.L.dGi[cycle])</span>
<span class="c">#            # facultative update positions</span>
<span class="c">#            Gi.pos = {}</span>
<span class="c">#            for cycle in meta:</span>
<span class="c">#                Gi.pos.update(self.L.dGi[cycle].pos)</span>
<span class="c">#            #</span>
<span class="c">#            #</span>
<span class="c">#            #</span>
<span class="c">#        metasig=self.lineofcycle(cs,ct)</span>

<span class="c">############################################################</span>
<span class="c">##</span>
<span class="c">##      1. the sequence of cycle between cycle source cs and</span>
<span class="c">##      cycle target ct are obtained via cycleinline method</span>
<span class="c">##</span>
<span class="c">##      2. all cycles adjscent at least to one of the previously</span>
<span class="c">##      obtained cycles are appended to the list lca (list of cycle around)</span>
<span class="c">##</span>
<span class="c">##      3. It is then required to add all cycles</span>
<span class="c">##      connected to the previous ones via an air wall.</span>
<span class="c">##</span>
<span class="c">##      lca is used to build the sliding graph of interactions</span>
<span class="c">##      it is important that lcil remains ordered this is not the case</span>
<span class="c">##      for lca</span>



        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="n">lcil</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># list of cycle around</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
            <span class="n">ncy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="n">cy</span><span class="p">)</span>
            <span class="n">lca</span> <span class="o">=</span> <span class="n">lca</span><span class="o">+</span><span class="n">ncy</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lca</span><span class="p">)))</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="n">lcil</span>
        <span class="n">lcair</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lca</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lcair</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="n">lca</span> <span class="o">+</span> <span class="n">lcair</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lca</span><span class="p">)))</span>
        <span class="c">#</span>
        <span class="c"># extract list of interactions from list of cycles lca</span>
        <span class="c">#</span>
        <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">lca</span><span class="p">:</span>
            <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ms</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="c"># enforce unicity of interactions in list li</span>
        <span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">li</span><span class="p">)))</span>

        <span class="c"># extract dictionnary of interactions position</span>
        <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">li</span><span class="p">}</span>

        <span class="c"># build the subgraph of L.Gi with only the selected interactions</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">li</span><span class="p">)</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">dpos</span>

        <span class="n">Gf</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># remove diffractions points from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">edgeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c">#for interaction source  in list of source interaction</span>

<span class="c">############################################################</span>
<span class="c">#        filter list of interactions in termination cycles</span>

        <span class="c"># list of interactions belonging to source</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># list of interactions belonging to target</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># filter lis remove transmission coming from outside</span>
        <span class="n">lli</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lisR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisTo</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="n">cs</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">lli</span> <span class="o">=</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisTo</span>
        <span class="c"># for li in lis:</span>
        <span class="c">#     ei = eval(li)</span>
        <span class="c">#     if len(ei)==2:</span>
        <span class="c">#        lli.append(li)</span>
        <span class="c">#    if len(ei)==3:</span>
        <span class="c">#        if ei[2]&lt;&gt;cs:</span>
        <span class="c">#           lli.append(li)</span>
        <span class="c"># filter lit remove transmission going outside</span>
        <span class="n">llt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">litR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litTi</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">ct</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>
        <span class="n">llt</span> <span class="o">=</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litTi</span>
        <span class="c">#for li in lit:</span>
        <span class="c">#    ei = eval(li)</span>
        <span class="c">#    if len(ei)==2:</span>
        <span class="c">#        llt.append(li)</span>
        <span class="c">#    if len(ei)==3:</span>
        <span class="c">#        if ei[2]==ct:</span>
        <span class="c">#           llt.append(li)</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="n">lli</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="n">llt</span>


<span class="c">#################################################</span>
<span class="c">#       propaths (a.k.a. all simple path) per adjacent cycles along cycles in line</span>
<span class="c">#       Obtaining Gf: filtred graph of Gi with Gc ( rename Gt in Gc )</span>

        <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">lsource</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ltarget</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">linter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
            <span class="c"># determine list of sources</span>
            <span class="k">if</span> <span class="n">ic</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">]][</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;segment&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                    <span class="n">lsource</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">lis</span>

            <span class="c"># determine list of targets</span>
            <span class="k">if</span> <span class="n">ic</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c">#if ic+3 &lt; len(lcil)-1:</span>
                <span class="n">lt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">]][</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">2</span><span class="p">]][</span><span class="s">&#39;segment&#39;</span><span class="p">]</span>
                <span class="c">#lt = self.L.Gt[lcil[ic+2]][lcil[ic+3]][&#39;segment&#39;]</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">lt</span><span class="p">:</span>
                    <span class="n">ltarget</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">target</span> <span class="p">,</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">2</span><span class="p">])))</span>
                    <span class="c">#ltarget.append(str((target , lcil[ic+2], lcil[ic+3])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">lit</span>

            <span class="n">lt</span>   <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">linter</span><span class="p">)</span>
            <span class="c">#lti = filter(lambda l: eval(l)[2]==lcil[ic+1],lt)</span>
            <span class="n">lto</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span><span class="n">lt</span><span class="p">)</span>
            <span class="n">ltom</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">lto</span><span class="p">)</span>
            <span class="n">ltomp</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">ltom</span><span class="p">)</span>

            <span class="n">lsource</span> <span class="o">=</span> <span class="n">lsource</span> <span class="o">+</span> <span class="n">ltomp</span>
            <span class="c">#pdb.set_trace()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lsource</span> <span class="p">:</span>
                <span class="c">#print s</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ltarget</span><span class="p">:</span>
                    <span class="c">#print t</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">itm1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">itm1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">itm1</span><span class="p">)</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="k">if</span> <span class="n">it</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">itm1</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
                            <span class="n">itm1</span> <span class="o">=</span> <span class="n">it</span>
<span class="c">#                        else:</span>
<span class="c">#                            #paths = [[nt]]</span>
<span class="c">#                            paths = [[s]]</span>


<span class="c">################################################################</span>
<span class="c">#       Obtain position of centroid of cycles source and target</span>


        <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Tx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pcs</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Rx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pct</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="c"># a =[ 0,  1,  2,  1,  4,  1,  6,  1,  8,  1, 10, 1]</span>
        <span class="c"># aa = np.array(a)</span>
        <span class="c"># X=aa.reshape((2,3,2)) # r x i x 2</span>
        <span class="c"># Y=X.swapaxes(0,2) # 2 x i x r</span>



        <span class="bp">self</span><span class="o">.</span><span class="n">Gf</span> <span class="o">=</span> <span class="n">Gf</span>
        <span class="k">print</span> <span class="s">&#39;signatures&#39;</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calsig</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">di</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">co</span><span class="o">+</span><span class="n">dcut</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">:</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">ns</span><span class="o">/</span><span class="n">k</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">nbi</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nbi</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>


        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span>
            <span class="n">a</span><span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">nbr</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbr</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.run3"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run3.html#pylayers.antprop.signature.Signatures.run3">[docs]</a>    <span class="k">def</span> <span class="nf">run3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            cutoff : limit the exploration of all_simple_path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">            sigslist = numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

<span class="c">############################################################</span>
<span class="c">##</span>
<span class="c">##      1. the sequence of cycle between cycle source cs and</span>
<span class="c">##      cycle target ct are obtained via cycleinline method</span>
<span class="c">##</span>
<span class="c">##      2. all cycles adjscent at least to one of the previously</span>
<span class="c">##      obtained cycles are appended to the list lca (list of cycle around)</span>
<span class="c">##</span>
<span class="c">##      3. It is then required to add all cycles</span>
<span class="c">##      connected to the previous ones via an air wall.</span>
<span class="c">##</span>
<span class="c">##      lca is used to build the sliding graph of interactions</span>
<span class="c">##      it is important that lcil remains ordered this is not the case</span>
<span class="c">##      for lca</span>

        <span class="c"># cs : cycle source</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="c"># ct : cycle target</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="c"># cps : centroid point source</span>
        <span class="n">cps</span> <span class="o">=</span> <span class="n">polys</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">polyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="c"># cpt : centroid point target</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="n">polyt</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cpt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cpt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-</span><span class="n">ps</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">mv</span>
        <span class="n">lcil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="n">ct</span><span class="p">)</span>

        <span class="c"># dac : dictionary of adjascent cycles</span>
        <span class="n">dac</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># dfl : dictionnary of fronlines</span>
        <span class="n">dfl</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
            <span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">nghb</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="n">cy</span><span class="p">)</span>
            <span class="n">dac</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span> <span class="o">=</span> <span class="n">nghb</span>
            <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">cp1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

            <span class="k">for</span> <span class="n">cya</span> <span class="ow">in</span> <span class="n">nghb</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cy</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
                    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cya</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
                <span class="n">cp2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">vp</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-</span><span class="n">p1</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p2</span><span class="o">-</span><span class="n">p1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="o">-</span><span class="n">p1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">vpn</span> <span class="o">=</span> <span class="n">vp</span><span class="o">/</span><span class="n">m2</span>
                <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vpn</span><span class="p">,</span><span class="n">vn</span><span class="p">)</span>
                <span class="c"># if dot(vn,vpn) &gt;0 cycle cya is ahead</span>
                <span class="k">if</span> <span class="n">dp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">lsegso</span> <span class="o">=</span> <span class="n">frontline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">vn</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lsegso</span><span class="p">:</span>
                        <span class="n">cyb</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">cy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s">&#39;ncycles&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">cyb</span><span class="o">&lt;&gt;</span><span class="p">[]:</span>
                            <span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">s</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">cyb</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c"># # list of interactions belonging to source</span>
        <span class="c"># lis = self.L.Gt.node[lcil[0]][&#39;inter&#39;]</span>

        <span class="c"># # list of interactions belonging to target</span>
        <span class="c"># lit = self.L.Gt.node[lcil[-1]][&#39;inter&#39;]</span>

        <span class="c"># # filter lis remove incoming transmission</span>
        <span class="c"># lli   = []</span>
        <span class="c"># lisR  = filter(lambda l: len(eval(l))==2,lis)</span>
        <span class="c"># lisT  = filter(lambda l: len(eval(l))==3,lis)</span>
        <span class="c"># lisTo = filter(lambda l: eval(l)[2]&lt;&gt;cs,lisT)</span>
        <span class="c"># lis = lisR + lisTo</span>

        <span class="c"># # filter lit remove outgoing transmission</span>
        <span class="c"># llt = []</span>
        <span class="c"># litR  = filter(lambda l: len(eval(l))==2,lit)</span>
        <span class="c"># litT  = filter(lambda l: len(eval(l))==3,lit)</span>
        <span class="c"># litTi = filter(lambda l: eval(l)[2]==ct,litT)</span>
        <span class="c"># lit = litR + litT</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">icy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="n">io</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">icy</span><span class="p">]]</span>
            <span class="n">io_</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">icy</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">print</span> <span class="n">io</span>
            <span class="k">print</span> <span class="n">io_</span>
            <span class="k">if</span> <span class="n">icy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:[[</span><span class="n">k</span><span class="p">]]})</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">io</span><span class="p">]</span>

            <span class="c"># remove keys which are not in front line</span>
            <span class="c"># kds = self.ds.keys()</span>
            <span class="c"># for k in kds :</span>
            <span class="c">#     if k not in io:</span>
            <span class="c">#         self.ds.pop(k)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">io_</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">[[]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">io</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># [self.ds.pop(k) for k in io]</span>

                    <span class="c"># ds[j]</span>
                    <span class="c"># if len(a) == 1:</span>
                    <span class="c">#     if len(ds[j]) &lt;&gt; 0:</span>
                    <span class="c">#         pdb.set_trace()</span>
                    <span class="c">#         [ds[j][k].extend(a[0][:-1]) for k in range(len(ds[j]))]</span>
                    <span class="c">#     else :</span>
                    <span class="c">#         ds[j]=a[0][:-1]</span>
                    <span class="c"># elif len(a)&gt; 1:</span>
                    <span class="c">#     if len(ds[j]) &lt;&gt; 0:</span>
                    <span class="c">#         [[ds[j][k].extend(a[l][:-1]) for k in range(len(ds[j]))] for l in range(len(a))]</span>
                    <span class="c">#     else :</span>
                    <span class="c">#         ds[j]=a[:-1]</span>


            <span class="c"># remove segments which separate two cycles.</span>
            <span class="c"># TODO: See if it worth to implement</span>
            <span class="c">#lsegs = filter(lambda x : x not in interseg,lsegs)</span>
        <span class="c"># add adjascent air cycles</span>
        <span class="c">#lcair=[]</span>
        <span class="c">#for cy in lcil:</span>
        <span class="c">#    try:</span>
        <span class="c">#        lcair.extend(self.L.dca[cy])</span>
        <span class="c">#    except:</span>
        <span class="c">#        pass</span>
        <span class="c">#lca = lca + lcair</span>
        <span class="c">#lca = list(np.unique(np.array(lca)))</span>

        <span class="c">#</span>
        <span class="c"># Reduction of Gi</span>
        <span class="c">#</span>

        <span class="c">#</span>
        <span class="c"># extract list of interactions from list of cycles lca</span>
        <span class="c">#</span>

        <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">dac</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cya</span> <span class="ow">in</span> <span class="n">dac</span><span class="p">[</span><span class="n">cy</span><span class="p">]:</span>
                <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cya</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="c"># enforce unicity of interactions in list li</span>
        <span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">li</span><span class="p">)))</span>

        <span class="c"># extract dictionnary of interactions position</span>
        <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">li</span><span class="p">}</span>

        <span class="c"># build the subgraph of L.Gi with only the selected interactions</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">li</span><span class="p">)</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">dpos</span>

        <span class="c"># remove diffractions points from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">edgeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c">#for interaction source  in list of source interaction</span>

<span class="c">############################################################</span>
<span class="c">#        filter list of interactions in termination cycles</span>

        <span class="c"># list of interactions belonging to source</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># list of interactions belonging to target</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># filter lis remove incoming transmission</span>
        <span class="n">lli</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lisR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisTo</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="n">cs</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisTo</span>

        <span class="c"># filter lit remove outgoing transmission</span>
        <span class="n">llt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">litR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litTi</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">ct</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litTi</span>

<span class="c">#################################################</span>
<span class="c">#       propaths (a.k.a. all simple path) per adjacent cycles along cycles in line</span>
<span class="c">#       Obtaining Gf: filtred graph of Gi with Gc ( rename Gt in Gc )</span>

        <span class="c">#</span>
        <span class="c"># Gf : filtered graph</span>
        <span class="c">#</span>
        <span class="n">Gf</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ncycles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="n">ltarget</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lsource</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncycles</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="c"># determine list of sources and targets</span>
            <span class="c"># The famous so called saute mouton algorithm</span>
            <span class="k">if</span> <span class="n">ic</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">lis</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="n">ic</span><span class="o">==</span><span class="n">ncycles</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">ltarget</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">lit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">ltarget</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lsource</span> <span class="p">:</span>
                <span class="c">#print s</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ltarget</span><span class="p">:</span>
                    <span class="c">#print t</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">itm1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">itm1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">itm1</span><span class="p">)</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="k">if</span> <span class="n">it</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">itm1</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
                            <span class="n">itm1</span> <span class="o">=</span> <span class="n">it</span>


<span class="c">################################################################</span>
<span class="c">#       Obtain position of centroid of cycles source and target</span>

        <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Tx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pcs</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Rx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pct</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">culdesac</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">culdesac</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">culdesac</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">culdesac</span><span class="p">)</span>
                <span class="k">print</span> <span class="n">culdesac</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c"># a =[ 0,  1,  2,  1,  4,  1,  6,  1,  8,  1, 10, 1]</span>
        <span class="c"># aa = np.array(a)</span>
        <span class="c"># X=aa.reshape((2,3,2)) # r x i x 2</span>
        <span class="c"># Y=X.swapaxes(0,2) # 2 x i x r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gf</span> <span class="o">=</span> <span class="n">Gf</span>
        <span class="k">print</span> <span class="s">&#39;signatures&#39;</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calsig</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">di</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">co</span><span class="o">+</span><span class="n">dcut</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">:</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">ns</span><span class="o">/</span><span class="n">k</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">nbi</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nbi</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>


        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span>
            <span class="n">a</span><span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">nbr</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbr</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="Signatures.meta"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.meta.html#pylayers.antprop.signature.Signatures.meta">[docs]</a>    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span>
        <span class="c"># metasig = list(nx.all_simple_paths(self.L.Gt,source=self.source,target=self.target,cutoff=cutoff))</span>
        <span class="c">#for cutoff in range(1,5):</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">metasig</span><span class="p">:</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">c</span><span class="p">))))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">d</span><span class="p">))))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures.lineofcycle"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.lineofcycle.html#pylayers.antprop.signature.Signatures.lineofcycle">[docs]</a>    <span class="k">def</span> <span class="nf">lineofcycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cs</span><span class="o">=</span><span class="p">[],</span><span class="n">ct</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; shortest path between 2 cycles</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cs : list</span>
<span class="sd">        ct : list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cs</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">cs</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">ct</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.cones"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.cones.html#pylayers.antprop.signature.Signatures.cones">[docs]</a>    <span class="k">def</span> <span class="nf">cones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="p">[],</span><span class="n">ax</span><span class="o">=</span><span class="p">[],</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; display cones of an unfolded signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : int</span>
<span class="sd">            the interaction block</span>
<span class="sd">        s : int</span>
<span class="sd">            the signature number in the block</span>
<span class="sd">        fig :</span>
<span class="sd">        ax  :</span>
<span class="sd">        figsize :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ax</span> <span class="o">==</span><span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>


        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="c"># create a global array or tahe segments</span>

        <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pta</span><span class="p">,</span><span class="n">phe</span><span class="p">))</span>
        <span class="n">lensi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">seg</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">lensi</span><span class="p">):</span>
            <span class="n">pseg0</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pseg1</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c">#</span>
            <span class="c"># create the cone seg0 seg1</span>
            <span class="c">#</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
            <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span> <span class="o">=</span> <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="n">figsize</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures.unfold"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.unfold.html#pylayers.antprop.signature.Signatures.unfold">[docs]</a>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; unfold a given signature</span>

<span class="sd">        return 2 np.ndarray of pta and phe &quot;aligned&quot;</span>
<span class="sd">        (reflexion interaction are mirrored)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : int</span>
<span class="sd">            the interaction block</span>
<span class="sd">        s : int</span>
<span class="sd">            the signature number in the block</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pta,phe</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.unfold</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">si</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">):(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">si</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">pta</span><span class="p">,</span><span class="n">phe</span>
</div>
<div class="viewcode-block" id="Signatures.show"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.show.html#pylayers.antprop.signature.Signatures.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot signatures within the simulated environment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : list or -1 (default = all groups)</span>
<span class="sd">            list of interaction group numbers</span>
<span class="sd">        s : list or -1 (default = all sig)</span>
<span class="sd">            list of indices of signature in interaction group</span>
<span class="sd">        ctx : cycle of tx (optional)</span>
<span class="sd">        crx : cycle of rx (optional)</span>
<span class="sd">        graph : type of graph to be displayed</span>
<span class="sd">        color : string</span>
<span class="sd">        alphasig : float</span>
<span class="sd">        widthsig : float</span>
<span class="sd">        colsig : string</span>
<span class="sd">        ms : int</span>
<span class="sd">        ctx  : int</span>
<span class="sd">        crx :int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;i&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="s">&#39;s&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="s">&#39;fig&#39;</span><span class="p">:[],</span>
                   <span class="s">&#39;ax&#39;</span><span class="p">:[],</span>
                   <span class="s">&#39;graph&#39;</span><span class="p">:</span><span class="s">&#39;s&#39;</span><span class="p">,</span>
                    <span class="s">&#39;color&#39;</span><span class="p">:</span><span class="s">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s">&#39;alphasig&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s">&#39;widthsig&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span>
                    <span class="s">&#39;colsig&#39;</span><span class="p">:</span><span class="s">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s">&#39;ms&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                    <span class="s">&#39;ctx&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s">&#39;crx&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span>
                   <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># display layout</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;ctx&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Tpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;ctx&#39;</span><span class="p">]][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">Tpoly</span><span class="o">.</span><span class="n">coul</span><span class="o">=</span><span class="s">&#39;r&#39;</span>
            <span class="n">Tpoly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;crx&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Rpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;crx&#39;</span><span class="p">]][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">Rpoly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;g&#39;</span><span class="p">)</span>

        <span class="c"># i=-1 all rays</span>
        <span class="c"># else block of interactions i</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">lgrint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lgrint</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">]]</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lgrint</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">lsig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsig</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">])</span>
                <span class="n">siga</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                <span class="c"># sig = np.hstack((self.pTx[0:2].reshape((2, 1)),</span>
                <span class="c">#                  np.hstack((self[i][&#39;pt&#39;][0:2, :, j],</span>
                <span class="c">#                  self.pRx[0:2].reshape((2, 1))))</span>
                <span class="c">#                  ))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">siga</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">siga</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;alphasig&#39;</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;colsig&#39;</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;widthsig&#39;</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.showi"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.showi.html#pylayers.antprop.signature.Signatures.showi">[docs]</a>    <span class="k">def</span> <span class="nf">showi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">uni</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">us</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; interactive show</span>

<span class="sd">        press n to visit signatures sequentially</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        uni : index of interaction dictionnary keys</span>
<span class="sd">        us : signature index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

        <span class="n">nit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
        <span class="n">ust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">polyS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">polyS</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">polyT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">polyT</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">st</span><span class="o">=</span><span class="s">&#39;a&#39;</span>

        <span class="k">while</span> <span class="n">st</span> <span class="o">!=</span> <span class="s">&#39;q&#39;</span><span class="p">:</span>
            <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">graph</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;# interaction :&#39;</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="s">&#39;signature #&#39;</span><span class="p">,</span><span class="n">us</span><span class="p">,</span><span class="s">&#39;/&#39;</span><span class="p">,</span><span class="n">ust</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">ptx</span>
            <span class="c"># draw terminal points (centroid of source and target cycle)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;xr&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;xb&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ni</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">print</span> <span class="s">&quot;incorrect number of interactions&quot;</span>
            <span class="n">pos</span><span class="o">=</span><span class="p">{}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">us</span><span class="o">*</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">u</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]})</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]))))</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span><span class="n">node_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][(</span><span class="n">us</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;signature index out of bounds of signature&quot;</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line</span><span class="p">,</span><span class="n">prx</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">line</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">line</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">print</span> <span class="n">inter</span>
            <span class="n">st</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="s">&#39;n&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">us</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">ust</span><span class="p">:</span>
                    <span class="n">us</span><span class="o">=</span><span class="n">us</span><span class="o">+</span><span class="mi">2</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">uni</span> <span class="o">=</span> <span class="n">uni</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ni</span> <span class="o">=</span> <span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
                        <span class="n">ust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                        <span class="n">us</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">uni</span><span class="o">=</span><span class="mi">0</span>
                        <span class="n">ni</span><span class="o">=</span><span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
                        <span class="n">us</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;press n for next signature&#39;</span>

    <span class="c"># def raysmt(self,ptx=0,prx=1):</span>
    <span class="c">#     &quot;&quot;&quot; from signatures dict to 2D rays</span>
    <span class="c">#         mutithread</span>

    <span class="c">#     Parameters</span>
    <span class="c">#     ----------</span>

    <span class="c">#     ptx : numpy.array or int</span>
    <span class="c">#         Tx coordinates is the center of gravity of the cycle number if</span>
    <span class="c">#         type(tx)=int</span>
    <span class="c">#     prx :  numpy.array or int</span>
    <span class="c">#         Rx coordinates is the center of gravity of the cycle number if</span>
    <span class="c">#         type(rx)=int</span>

    <span class="c">#     Returns</span>
    <span class="c">#     -------</span>

    <span class="c">#     rays : Rays</span>

    <span class="c">#     Notes</span>
    <span class="c">#     -----</span>

    <span class="c">#     In the same time the signature of the ray is stored in the Rays object</span>

    <span class="c">#     Todo : Find the best memory implemntation</span>

    <span class="c">#     See Also</span>
    <span class="c">#     --------</span>

    <span class="c">#     Signature.sig2ray</span>

    <span class="c">#     &quot;&quot;&quot;</span>

    <span class="c">#     if type(ptx)==int:</span>
    <span class="c">#         ptx = np.array(self.L.Gt.pos[ptx])</span>
    <span class="c">#     if type(prx)==int:</span>
    <span class="c">#         prx = np.array(self.L.Gt.pos[prx])</span>

    <span class="c">#     rays = Rays(ptx,prx)</span>

    <span class="c">#     #</span>
    <span class="c">#     # detect LOS situation</span>
    <span class="c">#     #</span>
    <span class="c">#     #</span>
    <span class="c">#     # cycle on a line between 2 cycles</span>
    <span class="c">#     # lc  = self.L.cycleinline(self.source,self.target)</span>

    <span class="c">#     #</span>
    <span class="c">#     # if source and target in the same merged cycle</span>
    <span class="c">#     # and ptx != prx</span>
    <span class="c">#     #</span>
    <span class="c">#     los = shg.LineString(((ptx[0], ptx[1]), (prx[0], prx[1])))</span>

    <span class="c">#     # convex cycle of each point</span>
    <span class="c">#     cyptx = self.L.pt2cy(ptx)</span>
    <span class="c">#     cyprx = self.L.pt2cy(prx)</span>

    <span class="c">#     # merged cycle of each point</span>
    <span class="c">#     polyctx = self.L.Gt.node[cyptx][&#39;polyg&#39;]</span>
    <span class="c">#     polycrx = self.L.Gt.node[cyprx][&#39;polyg&#39;]</span>

    <span class="c">#     dtxrx = np.sum((ptx-prx)*(ptx-prx))</span>
    <span class="c">#     if dtxrx&gt;1e-15:</span>
    <span class="c">#         if cyptx==cyprx:</span>
    <span class="c">#             if polyctx.contains(los):</span>
    <span class="c">#                 rays.los = True</span>
    <span class="c">#             else:</span>
    <span class="c">#                 rays.los = False</span>

    <span class="c">#     # k : Loop on interaction group</span>
    <span class="c">#     #   l : loop on signature</span>
    <span class="c">#     # ---&gt;</span>
    <span class="c">#     #  this part should be a generator</span>
    <span class="c">#     #</span>

    <span class="c">#     def rayproc(tsig,rays):</span>

    <span class="c">#         shsig = np.shape(tsig)</span>
    <span class="c">#         for l in range(shsig[0]/2):</span>
    <span class="c">#             sig = tsig[2*l:2*l+2,:]</span>
    <span class="c">#             ns0 = sig[0,0]</span>
    <span class="c">#             nse = sig[0,-1]</span>
    <span class="c">#             validtx = True</span>
    <span class="c">#             validrx = True</span>

    <span class="c">#             if (ns0&lt;0):</span>
    <span class="c">#                 pD = self.L.Gs.pos[ns0]</span>
    <span class="c">#                 TxD = shg.LineString(((ptx[0], ptx[1]), (pD[0], pD[1])))</span>
    <span class="c">#                 seg = polyctx.intersection(TxD)</span>
    <span class="c">#                 validtx = seg.almost_equals(TxD,decimal=4)</span>
    <span class="c">#                 if not validtx:</span>
    <span class="c">#                     print ns0</span>

    <span class="c">#             if (nse&lt;0):</span>
    <span class="c">#                 pD = self.L.Gs.pos[nse]</span>
    <span class="c">#                 DRx = shg.LineString(((pD[0], pD[1]), (prx[0], prx[1])))</span>
    <span class="c">#                 validrx = polyctx.contains(DRx)</span>
    <span class="c">#                 if not validrx:</span>
    <span class="c">#                     print nse</span>

    <span class="c">#             if validtx &amp; validrx:</span>
    <span class="c">#                 #    print sig</span>
    <span class="c">#                 #    print pD</span>
    <span class="c">#                 s  = Signature(sig)</span>
    <span class="c">#                 #</span>
    <span class="c">#                 # Transform signature into a ray</span>
    <span class="c">#                 # --&gt; sig2ray</span>

    <span class="c">#                 isray,Yi  = s.sig2ray(self.L, ptx[:2], prx[:2])</span>

    <span class="c">#                 if isray:</span>
    <span class="c">#                     Yi = np.fliplr(Yi)</span>
    <span class="c">#                     if k in rays.keys():</span>
    <span class="c">#                         Yi3d = np.vstack((Yi[:, 1:-1], np.zeros((1, k))))</span>
    <span class="c">#                         Yi3d = Yi3d.reshape(3, k, 1)</span>
    <span class="c">#                         rays[k][&#39;pt&#39;] = np.dstack(( rays[k][&#39;pt&#39;], Yi3d))</span>
    <span class="c">#                         rays[k][&#39;sig&#39;] = np.dstack(( rays[k][&#39;sig&#39;],</span>
    <span class="c">#                                                     sig.reshape(2, k, 1)))</span>
    <span class="c">#                     else:</span>
    <span class="c">#                         rays[k] = {&#39;pt&#39;: np.zeros((3, k, 1)),</span>
    <span class="c">#                                    &#39;sig&#39;: np.zeros((2, k, 1),dtype=int)}</span>
    <span class="c">#                         rays[k][&#39;pt&#39;][0:2, :, 0] = Yi[:, 1:-1]</span>
    <span class="c">#                         rays[k][&#39;sig&#39;][:, :, 0] = sig</span>


    <span class="c">#     import threading as thg</span>
    <span class="c">#     jobs = []</span>

    <span class="c">#     for k in self:</span>
    <span class="c">#         # get signature block with k interactions</span>
    <span class="c">#         tsig = self[k]</span>
    <span class="c">#         p = thg.Thread(target=rayproc, args=(tsig,rays))</span>
    <span class="c">#         jobs.append(p)</span>
    <span class="c">#         p.start()</span>
    <span class="c">#         p.join()</span>

    <span class="c">#     rays.nb_origin_sig = len(self)</span>
    <span class="c">#     rays.origin_sig_name = self.filename</span>
    <span class="c">#     return rays</span>
</div>
<div class="viewcode-block" id="Signatures.rays"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.rays.html#pylayers.antprop.signature.Signatures.rays">[docs]</a>    <span class="k">def</span> <span class="nf">rays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ptx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">prx</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; from signatures dict to 2D rays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptx : numpy.array or int</span>
<span class="sd">            Tx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(tx)=int</span>
<span class="sd">        prx :  numpy.array or int</span>
<span class="sd">            Rx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            sigtype(rx)=int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rays : Rays</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        In the same time the signature of the ray is stored in the Rays object</span>

<span class="sd">        Todo : Find the best memory implemntation</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.sig2ray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ptx</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">prx</span><span class="p">])</span>

        <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># detect LOS situation</span>
        <span class="c">#</span>
        <span class="c">#</span>
        <span class="c"># cycle on a line between 2 cycles</span>
        <span class="c"># lc  = self.L.cycleinline(self.source,self.target)</span>

        <span class="c">#</span>
        <span class="c"># if source and target in the same merged cycle</span>
        <span class="c"># and ptx != prx</span>
        <span class="c">#</span>
        <span class="n">los</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="c"># convex cycle of each point</span>
        <span class="n">cyptx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span>
        <span class="n">cyprx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span>

        <span class="c"># merged cycle of each point</span>
        <span class="n">polyctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyptx</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">polycrx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyprx</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>

        <span class="n">dtxrx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dtxrx</span><span class="o">&gt;</span><span class="mf">1e-15</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cyptx</span><span class="o">==</span><span class="n">cyprx</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">los</span><span class="p">):</span>
                    <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># k : Loop on interaction group</span>
        <span class="c">#   l : loop on signature</span>
        <span class="c"># ---&gt;</span>
        <span class="c">#  this part should be a generator</span>
        <span class="c">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c"># print &#39;block#&#39;,k</span>
            <span class="c"># if k ==3:</span>
            <span class="c">#     import ipdb</span>
            <span class="c">#     ipdb.set_trace()</span>
            <span class="c"># get signature block with k interactions</span>
            <span class="n">tsig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">shsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tsig</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shsig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">tsig</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,:]</span>
                <span class="n">ns0</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nse</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">validtx</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">validrx</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">ns0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">pD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ns0</span><span class="p">]</span>
                    <span class="n">TxD</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">pD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pD</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">TxD</span><span class="p">)</span>
                    <span class="n">validtx</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">almost_equals</span><span class="p">(</span><span class="n">TxD</span><span class="p">,</span><span class="n">decimal</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validtx</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c">#print &quot;Signature.rays&quot;: ns0</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">nse</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">pD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nse</span><span class="p">]</span>
                    <span class="n">DRx</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">pD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pD</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">validrx</span> <span class="o">=</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DRx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validrx</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c">#print nse</span>

                <span class="k">if</span> <span class="n">validtx</span> <span class="o">&amp;</span> <span class="n">validrx</span><span class="p">:</span>
                    <span class="c">#    print sig</span>
                    <span class="c">#    print pD</span>
                    <span class="n">s</span>  <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                    <span class="c">#</span>
                    <span class="c"># Transform signature into a ray</span>
                    <span class="c"># --&gt; sig2ray</span>

                    <span class="n">isray</span><span class="p">,</span><span class="n">Yi</span>  <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sig2ray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">ptx</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">prx</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">isray</span><span class="p">:</span>
                        <span class="n">Yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rays</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Yi3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Yi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))))</span>
                            <span class="n">Yi3d</span> <span class="o">=</span> <span class="n">Yi3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span> <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;pt&#39;</span><span class="p">],</span> <span class="n">Yi3d</span><span class="p">))</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span> <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;sig&#39;</span><span class="p">],</span>
                                                        <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>

                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;pt&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                       <span class="s">&#39;sig&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)}</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;sig&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="n">rays</span><span class="o">.</span><span class="n">nb_origin_sig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">return</span> <span class="n">rays</span>

</div>
<div class="viewcode-block" id="Signatures.raysv"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.raysv.html#pylayers.antprop.signature.Signatures.raysv">[docs]</a>    <span class="k">def</span> <span class="nf">raysv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ptx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">prx</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; from signatures dict to 2D rays Vectorized version</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptx : numpy.array or int</span>
<span class="sd">            Tx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(tx)=int</span>
<span class="sd">        prx :  numpy.array or int</span>
<span class="sd">            Rx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(rx)=int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rays : Rays</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This is a vectorized version of Signatures.rays.</span>
<span class="sd">        This implementation take advantage of the np.ndarray</span>
<span class="sd">        and calculate images and backtrace for block of signatures.</span>
<span class="sd">        A block of signature gather all signatures with the same number of interaction.</span>

<span class="sd">        For mathematical details see :</span>

<span class="sd">        @phdthesis{amiot:tel-00971809,</span>
<span class="sd">          TITLE = {{Design of simulation platform joigning site specific radio propagation and human mobility for localization applications}},</span>
<span class="sd">          AUTHOR = {Amiot, Nicolas},</span>
<span class="sd">          URL = {https://tel.archives-ouvertes.fr/tel-00971809},</span>
<span class="sd">          NUMBER = {2013REN1S125},</span>
<span class="sd">          SCHOOL = {{Universit{\&#39;e} Rennes 1}},</span>
<span class="sd">          YEAR = {2013},</span>
<span class="sd">          MONTH = Dec,</span>
<span class="sd">          KEYWORDS = {Electromagnetic wave propagation simulation ; Human mobility simulation ; Wireless localization methods ; Position estimation methods in wireless networks ; Vectorized computation ; Ray-tracing ; Ultra wide band ; Simulateur de propagation {\&#39;e}lectromagn{\&#39;e}tique ; Simulateur de mobilit{\&#39;e} humaine ; M{\&#39;e}thodes de localisation sans fils ; M{\&#39;e}thodes d&#39;estimation de la position dans les r{\&#39;e}seaux sans fils ; Calcul informatique vectoris{\&#39;e} ; Outil de trac{\&#39;e} de rayons ; Ultra large bande},</span>
<span class="sd">          TYPE = {Theses},</span>
<span class="sd">          HAL_ID = {tel-00971809},</span>
<span class="sd">          HAL_VERSION = {v1},</span>
<span class="sd">        }</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signatures.image</span>
<span class="sd">        Signatures.backtrace</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ptx</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">prx</span><span class="p">])</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ptx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ptx</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">prx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">prx</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span>

        <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">)</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image2</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backtrace</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">nb_origin_sig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">return</span> <span class="n">rays</span>
</div>
    <span class="k">def</span> <span class="nf">backtrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Warning :</span>
<span class="sd">            This is an attempt to vectorize the backtrace process.</span>
<span class="sd">            Despite it has been tested on few cases with succes,</span>
<span class="sd">            this is quite new need to be validated !!!</span>


<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">                tx : ndarray</span>
<span class="sd">                    position of tx (2,)</span>
<span class="sd">                rx : ndarray</span>
<span class="sd">                    position of tx (2,)</span>
<span class="sd">                M : dict</span>
<span class="sd">                    position of intermediate point from self.image()</span>

<span class="sd">            Return</span>
<span class="sd">            -------</span>

<span class="sd">                rayp : dict</span>
<span class="sd">                key = number_of_interactions</span>
<span class="sd">                value =ndarray positions of interactions for creating rays</span>

<span class="sd">            Notes</span>
<span class="sd">            -----</span>
<span class="sd">            dictionnary of intermediate coordinated :</span>
<span class="sd">            key = number_of_interactions</span>
<span class="sd">            value = nd array M with shape : (2,nb_signatures,nb_interactions)</span>
<span class="sd">            and 2 represent x and y coordinates</span>


<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">rayp</span><span class="o">=</span><span class="p">{}</span>
        <span class="c"># loop on number of interactions</span>
        <span class="k">for</span> <span class="n">ninter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">signatures</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">])</span>
            <span class="c"># get segment ids of signature with 4 interactions</span>
            <span class="c"># get segment ids of signature with ninter interactions</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">unegseg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">uninegseg</span><span class="p">,</span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">unegseg</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">pneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">uninegseg</span><span class="p">])</span>

            <span class="n">nsig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

            <span class="c"># determine positions of points limiting the semgments</span>
            <span class="c"># 1 get index in L.tahe</span>
            <span class="c"># 2 get associated position in L.pt</span>


            <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">seg</span><span class="p">]]</span>
            <span class="c"># pt : (xycoord (2),pt indexes (2),nb_signatures,nb_interactions)</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="n">utahe</span><span class="p">]</span>
            

            <span class="c">#### WARNING BIG TRICK HERE :</span>
            <span class="c">#### pa and pb are not set as the same value </span>
            <span class="c">#### to avoid a singular matrixnext.</span>
            <span class="c">#### set pa =-pb has no incidence but avoid complex and vain code </span>
            <span class="c">#### modification for handling diffractions</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">pneg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=-</span><span class="n">pneg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="c"># pt shape =</span>
            <span class="c"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c"># 1 : 2 points (linking the semgnet) a=0,b=1</span>
            <span class="c"># 2 : nb of found signatures/segments</span>
            <span class="c"># 3 : nb interaction</span>
            <span class="c">#shape =</span>
            <span class="c"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c"># 1 : 2 points (linking the semgnet) a=0,b=1</span>
            <span class="c"># 2 : nb of found signatures/segments</span>
            <span class="c"># 3 : nb interaction</span>
            <span class="c"># how to do this into a while loop</span>
            <span class="n">p</span><span class="o">=</span><span class="n">rx</span>

            <span class="c"># creating W matrix required in eq (2.70) thesis Nicolas AMIOT</span>
            <span class="c"># Warning W is rolled after and becomes (nsig,4,4)</span>
            <span class="n">W</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">nsig</span><span class="p">))</span>
            <span class="n">I</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nsig</span><span class="p">))</span>
            <span class="n">W</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
            <span class="n">W</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>

            <span class="c"># once rolled :</span>
            <span class="c"># W (nsig,4,4)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


            <span class="n">kinter</span><span class="o">=</span><span class="n">ninter</span><span class="o">-</span><span class="mi">1</span>

            <span class="n">ptr</span> <span class="o">=</span> <span class="n">pt</span>
            <span class="n">Mr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span>
            <span class="n">rayp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="p">))</span>
            <span class="c"># rayp_i[:2,:,-1]=rx[:,None]</span>
            <span class="c"># backtrace process</span>
            <span class="c"># if ninter == 6:</span>
            <span class="c">#     print np.where(((signatures[:,0]==42) &amp;(signatures[:,1]==-277) &amp; (signatures[:,2]==135) &amp; (signatures[:,3]==21) &amp; (signatures[:,4]==46) &amp; (signatures[:,5]==319)))</span>
            <span class="c">#     import ipdb</span>
            <span class="c">#     ipdb.set_trace()</span>

            <span class="k">while</span> <span class="n">kinter</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="c"># Initilization, using the Tx position</span>
                <span class="k">if</span> <span class="n">kinter</span> <span class="o">==</span> <span class="n">ninter</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">p_min_m</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">][:,:,</span><span class="n">kinter</span><span class="p">]</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">p_min_m</span> <span class="o">=</span> <span class="n">pvalid</span><span class="p">[:]</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">][:,:,</span><span class="n">kinter</span><span class="p">]</span>

                <span class="n">a_min_b</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]</span><span class="o">-</span><span class="n">ptr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]</span>

                <span class="c"># Creating W from  eq (2.71)</span>
                <span class="c"># a_min_b &lt;=&gt; a_{Lh-l}-b_{Lh-l}</span>
                <span class="c"># p_min_m &lt;=&gt; \tilde{p}_{Lh}-\tilde{b}_{Lh-l}</span>
                <span class="c"># W (nsig,4,4)</span>
                <span class="c"># p_min_m (2,nsig)</span>
                <span class="c"># a_min_b (2,nsig)</span>
                <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_min_m</span><span class="o">.</span><span class="n">T</span>
                <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_min_b</span><span class="o">.</span><span class="n">T</span>

                <span class="c"># create 2nd member from eq (2.72)</span>
                <span class="k">if</span> <span class="n">kinter</span> <span class="o">==</span> <span class="n">ninter</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nsig</span><span class="p">)),</span><span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pvalid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]))</span>

                <span class="c"># y once transposed :</span>
                <span class="c"># y (nsig,4)</span>
                <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">T</span>


                <span class="c"># search and remove point with singular matrix</span>
                <span class="n">invalid_sig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">W</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1e-15</span><span class="p">)</span>

                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">],</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">rayp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">rayp_i</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c"># remove signatures</span>

                <span class="n">usig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">invalid_sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">usig</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usig</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
                <span class="n">usig</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usig</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">signatures</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">signatures</span><span class="p">,</span><span class="n">usig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c"># detect diffrac</span>
                <span class="n">uD</span> <span class="o">=</span> <span class="n">signatures</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span>
                <span class="n">uuD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signatures</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


                <span class="n">psolved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

                <span class="c"># valid ray is : 0 &lt; \alpha &lt; 1 and 0&lt; \beta &lt; 1</span>

                <span class="c"># alpha</span>
                <span class="n">uvalidA</span><span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.</span>
                <span class="n">uvalidB</span><span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="mf">1.</span>
                <span class="c"># beta</span>
                <span class="n">uvalidC</span><span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">epsilon</span>
                <span class="n">uvalidD</span><span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span><span class="mf">1.</span><span class="o">-</span><span class="n">epsilon</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">uvalidA</span> <span class="o">&amp;</span> <span class="n">uvalidB</span> <span class="o">&amp;</span> <span class="n">uvalidC</span> <span class="o">&amp;</span> <span class="n">uvalidD</span>
                <span class="c"># consider valid diffraction interactions</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">|</span> <span class="n">uD</span>
                <span class="n">uvalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># re-add correct position of diffraction interations</span>
                <span class="c"># indeed diffraction point should not been solved with linalg, </span>
                <span class="c"># but by setting pa=-pb, no singular matrix appear</span>
                <span class="c"># and diffraction points can be re-add thereafter.</span>
                <span class="n">psolved</span><span class="p">[</span><span class="n">uuD</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">uuD</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

                <span class="n">pvalid</span> <span class="o">=</span> <span class="n">psolved</span><span class="p">[</span><span class="n">uvalid</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>






                <span class="c"># keep only valid rays for ptr and Mr</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">]</span><span class="o">=</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">][:,</span><span class="n">uvalid</span><span class="p">,:]</span>
                <span class="n">ptr</span><span class="o">=</span><span class="n">ptr</span><span class="p">[:,:,</span><span class="n">uvalid</span><span class="p">,:]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">uvalid</span><span class="p">,:,:]</span>


                <span class="c"># remove signatures</span>
                <span class="n">usigv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uvalid</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">usigv</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usigv</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
                <span class="n">usigv</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usigv</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">signatures</span> <span class="o">=</span> <span class="n">signatures</span><span class="p">[</span><span class="n">usigv</span><span class="p">,:]</span>
                <span class="n">rayp_i</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="n">uvalid</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span> <span class="o">=</span> <span class="n">pvalid</span><span class="o">.</span><span class="n">T</span>
                <span class="n">rayp_i</span> <span class="o">=</span> <span class="n">rayp_i</span><span class="p">[:,</span><span class="n">uvalid</span><span class="p">,:]</span>
                <span class="c"># if no more rays are valid , then quit block</span>
                <span class="c"># (kinter &lt;0 is the exit while condition)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvalid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">kinter</span><span class="o">=</span><span class="n">kinter</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">kinter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

            <span class="c"># rayp_i[:2,:,0]=tx[:,None]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvalid</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">sir1</span><span class="o">=</span><span class="n">signatures</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ninter</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">usigv</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">sir2</span><span class="o">=</span><span class="n">signatures</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ninter</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">usigv</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">ninter</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">usigv</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">sir1</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">sir2</span>
                <span class="n">rayp_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">rayp_i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">rayp</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ninter</span><span class="p">:{</span><span class="s">&#39;pt&#39;</span><span class="p">:</span><span class="n">rayp_i</span><span class="p">,</span><span class="s">&#39;sig&#39;</span><span class="p">:</span><span class="n">sig</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">)}})</span>
        <span class="k">return</span> <span class="n">rayp</span>


<div class="viewcode-block" id="Signatures.image2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.image2.html#pylayers.antprop.signature.Signatures.image2">[docs]</a>    <span class="k">def</span> <span class="nf">image2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine rays from images (second implementation)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx : point</span>

<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dM</span><span class="o">=</span><span class="p">{}</span>
        <span class="c"># loop on number of interactions</span>
        <span class="k">for</span> <span class="n">ninter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c"># get segment ids of signature with ninter interactions</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span>
            <span class="c"># seek for diffraction</span>
            <span class="c"># negative index points are diffraction points</span>
            <span class="n">unegseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">uninegseg</span><span class="p">,</span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="n">unegseg</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">pneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">uninegseg</span><span class="p">])</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="p">))</span>
            <span class="c"># determine positions of points limiting the segments</span>
            <span class="c"># 1 get index in L.tahe</span>
            <span class="c"># 2 get associated position in L.pt</span>

            <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">seg</span><span class="p">]]</span>
            <span class="c"># pt : (xycoord (2),pt indexes (2),nb_signatures,nb_interactions)</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="n">utahe</span><span class="p">]</span>
            <span class="c">#</span>
            <span class="c"># TODO Upgrading layout for handling slab offsets </span>
            <span class="c">#</span>
            <span class="c"># uncomment those two lines when the numpy array L.norm and</span>
            <span class="c"># L.offset exist</span>
            <span class="c">#norm    = self.L.normal[:,utahe]</span>
            <span class="c">#offset  = self.L.offset[:,utahe]</span>
            <span class="c"># pt = pt + offset*norm</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pneg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">unegseg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pneg</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="c"># pt shape =</span>
            <span class="c"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c"># 1 : 2 points (linking the segment) a=0,b=1</span>
            <span class="c"># 2 : nb of found signatures/segments</span>
            <span class="c"># 3 : nb interactions</span>

            <span class="c">############</span>
            <span class="c"># formula 2.61 -&gt; 2.64 N.AMIOT PH.D thesis</span>
            <span class="c">############</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">sx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">sy</span><span class="o">**</span><span class="mi">2</span>
            <span class="c"># den = ((pt[0,0,:,:]-pt[0,1,:,:])**2+(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>
            <span class="c"># avoiding singularity (should not be possible)</span>
            <span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">den</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">den</span><span class="p">[</span><span class="n">uz</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">b</span><span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                              <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                             <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                              <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                             <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="c"># a = ((pt[0,0,:,:]-pt[0,1,:,:])**2-(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>
            <span class="c"># a=a/(1.*den)</span>

            <span class="c"># b = 2*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,1,:,:]-pt[1,0,:,:])</span>
            <span class="c"># b=b/(1.*den)</span>

            <span class="c"># c= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])**2+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,0,:,:]-pt[1,1,:,:]))</span>
            <span class="c"># c = c/(1.*den)</span>

            <span class="c"># d= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])*(pt[0,1,:,:]-pt[0,0,:,:])+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])**2)</span>
            <span class="c"># d= d/(1.*den)</span>

            <span class="c"># K=np.array([[a,-b],[-b,-a]])</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">],[</span><span class="o">-</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">]])</span>

            <span class="c"># translation vector v (2.60)</span>
            <span class="n">v</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">]))</span>

            <span class="n">ityp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ninter</span><span class="p">):</span>
                <span class="c"># get segment ids of signature with ninter interactions</span>
                <span class="n">uT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">=</span><span class="n">tx</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nsig</span><span class="p">))</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">[:,:,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c"># reflexion 0 (2.67)</span>
                <span class="n">M</span><span class="p">[:,</span><span class="n">uR</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijk,jk-&gt;ik&#39;</span><span class="p">,</span><span class="n">K</span><span class="p">[:,:,</span><span class="n">uR</span><span class="p">,</span><span class="n">n</span><span class="p">],</span><span class="n">p</span><span class="p">[:,</span><span class="n">uR</span><span class="p">])</span><span class="o">+</span><span class="n">v</span><span class="p">[:,</span><span class="n">uR</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>
                <span class="c"># transmission 0 (2.67)</span>
                <span class="n">M</span><span class="p">[:,</span><span class="n">uT</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="n">uT</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[:,</span><span class="n">uD</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">uD</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>

            <span class="c"># if ninter==6:</span>
            <span class="c">#     print np.where(((seg[:,0]==42) &amp; (seg[:,1]==-277) &amp; (seg[:,2]==135) &amp; (seg[:,3]==21)&amp;(seg[:,-1]==319)))</span>
            <span class="c">#     import ipdb</span>
            <span class="c">#     ipdb.set_trace()</span>

            <span class="n">dM</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ninter</span><span class="p">:</span><span class="n">M</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">dM</span></div>
<div class="viewcode-block" id="Signatures.image"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.image.html#pylayers.antprop.signature.Signatures.image">[docs]</a>    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.7</span><span class="p">,</span><span class="mf">12.5</span><span class="p">])):</span>
        <span class="sd">&#39;&#39;&#39; Warning :</span>
<span class="sd">            This is an attempt to vectorize the image process.</span>
<span class="sd">            Despite it has been tested on few cases with succes,</span>
<span class="sd">            this is quite new need to be validated !!!</span>


<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">                tx : ndarray</span>
<span class="sd">                    position of tx (2,)</span>

<span class="sd">            Return</span>
<span class="sd">            -------</span>

<span class="sd">                M : dictionnary</span>

<span class="sd">            dictionnary of intermediate coordinated :</span>
<span class="sd">            key = number_of_interactions</span>
<span class="sd">            value = nd array M with shape : (2,nb_signatures,nb_interactions)</span>
<span class="sd">            and 2 represent x and y coordinates</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">nb_split</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">nsp</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">out</span><span class="o">=</span><span class="bp">False</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">res</span><span class="o">=</span><span class="n">a</span><span class="o">%</span><span class="n">nsp</span>
                <span class="k">if</span> <span class="n">res</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">nsp</span><span class="o">=</span><span class="n">nsp</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">=</span><span class="bp">True</span>
            <span class="k">return</span> <span class="n">nsp</span>

        <span class="n">dM</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">ninter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c"># get segment ids of signature with ninter interactions</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
            <span class="c"># determine positions of points limiting the semgments</span>
            <span class="c"># 1 get index in L.tahe</span>
            <span class="c"># 2 get associated position in L.pt</span>

            <span class="c"># utahe (2 pt indexes,nb_signatures,nb_interactions)</span>

            <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">seg</span><span class="p">]]</span>



            <span class="c"># pt : (xycoord (2),pt indexes (2),nb_signatures,nb_interactions)</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="n">utahe</span><span class="p">]</span>

            <span class="c"># pt shape =</span>
            <span class="c"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c"># 1 : 2 points (linking the semgnet) a=0,b=1</span>
            <span class="c"># 2 : nb of found signatures/segments</span>
            <span class="c"># 3 : nb interaction</span>

            <span class="c">############</span>
            <span class="c"># formula 2.61 -&gt; 2.64 N.AMIOT thesis</span>
            <span class="c">############</span>
            <span class="n">den</span> <span class="o">=</span> <span class="p">((</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">den</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">den</span><span class="p">[</span><span class="n">uz</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">b</span><span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span>

            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                                <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                                <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="c"># den = ((pt[0,0,:,:]-pt[0,1,:,:])**2+(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>

            <span class="c"># a = ((pt[0,0,:,:]-pt[0,1,:,:])**2-(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>
            <span class="c"># a=a/(1.*den)</span>

            <span class="c"># b = 2*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,1,:,:]-pt[1,0,:,:])</span>
            <span class="c"># b=b/(1.*den)</span>

            <span class="c"># c= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])**2+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,0,:,:]-pt[1,1,:,:]))</span>
            <span class="c"># c = c/(1.*den)</span>

            <span class="c"># d= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])*(pt[0,1,:,:]-pt[0,0,:,:])+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])**2)</span>
            <span class="c"># d= d/(1.*den)</span>

            <span class="c"># get segment ids of signature with ninter interactions</span>
            <span class="n">ityp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">uT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">uR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uD</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># create matrix AM which is used to create marix A from eq. 2.65</span>
            <span class="n">AM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">ninter</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nsig</span><span class="p">)</span>

            <span class="c"># Reflexion MAtrix K (2.59)</span>
            <span class="n">K</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">],[</span><span class="o">-</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">]])</span>
            <span class="c"># translation vector v (2.60)</span>
            <span class="n">v</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">]))</span>

            <span class="c">############</span>
            <span class="c"># Create matrix A (2.66) which is fill by blocks</span>
            <span class="c">############</span>



            <span class="n">blocks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c"># Reflexion block</span>
            <span class="n">blocks</span><span class="p">[:,:,</span><span class="n">uR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uR</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=-</span><span class="n">K</span><span class="p">[:,:,</span><span class="n">uR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># Transmission block</span>
            <span class="n">blocks</span><span class="p">[:,:,</span><span class="n">uT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uT</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">uT</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="c"># Diff block</span>
            <span class="n">blocks</span><span class="p">[:,:,</span><span class="n">uD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uD</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="mf">0.</span>

            <span class="c"># fill the AM mda on the diagonal below the mda diagonal....</span>
            <span class="n">A</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">fill_block_diagMDA</span><span class="p">(</span><span class="n">AM</span><span class="p">,</span><span class="n">blocks</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># The 2nd member y is firslty completly fill, without taking into account that the 1st line differst from others.</span>
            <span class="c"># 1. find which interaction and signature are R|T|D =&gt; create a masked array</span>
            <span class="c"># 2. repeat is created because to each signature/interaction correspond a 2x1 column. Repeat allow to have the correct size to fill y</span>
            <span class="c"># 3. fill the 1st line of y to take into consideration that difference.</span>

            <span class="c"># y is the 2nd memeber from from (2.65) and will be filled following (2.67)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ninter</span><span class="p">,</span><span class="n">nsig</span><span class="p">))</span>

            <span class="c">#######</span>
            <span class="c"># Determine where y has to be filed with R|T|D</span>
            <span class="c">#####</span>
            <span class="c"># find the position where there is T|R|D. non continuous =&gt; need mask array</span>
            <span class="n">uTf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">uRf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uDf</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># postiion in signature &lt;=&gt; 2 lines in y . need to repeat to get the correct size</span>
            <span class="n">uRy2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uRf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uRy1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uRf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uRy1</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">uRy1</span>
            <span class="n">uRy1</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">uRy1</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>

            <span class="n">uDy2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uDf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uDy1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uDf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uDy1</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">uDy1</span>
            <span class="n">uDy1</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">uDy1</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">uRy1</span><span class="p">,</span><span class="n">uRy2</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">[:,</span><span class="n">uRf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uRf</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c">#print &#39;no R&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c">#uT1mr = np.repeat(uT1m.mask,2,axis=1).T</span>
                <span class="c"># nothing to do. shoould be a zero vector , already initialized by y</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c">#print &#39;no T&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># NEVER TESTED !!!!!!!!!!!</span>
                <span class="n">y</span><span class="p">[</span><span class="n">uDy1</span><span class="p">,</span><span class="n">uDy2</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">uDf</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;signatures.image diffraction line 3672 Not yet tested !&quot;</span>

                <span class="k">pass</span> <span class="c">#print &#39;no D&#39;</span>

            <span class="c">######</span>
            <span class="c">#FIRST LINE specific processing of (2.67)</span>
            <span class="c">######</span>
            <span class="n">uT0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uR0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uD0</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># reflexion 0 (2.67)</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijk,j-&gt;ik&#39;</span><span class="p">,</span><span class="n">K</span><span class="p">[:,:,</span><span class="n">uR0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">tx</span><span class="p">)</span><span class="o">+</span><span class="n">v</span><span class="p">[:,</span><span class="n">uR0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># trnasmission 0 (2.67)</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uT0</span><span class="p">))</span>
            <span class="c"># diff 0 (2.67)</span>
            <span class="n">d0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">uD0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># first line</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">uR0</span><span class="p">]</span><span class="o">=</span><span class="n">r0</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">uT0</span><span class="p">]</span><span class="o">=</span><span class="n">t0</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">uD0</span><span class="p">]</span><span class="o">=</span><span class="n">d0</span>

            <span class="c"># reshape for compliant size with linalg</span>
            <span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">leA</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">res</span><span class="o">=</span><span class="mi">0</span>
            <span class="c"># trick for memory usage</span>
            <span class="k">if</span> <span class="n">leA</span> <span class="o">&gt;</span> <span class="mf">1e4</span><span class="p">:</span>
                <span class="n">nsp</span> <span class="o">=</span> <span class="n">nb_split</span><span class="p">(</span><span class="n">leA</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nsp</span> <span class="o">!=</span> <span class="n">leA</span><span class="p">:</span>
                    <span class="n">lA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">nsp</span><span class="p">)</span>
                    <span class="n">ly</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">nsp</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">A</span>
                    <span class="k">del</span> <span class="n">y</span>
                    <span class="k">print</span> <span class="n">nsp</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsp</span><span class="p">):</span>

                        <span class="n">lm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">lA</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">ly</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">lm</span><span class="p">))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">lm</span>
                    <span class="k">del</span> <span class="n">lm</span>
                    <span class="k">del</span> <span class="n">lA</span>
                    <span class="k">del</span> <span class="n">ly</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">m</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span><span class="n">m</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

            <span class="n">dM</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ninter</span><span class="p">:</span><span class="n">M</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">dM</span>

</div>
<span class="k">class</span> <span class="nc">Signature</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; class Signature</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    seq : list  of interaction point (edges (&gt;0)  or vertices (&lt;0) [int]</span>
<span class="sd">    typ : list of interaction type 1-R 2-T 3-D  [int]</span>
<span class="sd">    pa  : tail point of interaction segmenti (2xN) ndarray</span>
<span class="sd">    pb  : head point of interaction segment  (2xN) ndarray</span>
<span class="sd">    pc  : center point of interaction segment (2xN) ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Signature.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.__init__.html#pylayers.antprop.signature.Signature.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sig : nd.array or list of interactions</span>

<span class="sd">        &gt;&gt;&gt; seq = np.array([[1,5,1],[1,1,1]])</span>
<span class="sd">        &gt;&gt;&gt; s = Signature(seq)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">typinter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">seginter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">seginter</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">typinter</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signature.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.__repr__.html#pylayers.antprop.signature.Signature.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="Signature.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.info.html#pylayers.antprop.signature.Signature.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Signature.ev2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.ev2.html#pylayers.antprop.signature.Signature.ev2">[docs]</a>    <span class="k">def</span> <span class="nf">ev2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature. At that level the coordinates of extremities (tx and rx) is</span>
<span class="sd">        not known yet.</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>
<span class="sd">        pc  the center of segment (2xN)</span>

<span class="sd">        norm normal to the segment if segment</span>
<span class="sd">        in case the interaction is a point the normal is undefined and then</span>
<span class="sd">        set to 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">seqpointa</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nor1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nor1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nor1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pa</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">pc</span><span class="p">,</span><span class="n">norm</span><span class="p">)))</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">seqpointa</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">6</span><span class="p">:,:]</span>

</div>
<div class="viewcode-block" id="Signature.evf"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.evf.html#pylayers.antprop.signature.Signature.evf">[docs]</a>    <span class="k">def</span> <span class="nf">evf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature (fast version)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature.</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># head</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># segment</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>      <span class="c"># node</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
</div>
<div class="viewcode-block" id="Signature.ev"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.ev.html#pylayers.antprop.signature.Signature.ev">[docs]</a>    <span class="k">def</span> <span class="nf">ev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature.</span>

<span class="sd">        At that stage coordinates of extremities (tx and rx) is</span>
<span class="sd">        not known yet</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>
<span class="sd">        pc  the center of segment (2xN)</span>

<span class="sd">        norm normal to the segment if segment</span>
<span class="sd">        in case the interaction is a point the normal is undefined and then</span>
<span class="sd">        set to 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO : use map and filter instead of for loop</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># segment</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">norm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;norm&#39;</span><span class="p">])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">norm1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>      <span class="c"># node</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
</div>
<div class="viewcode-block" id="Signature.unfold"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.unfold.html#pylayers.antprop.signature.Signature.unfold">[docs]</a>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; unfold a given signature</span>

<span class="sd">        returns 2 np.ndarray of pta and phe &quot;aligned&quot;</span>
<span class="sd">        reflexion interactions are mirrored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pta : np.array</span>
<span class="sd">        phe : np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lensi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>
        <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>

        <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">mirror</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">lensi</span><span class="p">):</span>

            <span class="n">pam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pbm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># R</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mirror</span><span class="p">:</span>
                    <span class="n">pam</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">pbm</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pbm</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                <span class="n">pta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pam</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">phe</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">mirror</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">:</span> <span class="c"># T</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mirror</span><span class="p">:</span>
                    <span class="n">pam</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">pbm</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pbm</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                <span class="n">pta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pam</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">phe</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span> <span class="c"># D</span>
                <span class="k">pass</span>
                <span class="c"># TODO not implemented yet</span>

        <span class="k">return</span> <span class="n">pta</span><span class="p">,</span><span class="n">phe</span>
</div>
<div class="viewcode-block" id="Signature.evtx"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.evtx.html#pylayers.antprop.signature.Signature.evtx">[docs]</a>    <span class="k">def</span> <span class="nf">evtx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; evaluate transmitter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L  : Layout</span>
<span class="sd">        tx : np.array (2xN)</span>
<span class="sd">        rx : np.array (2xM)</span>

<span class="sd">        DEPRECATED</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">norm1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">norm1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">pb</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])))</span>
        <span class="c">#</span>
        <span class="c">#  vecteur entre deux points adjascents de la signature</span>
        <span class="c">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">u1</span> <span class="o">*</span> <span class="n">u2</span><span class="p">)</span>
        <span class="c">#return(vn)</span>
        <span class="c">#return(typ)</span>

</div>
<div class="viewcode-block" id="Signature.image"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.image.html#pylayers.antprop.signature.Signature.image">[docs]</a>    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; compute the tx&#39;s images with respect to the signature segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx : numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        M : numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span>
        <span class="n">pab</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pab</span> <span class="o">*</span> <span class="n">pab</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">zalpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">alpha</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">[</span><span class="n">zalpha</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>

        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>
        <span class="c"># number of interactions</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pa</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c"># detect diffraction</span>
        <span class="n">usig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">usig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">usig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c"># detect transmission</span>
        <span class="n">tsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">#blocks[tsig, :, :] = np.zeros((2, 2))</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">tsig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c"># detect reflexion</span>
        <span class="n">rsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">rsig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">rsig</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">fill_block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vc0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">tx</span><span class="p">)</span> <span class="o">+</span> <span class="n">vc0</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c">#y[2 * (i + 1):2 * (i + 1) + 2] = y[2*i:2*i+2]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">M</span>
</div>
<div class="viewcode-block" id="Signature.backtrace"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.backtrace.html#pylayers.antprop.signature.Signature.backtrace">[docs]</a>    <span class="k">def</span> <span class="nf">backtrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; backtrace given image, tx, and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx :  ndarray (2x1)</span>
<span class="sd">              transmitter</span>
<span class="sd">        rx :  ndarray (2x1)</span>
<span class="sd">              receiver</span>
<span class="sd">        M  :  ndarray (2xN)</span>
<span class="sd">              N image points obtained using self.image method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        isvalid : bool</span>
<span class="sd">            True if the backtrace ends successfully</span>

<span class="sd">        Y : ndarray (2 x (N+2))</span>
<span class="sd">            sequence of points corresponding to the seek ray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.antprop.signature import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout()</span>
<span class="sd">            &gt;&gt;&gt; L.dumpr()</span>
<span class="sd">            &gt;&gt;&gt; seq = np.array([[1,5,1],[1,1,1]])</span>
<span class="sd">            &gt;&gt;&gt; s = Signature(seq)</span>
<span class="sd">            &gt;&gt;&gt; tx = np.array([4,-1])</span>
<span class="sd">            &gt;&gt;&gt; rx = np.array([1,1])</span>
<span class="sd">            &gt;&gt;&gt; s.ev(L)</span>
<span class="sd">            &gt;&gt;&gt; M = s.image(tx)</span>
<span class="sd">            &gt;&gt;&gt; isvalid,Y = s.backtrace(tx,rx,M)</span>
<span class="sd">            &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">            &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">            &gt;&gt;&gt; l1 = ax.plot(tx[0],tx[1],&#39;or&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l2 = ax.plot(rx[0],rx[1],&#39;og&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l3 = ax.plot(M[0,:],M[1,:],&#39;ob&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l4 = ax.plot(Y[0,:],Y[1,:],&#39;xk&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ray = np.hstack((np.hstack((tx.reshape(2,1),Y)),rx.reshape(2,1)))</span>
<span class="sd">            &gt;&gt;&gt; l5 = ax.plot(ray[0,:],ray[1,:],color=&#39;#999999&#39;,alpha=0.6,linewidth=0.6)</span>
<span class="sd">            &gt;&gt;&gt; fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For mathematical details see :</span>

<span class="sd">        @INPROCEEDINGS{6546704,</span>
<span class="sd">        author={Laaraiedh, Mohamed and Amiot, Nicolas and Uguen, Bernard},</span>
<span class="sd">        booktitle={Antennas and Propagation (EuCAP), 2013 7th European Conference on},</span>
<span class="sd">        title={Efficient ray tracing tool for UWB propagation and</span>
<span class="sd">               localization modeling},</span>
<span class="sd">        year={2013},</span>
<span class="sd">        pages={2307-2311},}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#import ipdb</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="c">#import pdb</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pa</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">I2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">pkm1</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">pkm1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>          <span class="c"># interaction counter</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>      <span class="c"># to enter into the loop</span>
        <span class="n">isvalid</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># signature is asumed being valid by default</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span>
        <span class="c"># if tuple(self.seq) == ( 42, -277,  135,   21,   46,  319):</span>
        <span class="c">#     import ipdb</span>
        <span class="c">#     ipdb.set_trace()</span>
        <span class="c"># while (((beta &lt;= 1) &amp; (beta &gt;= 0)) &amp; (k &lt; N)):</span>
        <span class="k">while</span> <span class="p">(((</span><span class="n">beta</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">-</span><span class="n">epsilon</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;=</span> <span class="n">epsilon</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)):</span>
            <span class="c">#if int(typ[k]) != 1: # not a diffraction (surprisingly it works)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># not a diffraction</span>
                <span class="c"># Formula (25) of paper Eucap 2013</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I2</span><span class="p">,</span> <span class="n">pkm1</span> <span class="o">-</span> <span class="n">M</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">z0</span><span class="p">))</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I2</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span>
                                <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                                <span class="n">pb</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="p">))</span>
                <span class="c"># print pkm1</span>
                <span class="c"># import ipdb</span>
                <span class="c"># ipdb.set_trace()</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span>
                <span class="n">yk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pkm1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

                <span class="n">deT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">deT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-15</span><span class="p">:</span>
                    <span class="k">return</span><span class="p">(</span><span class="bp">False</span><span class="p">,(</span><span class="n">k</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">yk</span><span class="p">)</span>
                <span class="n">pkm1</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">gk</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="mi">2</span><span class="p">::]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">gk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">gk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">pkm1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c"># dummy necessary for the test below</span>
                <span class="c"># fixing #210</span>
                <span class="c">#Y = np.hstack((Y, pa[:, k].reshape((2, 1))))</span>
                <span class="c">#pkm1 = pa[:, k].reshape((2, 1))</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
                <span class="n">pkm1</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))):</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">isvalid</span><span class="p">,</span><span class="n">Y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isvalid</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">isvalid</span><span class="p">,(</span><span class="n">k</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signature.sig2beam"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.sig2beam.html#pylayers.antprop.signature.Signature.sig2beam">[docs]</a>    <span class="k">def</span> <span class="nf">sig2beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;incremental&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; signature to beam</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        p : point</span>
<span class="sd">        mode : string</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">L</span><span class="o">.</span><span class="n">Gr</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c"># ev transforms a sequence of segment into numpy arrays (points)</span>
        <span class="c"># necessary for image calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="c"># calculates images from pTx</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signature.sig2ray"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.sig2ray.html#pylayers.antprop.signature.Signature.sig2ray">[docs]</a>    <span class="k">def</span> <span class="nf">sig2ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">pTx</span><span class="p">,</span> <span class="n">pRx</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;incremental&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; convert a signature to a 2D ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        pTx : ndarray</span>
<span class="sd">            2D transmitter position</span>
<span class="sd">        pRx : ndarray</span>
<span class="sd">            2D receiver position</span>
<span class="sd">        mod : if mod==&#39;incremental&#39; a set of alternative signatures is return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Y : ndarray (2x(N+2))</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.image</span>
<span class="sd">        Signature.backtrace</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#try:</span>
        <span class="c">#    L.Gr</span>
        <span class="c">#except:</span>
        <span class="c">#    L.build()</span>

        <span class="c"># ev transforms a sequence of segment into numpy arrays (points)</span>
        <span class="c"># necessary for image calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="c"># calculates images from pTx</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">pTx</span><span class="p">)</span>
        <span class="c">#print self</span>
        <span class="c">#if np.array_equal(self.seq,np.array([5,7,4])):</span>
        <span class="c">#    pdb.set_trace()</span>
        <span class="n">isvalid</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backtrace</span><span class="p">(</span><span class="n">pTx</span><span class="p">,</span> <span class="n">pRx</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="c">#print isvalid,Y</span>
        <span class="c">#</span>
        <span class="c"># If incremental mode this function returns an alternative signature</span>
        <span class="c"># in case the signature do not yield a valid ray.</span>
        <span class="c">#</span>
        <span class="n">isray</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s">&#39;incremental&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isvalid</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="n">Y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isray</span><span class="o">=</span><span class="bp">False</span>
                <span class="c"># something to do here</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isvalid</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="n">Y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isray</span><span class="o">=</span><span class="bp">False</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="bp">None</span>

<span class="c"># def get_sigslist(self, tx, rx):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        get signatures (in one list of arrays) between tx and rx</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#            tx : numpy.ndarray</span>
<span class="c">#            rx : numpy.ndarray</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            sigslist = numpy.ndarray</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        try:</span>
<span class="c">#            self.L.Gi</span>
<span class="c">#        except:</span>
<span class="c">#            self.L.build()</span>
<span class="c">#        # all the vnodes &gt;0  from the room</span>
<span class="c">#        #</span>
<span class="c">#        NroomTx = self.L.pt2ro(tx)</span>
<span class="c">#        NroomRx = self.L.pt2ro(rx)</span>
<span class="c">#        print NroomTx,NroomRx</span>
<span class="c">#</span>
<span class="c">#        if not self.L.Gr.has_node(NroomTx) or not self.L.Gr.has_node(NroomRx):</span>
<span class="c">#            raise AttributeError(&#39;Tx or Rx is not in Gr&#39;)</span>
<span class="c">#</span>
<span class="c">#        #list of interaction</span>
<span class="c">#        ndt = self.L.Gt.node[self.L.Gr.node[NroomTx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
<span class="c">#        ndr = self.L.Gt.node[self.L.Gr.node[NroomRx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
<span class="c">#</span>
<span class="c">#        ndt1 = filter(lambda l: len(eval(l))&gt;2,ndt)</span>
<span class="c">#        ndt2 = filter(lambda l: len(eval(l))&lt;3,ndt)</span>
<span class="c">#        ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr)</span>
<span class="c">#        ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr)</span>
<span class="c">#</span>
<span class="c">#        print ndt1</span>
<span class="c">#        print ndr1</span>
<span class="c">#        ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;NroomTx,ndt1)</span>
<span class="c">#        ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;NroomRx,ndr1)</span>
<span class="c">#</span>
<span class="c">#        ndt = ndt1 + ndt2</span>
<span class="c">#        ndr = ndr1 + ndr2</span>
<span class="c">#</span>
<span class="c">#        ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        sigslist = []</span>
<span class="c">#</span>
<span class="c">#        for nt in ndt:</span>
<span class="c">#            print nt</span>
<span class="c">#            for nr in ndr:</span>
<span class="c">#                addpath = False</span>
<span class="c">#                print nr</span>
<span class="c">#                if (nt != nr):</span>
<span class="c">#                    try:</span>
<span class="c">#                        path = nx.dijkstra_path(self.L.Gi, nt, nr)</span>
<span class="c">#                        #paths = nx.all_simple_paths(self.L.Gi,source=nt,target=nr)</span>
<span class="c">#                        addpath = True</span>
<span class="c">#                        showsig(self.L,path,tx,rx)</span>
<span class="c">#                    except:</span>
<span class="c">#                        pass</span>
<span class="c">#                if addpath:</span>
<span class="c">#                    sigarr = np.array([]).reshape(2, 0)</span>
<span class="c">#                    for interaction in path:</span>
<span class="c">#                        it = eval(interaction)</span>
<span class="c">#                        if type(it) == tuple:</span>
<span class="c">#                            if len(it)==2: #reflexion</span>
<span class="c">#                                sigarr = np.hstack((sigarr,</span>
<span class="c">#                                                np.array([[it[0]],[1]])))</span>
<span class="c">#                            if len(it)==3: #transmission</span>
<span class="c">#                                sigarr = np.hstack((sigarr,</span>
<span class="c">#                                                np.array([[it[0]], [2]])))</span>
<span class="c">#                        elif it &lt; 0: #diffraction</span>
<span class="c">#                            sigarr = np.hstack((sigarr,</span>
<span class="c">#                                                np.array([[it], [3]])))</span>
<span class="c">#                    sigslist.append(sigarr)</span>
<span class="c">#</span>
<span class="c">#        return sigslist</span>
<span class="c">#</span>
<span class="c">#    def update_sigslist(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        get signatures taking into account reverberations</span>
<span class="c">#</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            sigslist: numpy.ndarry</span>
<span class="c">#</span>
<span class="c">#        Notes</span>
<span class="c">#        -----</span>
<span class="c">#        This is a preliminary function need more investigations</span>
<span class="c">#</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        pTx = self.pTx</span>
<span class="c">#        pRx = self.pRx</span>
<span class="c">#        NroomTx = self.L.pt2ro(pTx)</span>
<span class="c">#        NroomRx = self.L.pt2ro(pRx)</span>
<span class="c">#        if NroomTx == NroomRx:</span>
<span class="c">#            sigslist = self.get_sigslist(pTx, pRx)</span>
<span class="c">#        else:</span>
<span class="c">#            sigslist = []</span>
<span class="c">#            sigtx = self.get_sigslist(pTx, pTx)</span>
<span class="c">#            sigrx = self.get_sigslist(pRx, pRx)</span>
<span class="c">#            sigtxrx = self.get_sigslist(pTx, pRx)</span>
<span class="c">#            sigslist = sigslist + sigtxrx</span>
<span class="c">#            for sigtr in sigtxrx:</span>
<span class="c">#                for sigt in sigtx:</span>
<span class="c">#                    if (sigt[:, -1] == sigtr[:, 0]).all():</span>
<span class="c">#                        if np.shape(sigtr)[1] == 1 or np.shape(sigt)[1] == 1:</span>
<span class="c">#                            pass</span>
<span class="c">#                        else:</span>
<span class="c">#                            sigslist.append(np.hstack((sigt, sigtr[:, 1:])))</span>
<span class="c">#                for sigr in sigrx:</span>
<span class="c">#                    if (sigr[:, 0] == sigtr[:, -1]).all():</span>
<span class="c">#                        if np.shape(sigtr)[1] == 1 or np.shape(sigr)[1] == 1:</span>
<span class="c">#                            pass</span>
<span class="c">#                        else:</span>
<span class="c">#                            sigslist.append(np.hstack((sigtr, sigr[:, 1:])))</span>
<span class="c">#</span>
<span class="c">#        return sigslist</span>
<span class="c">#</span>
<span class="c">#    def image_ceilfloor(self, tx, pa, pb):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Compute the images of tx with respect to ceil or floor</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#            tx : numpy.ndarray</span>
<span class="c">#            pa : numpy.ndarray</span>
<span class="c">#            pb : numpy.ndarray</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            M : numpy.ndarray</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c">#        pab = pb - pa</span>
<span class="c">#        alpha = np.sum(pab * pab, axis=0)</span>
<span class="c">#        zalpha = np.where(alpha == 0.)</span>
<span class="c">#        alpha[zalpha] = 1.</span>
<span class="c">#</span>
<span class="c">#        a = 1 - (2. / alpha) * (pa[1, :] - pb[1, :]) ** 2</span>
<span class="c">#        b = (2. / alpha) * (pb[0, :] - pa[0, :]) * (pa[1, :] - pb[1, :])</span>
<span class="c">#        c = (2. / alpha) * (pa[0, :] * (pa[1, :] - pb[1, :]) ** 2 +</span>
<span class="c">#                            pa[1, :] * (pa[1, :] - pb[1, :]) *</span>
<span class="c">#                            (pb[0, :] - pa[0, :]))</span>
<span class="c">#        d = (2. / alpha) * (pa[1, :] * (pb[0, :] - pa[0, :]) ** 2 +</span>
<span class="c">#                            pa[0, :] * (pa[1, :] - pb[1, :]) *</span>
<span class="c">#                            (pb[0, :] - pa[0, :]))</span>
<span class="c">#</span>
<span class="c">#        S = np.zeros((1, 2, 2))</span>
<span class="c">#        S[:, 0, 0] = -a</span>
<span class="c">#        S[:, 0, 1] = b</span>
<span class="c">#        S[:, 1, 0] = b</span>
<span class="c">#        S[:, 1, 1] = a</span>
<span class="c">#        A = np.eye(2)</span>
<span class="c">#</span>
<span class="c">#        vc0 = np.array([c[0], d[0]])</span>
<span class="c">#        y = np.dot(-S[0, :, :], tx) + vc0</span>
<span class="c">#</span>
<span class="c">#        x = la.solve(A, y)</span>
<span class="c">#        M = np.vstack((x[0::2], x[1::2]))</span>
<span class="c">#        return M</span>
<span class="c">#</span>
<span class="c">#    def backtrace_ceilfloor(self, tx, rx, pa, pb, M):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        backtracing step: given the image, tx, and rx, this function</span>
<span class="c">#        traces the 2D ray.</span>
<span class="c">#</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#            tx :  numpy.ndarray</span>
<span class="c">#                  transmitter</span>
<span class="c">#            rx :  numpy.ndarray</span>
<span class="c">#                  receiver</span>
<span class="c">#            M  :  numpy.ndarray</span>
<span class="c">#                  images obtained using image()</span>
<span class="c">#</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            Y : numpy.ndarray</span>
<span class="c">#                2D ray</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        N = np.shape(pa)[1]</span>
<span class="c">#        I2 = np.eye(2)</span>
<span class="c">#        z0 = np.zeros((2, 1))</span>
<span class="c">#</span>
<span class="c">#        pkm1 = rx.reshape(2, 1)</span>
<span class="c">#        Y = pkm1</span>
<span class="c">#        k = 0</span>
<span class="c">#        beta = .5</span>
<span class="c">#        cpt = 0</span>
<span class="c">#        while (((beta &lt;= 1) &amp; (beta &gt;= 0)) &amp; (k &lt; N)):</span>
<span class="c">#            l0 = np.hstack((I2, pkm1 - M[:, N - (k + 1)].reshape(2, 1), z0</span>
<span class="c">#                            ))</span>
<span class="c">#            l1 = np.hstack((I2, z0,</span>
<span class="c">#                            pa[:, N - (k + 1)].reshape(2, 1) -</span>
<span class="c">#                            pb[:, N - (k + 1)].reshape(2, 1)</span>
<span class="c">#                            ))</span>
<span class="c">#</span>
<span class="c">#            T = np.vstack((l0, l1))</span>
<span class="c">#            yk = np.hstack((pkm1[:, 0].T, pa[:, N - (k + 1)].T))</span>
<span class="c">#            deT = np.linalg.det(T)</span>
<span class="c">#            if abs(deT) &lt; 1e-15:</span>
<span class="c">#                return(None)</span>
<span class="c">#            xk = la.solve(T, yk)</span>
<span class="c">#            pkm1 = xk[0:2].reshape(2, 1)</span>
<span class="c">#            gk = xk[2::]</span>
<span class="c">#            alpha = gk[0]</span>
<span class="c">#            beta = gk[1]</span>
<span class="c">#            Y = np.hstack((Y, pkm1))</span>
<span class="c">#            k += 1</span>
<span class="c">#        if ((k == N) &amp; ((beta &gt; 0) &amp; (beta &lt; 1))):  # &amp; ((alpha &gt; 0) &amp; (alpha &lt; 1))):</span>
<span class="c">#            Y = np.hstack((Y, tx.reshape(2, 1)))</span>
<span class="c">#            return(Y)</span>
<span class="c">#        else:</span>
<span class="c">#            return(None)</span>
<span class="c">#   def sigs2rays(self, sigslist):</span>
<span class="c">#        &quot;&quot;&quot; from signatures list to 2D rays</span>
<span class="c">#</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#</span>
<span class="c">#            sigslist : list</span>
<span class="c">#</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#</span>
<span class="c">#            rays : dict</span>
<span class="c">#</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        rays = {}</span>
<span class="c">#        for sig in sigslist:</span>
<span class="c">#            s = Signature(sig)</span>
<span class="c">#            Yi = s.sig2ray(self.L, self.pTx[:2], self.pRx[:2])</span>
<span class="c">#            if Yi is not None:</span>
<span class="c">#                #pdb.set_trace()</span>
<span class="c">#                Yi = np.fliplr(Yi)</span>
<span class="c">#                nint = len(sig[0, :])</span>
<span class="c">#                if str(nint) in rays.keys():</span>
<span class="c">#                    Yi3d = np.vstack((Yi[:, 1:-1], np.zeros((1, nint))))</span>
<span class="c">#                    Yi3d = Yi3d.reshape(3, nint, 1)</span>
<span class="c">#                    rays[str(nint)][&#39;pt&#39;] = np.dstack((</span>
<span class="c">#                                                      rays[str(nint)][&#39;pt&#39;], Yi3d))</span>
<span class="c">#                    rays[str(nint)][&#39;sig&#39;] = np.dstack((</span>
<span class="c">#                                                       rays[str(nint)][&#39;sig&#39;],</span>
<span class="c">#                                                       sig.reshape(2, nint, 1)))</span>
<span class="c">#                else:</span>
<span class="c">#                    rays[str(nint)] = {&#39;pt&#39;: np.zeros((3, nint, 1)),</span>
<span class="c">#                                       &#39;sig&#39;: np.zeros((2, nint, 1))}</span>
<span class="c">#                    rays[str(nint)][&#39;pt&#39;][0:2, :, 0] = Yi[:, 1:-1]</span>
<span class="c">#                    rays[str(nint)][&#39;sig&#39;][:, :, 0] = sig</span>
<span class="c">#        return rays</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;testing pylayers/antprop/signature.py&quot;</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;-------------------------------------&quot;</span>
</pre></div>

          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>
  


    <div class="footer">
        &copy; 2015, PyLayers developer team.
      Last updated on mars 26, 2015.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2. Design by <a href="http://desgrana.es">Desgrana</a>.
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../../../py-modindex.html">
        Previous
      </a>  
    </div>
    
     </div>
     <script type="text/javascript">
       $("div.buttonNext, div.buttonPrevious").hover(
           function () {
               $(this).css('background-color', '#AFFFFF');
           },
           function () {
               $(this).css('background-color', '#AFFFFF');
           }
       );
     </script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34943220-1']);
  _gaq.push(['_setDomainName', 'pylayers.github.io']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })(); 
</script> 
 
  </body>
</html>