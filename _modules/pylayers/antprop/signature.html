
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pylayers.antprop.signature &mdash; Python 1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="Python 1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34943220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body role="document">

    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../../../index.html">
            <img src="../../../_static/pylayers.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../../../download.html">Download</a></li>
            <li><a href="../../../notebook/TOC.html">User Guide</a></li>
            <li><a href="../../../modules/pylayers.html">Reference</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script>
  (function() {
       var cx = '004820205189002234612:sa15qzuf2ca';
           var gcse = document.createElement('script');
               gcse.type = 'text/javascript';
                   gcse.async = true;
                       gcse.src = (document.location.protocol == 'https:' ?
                           'https:' : 'http:') +
                               '//cse.google.com/cse.js?cx=' + cx;
                                   var s =
                                   document.getElementsByTagName('script')[0];
                                       s.parentNode.insertBefore(gcse, s);
                                         })();
</script>
<gcse:search></gcse:search>
</div>
</div> <!-- end navbar --></div>
    </div>

    <div class="content-wrapper">

      <div class="sphinxsidebar">
	<div class="sphinxsidebarwrapper">
	  <div class="rel">
	   
	<!-- rellinks[1:] is an ugly hack to avoid link to module
	    index  -->
	<div class="rellink">
	<a href="../../../py-modindex.html" title="Python Module Index"
	    >Modules
	    <br>
	    <span class="smallrellink">
	    Python Module...
	    </span>
	    <span class="hiddenrellink">
	    Python Module Index
	    </span>
	    
	    </a>
	</div>
	<!-- Ad a link to the 'up' page -->
	<div class="spacer">
	&nbsp;
	</div>
	<div class="rellink">
	<a href="../../index.html" title="Module code" >
	Up
	<br>
	<span class="smallrellink">
	Module code
	</span>
	<span class="hiddenrellink">
	Module code
	</span>
	
	</a>
	</div>
    </div>
    <p style="text-align: center; background-color: #BFFFFF">This documentation is

    for Python <strong>version 1</strong>
    &mdash; <a href="https://github.com/pylayers/pylayers/archive/master.zip">Other versions</a></p>
    
    <h3>Citing</h3>
    <p>If you use the software, please consider
    <a href="../../../about.html#citing-pylayers">citing pylayers</a>.</p>
    <h3>This page</h3>
	
    
    </div>
	  </div>


      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pylayers.antprop.signature</h1><div class="highlight"><pre>
<span></span><span class="c1">#-*- coding:Utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class Signatures</span>
<span class="sd">================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Signatures.__init__</span>
<span class="sd">    Signatures.__repr__</span>
<span class="sd">    Signatures.__len__</span>
<span class="sd">    Signatures.num</span>
<span class="sd">    Signatures.info</span>
<span class="sd">    Signatures.saveh5</span>
<span class="sd">    Signatures.loadh5</span>
<span class="sd">    Signatures._saveh5</span>
<span class="sd">    Signatures._loadh5</span>
<span class="sd">    Signatures.load</span>
<span class="sd">    Signatures.save</span>
<span class="sd">    Signatures.sp</span>
<span class="sd">    Signatures.procone</span>
<span class="sd">    Signatures.propaths</span>
<span class="sd">    Signatures.short_propath</span>
<span class="sd">    Signatures.propaths2</span>
<span class="sd">    Signatures.propaths3</span>
<span class="sd">    Signatures.propaths2015_2</span>
<span class="sd">    Signatures.procone2</span>
<span class="sd">    Signatures.calsig</span>
<span class="sd">    Signatures.exist</span>
<span class="sd">    Signatures.run2015</span>
<span class="sd">    Signatures.run2015_2</span>
<span class="sd">    Signatures.dido</span>
<span class="sd">    Signatures.run</span>
<span class="sd">    Signatures.run_old</span>
<span class="sd">    Signatures.run_exp</span>
<span class="sd">    Signatures.run_exp2</span>
<span class="sd">    Signatures.meta</span>
<span class="sd">    Signatures.lineofcycle</span>
<span class="sd">    Signatures.cones</span>
<span class="sd">    Signatures.unfold</span>
<span class="sd">    Signatures.show</span>
<span class="sd">    Signatures.showi</span>
<span class="sd">    Signatures.rays</span>
<span class="sd">    Signatures.raysv</span>
<span class="sd">    Signatures.image</span>
<span class="sd">    Signatures.image2</span>

<span class="sd">Class Signature</span>
<span class="sd">===============</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Signature.__init__</span>
<span class="sd">    Signature.__repr__</span>
<span class="sd">    Signature.info</span>
<span class="sd">    Signature.split</span>
<span class="sd">    Signature.ev2</span>
<span class="sd">    Signature.evf</span>
<span class="sd">    Signature.ev</span>
<span class="sd">    Signature.unfold</span>
<span class="sd">    Signature.evtx</span>
<span class="sd">    Signature.image</span>
<span class="sd">    Signature.backtrace</span>
<span class="sd">    Signature.sig2beam</span>
<span class="sd">    Signature.sig2ray</span>

<span class="sd">Utility functions</span>
<span class="sd">=================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    showsig</span>
<span class="sd">    gidl</span>
<span class="sd">    frontline</span>
<span class="sd">    edgeout2</span>
<span class="sd">    edgeout</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="c1">#import scipy as sp</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="kn">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="kn">as</span> <span class="nn">shg</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">pylayers.gis.layout</span> <span class="kn">as</span> <span class="nn">layout</span>
<span class="kn">import</span> <span class="nn">pylayers.util.geomutil</span> <span class="kn">as</span> <span class="nn">geu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.cone</span> <span class="kn">as</span> <span class="nn">cone</span>
<span class="c1">#import pylayers.util.graphutil as gph</span>
<span class="kn">import</span> <span class="nn">pylayers.util.pyutil</span> <span class="kn">as</span> <span class="nn">pyu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.plotutil</span> <span class="kn">as</span> <span class="nn">plu</span>
<span class="kn">from</span> <span class="nn">pylayers.antprop.rays</span> <span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span> <span class="nn">pylayers.util.project</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="kn">as</span> <span class="nn">sh</span>
<span class="kn">import</span> <span class="nn">shapely.ops</span> <span class="kn">as</span> <span class="nn">sho</span>
<span class="c1">#from numba import autojit</span>


<span class="k">def</span> <span class="nf">plot_lines</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">[]):</span>

    <span class="kn">from</span> <span class="nn">descartes.patch</span> <span class="kn">import</span> <span class="n">PolygonPatch</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ob</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span> 
                <span class="n">c</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span>
            <span class="k">elif</span> <span class="n">ii</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span><span class="o">=</span> <span class="s1">&#39;k&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span><span class="o">=</span><span class="n">color</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">xy</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">solid_capstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
<span class="k">def</span> <span class="nf">plot_poly</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">[]):</span>
    
    <span class="kn">from</span> <span class="nn">descartes.patch</span> <span class="kn">import</span> <span class="n">PolygonPatch</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ob</span><span class="p">):</span>
        
        <span class="n">pp</span> <span class="o">=</span> <span class="n">PolygonPatch</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>



<div class="viewcode-block" id="showsig"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.showsig.html#pylayers.antprop.signature.showsig">[docs]</a><span class="k">def</span> <span class="nf">showsig</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">tx</span><span class="o">=</span><span class="p">[],</span><span class="n">rx</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot; show signature</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L  : Layout</span>
<span class="sd">    s  :</span>
<span class="sd">    tx :</span>
<span class="sd">    rx :</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">showGs</span><span class="p">()</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlabel&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">L</span><span class="o">.</span><span class="n">showGs</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">edlist</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tx</span> <span class="o">!=</span><span class="p">[]:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rx</span> <span class="o">!=</span><span class="p">[]:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlabel&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">False</span></div>


<div class="viewcode-block" id="gidl"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.gidl.html#pylayers.antprop.signature.gidl">[docs]</a><span class="k">def</span> <span class="nf">gidl</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; gi without diffraction</span>

<span class="sd">   Returns</span>
<span class="sd">   -------</span>

<span class="sd">   gr : A graph </span>

<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">edlist</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pos</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">edlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">gr</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edlist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gr</span><span class="o">.</span><span class="n">edge</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="n">gr</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">ke</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k1</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">va</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k1</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">keva</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ke</span><span class="p">,</span><span class="n">va</span><span class="p">)</span>
            <span class="n">keva_valid</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keva</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">gr</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k1</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">keva_valid</span><span class="p">)</span>

    <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">g</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edlist</span><span class="p">}</span>
    <span class="n">gr</span><span class="o">.</span><span class="n">pos</span><span class="o">=</span><span class="n">dpos</span>
    <span class="k">return</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">shLtmp</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">seg_connect</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">}</span>

    <span class="n">dpts</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seg_connect</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">}</span>
    <span class="n">L</span><span class="o">.</span><span class="n">_shseg</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dpts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<span class="k">def</span> <span class="nf">showsig2</span><span class="p">(</span><span class="n">lsig</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">tahe</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lsig</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">lsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">:</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">npt</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">k1</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">plu</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">pta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">phe</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k1</span> <span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">plu</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">pta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">phe</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">tahe</span><span class="p">:</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="n">th</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">he</span> <span class="o">=</span> <span class="n">th</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">plu</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">ta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">he</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                      

    <span class="n">tahe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tahe</span><span class="p">)</span> <span class="c1"># Nseg x tahe x xy </span>
    <span class="n">pta</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>  <span class="c1">#2 x Nseg</span>
    <span class="n">phe</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># 2 x Nseg </span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">ccw</span><span class="p">(</span><span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">^</span>
            <span class="n">geu</span><span class="o">.</span><span class="n">ccw</span><span class="p">(</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">):</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># twisted = True</span>
        <span class="n">lef</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">rig</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lef</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">rig</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
    <span class="c1">#L.showG(&#39;s&#39;,labels=True)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">_shseg</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lsig</span><span class="p">))</span>
    <span class="n">plot_lines</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">(),</span><span class="n">ob</span><span class="o">=</span><span class="n">lines</span><span class="p">)</span>
    <span class="n">plot_lines</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">(),</span><span class="n">ob</span><span class="o">=</span><span class="p">[</span><span class="n">lef</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>
    <span class="n">plot_lines</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">(),</span><span class="n">ob</span><span class="o">=</span><span class="p">[</span><span class="n">rig</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pta</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">pta</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;tail&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">phe</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">phe</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;head&#39;</span><span class="p">)</span>
    <span class="c1">#plu.displot(vl[0].reshape(2,1),vl[1].reshape(2,1),arrow=True)</span>
    <span class="c1">#plu.displot(vr[0].reshape(2,1),vr[1].reshape(2,1),arrow=True)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="c1">#@profile</span>
<span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="n">lsig</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">tahe</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Check if a signature is valid.</span>
<span class="sd">    if a segment of a given signature is not in or touches the polygon</span>
<span class="sd">    described by the 1st and last segment, the signature is not valid</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    lsig : list of tuple from run  |signatures</span>
<span class="sd">    L : layout</span>
<span class="sd">    tahe : </span>
<span class="sd">        lensig , ta|he , x,y</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    inside : boolean</span>
<span class="sd">        is the signature valid ?</span>


<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">lensi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lsig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lensi</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="c1"># DEBUG</span>
    <span class="c1"># if lensi == 4:</span>
    <span class="c1">#     if np.all(lsig == np.array([[ 5,  2, 67, 58],[ 2,  2,  3,  2]]).T):</span>
    <span class="c1">#         import ipdb</span>
    <span class="c1">#         ipdb.set_trace()</span>

    <span class="c1"># ensure compatibility with Signature.run where</span>
    <span class="c1"># lsig is a list of tuple</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lsig</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">lsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">])</span>

    <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>
    <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>

    <span class="n">seq</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># upos = np.where(seq&gt;0)[0]</span>
    <span class="c1"># uneg = np.where(seq&lt;0)[0]</span>
    
    <span class="c1"># tahep = L.seg2pts(seq[upos])</span>
    <span class="c1"># tahen = np.array([L.Gs.pos[i] for i in seq[uneg]]).T</span>
    <span class="c1"># tahen = np.vstack((tahen,tahen))</span>
    <span class="c1"># tahe = np.empty((4,lensi))</span>
    <span class="c1"># tahe[:,upos]=tahep</span>
    <span class="c1"># try:</span>
    <span class="c1">#     tahe[:,uneg]=tahen</span>
    <span class="c1"># except:</span>
    <span class="c1">#     pass</span>
    <span class="c1"># pts = [k for i in seq for k in [L.Gs[i].keys()[0],L.Gs[i].keys()[1]]]</span>
    <span class="c1"># if tahe ==[]:</span>
    <span class="c1"># print &#39;run tahe\n&#39;,np.array(tahe)</span>
    <span class="c1"># if tahe == []:</span>
    <span class="c1">#     pts = [L.Gs[i].keys() for i in seq]</span>
    <span class="c1">#     tahe = np.array([[L.Gs.pos[p[0]],L.Gs.pos[p[1]]] for p in pts])</span>

    <span class="c1">#     pta[:,0] = tahe[0,0,:]</span>
    <span class="c1">#     phe[:,0] = tahe[0,1,:]</span>

    <span class="c1">#     typ = lsig[:,1]</span>
    <span class="c1">#     mirror=[]</span>
    <span class="c1">#     # lines = [L._shseg[seq[0]]]</span>
    <span class="c1">#     for i in range(1,lensi):</span>
    <span class="c1">#         # pam = pa[:,i].reshape(2,1)</span>
    <span class="c1">#         # pbm = pb[:,i].reshape(2,1)</span>
    <span class="c1">#         pam = tahe[i,0,:].reshape(2,1)</span>
    <span class="c1">#         pbm = tahe[i,1,:].reshape(2,1)</span>
    <span class="c1">#         if typ[i] == 2: # R</span>
    <span class="c1">#             for m in mirror:</span>
    <span class="c1">#                 pam = geu.mirror(pam,pta[:,m],phe[:,m])</span>
    <span class="c1">#                 pbm = geu.mirror(pbm,pta[:,m],phe[:,m])</span>
    <span class="c1">#             pta[:,i] = pam.reshape(2)</span>
    <span class="c1">#             phe[:,i] = pbm.reshape(2)</span>
    <span class="c1">#             mirror.append(i)</span>

    <span class="c1">#         elif typ[i] == 3 : # T</span>
    <span class="c1">#             for m in mirror:</span>
    <span class="c1">#                 pam = geu.mirror(pam,pta[:,m],phe[:,m])</span>
    <span class="c1">#                 pbm = geu.mirror(pbm,pta[:,m],phe[:,m])</span>
    <span class="c1">#             pta[:,i] = pam.reshape(2)</span>
    <span class="c1">#             phe[:,i] = pbm.reshape(2)</span>
    <span class="c1">#         elif typ[i] == 1 : # D</span>
    <span class="c1">#             pta[:,i] = pam.reshape(2)</span>
    <span class="c1">#             phe[:,i] = pbm.reshape(2)</span>

    <span class="c1"># else:</span>

    <span class="n">tahe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tahe</span><span class="p">)</span> <span class="c1"># Nseg x tahe x xy </span>
    <span class="n">pta</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>  <span class="c1">#2 x Nseg</span>
    <span class="n">phe</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># 2 x Nseg </span>




    <span class="c1"># ### ONLY FOR TEST TO BE DELETED</span>
    <span class="c1"># pts = [L.Gs[i].keys() for i in seq]</span>
    <span class="c1"># tahetest = np.array([[L.Gs.pos[p[0]],L.Gs.pos[p[1]]] for p in pts])</span>
    <span class="c1"># ptat = np.empty((2,lensi))</span>
    <span class="c1"># phet = np.empty((2,lensi))</span>
    <span class="c1"># ptat[:,0] = tahetest[0,0,:]</span>
    <span class="c1"># phet[:,0] = tahetest[0,1,:]</span>

    <span class="c1"># typ = lsig[:,1]</span>
    <span class="c1"># mirror=[]</span>
    <span class="c1">#lines = [L._shseg[seq[0]]]</span>
    <span class="c1"># for i in range(1,lensi):</span>
    <span class="c1">#     # pam = pa[:,i].reshape(2,1)</span>
    <span class="c1">#     # pbm = pb[:,i].reshape(2,1)</span>
    <span class="c1">#     pam = tahetest[i,0,:].reshape(2,1)</span>
    <span class="c1">#     pbm = tahetest[i,1,:].reshape(2,1)</span>
    <span class="c1">#     if typ[i] == 2: # R</span>
    <span class="c1">#         for m in mirror:</span>
    <span class="c1">#             pam = geu.mirror(pam,ptat[:,m],phet[:,m])</span>
    <span class="c1">#             pbm = geu.mirror(pbm,ptat[:,m],phet[:,m])</span>
    <span class="c1">#         ptat[:,i] = pam.reshape(2)</span>
    <span class="c1">#         phet[:,i] = pbm.reshape(2)</span>
    <span class="c1">#         mirror.append(i)</span>

    <span class="c1">#     elif typ[i] == 3 : # T</span>
    <span class="c1">#         for m in mirror:</span>
    <span class="c1">#             pam = geu.mirror(pam,ptat[:,m],phet[:,m])</span>
    <span class="c1">#             pbm = geu.mirror(pbm,ptat[:,m],phet[:,m])</span>
    <span class="c1">#         ptat[:,i] = pam.reshape(2)</span>
    <span class="c1">#         phet[:,i] = pbm.reshape(2)</span>
    <span class="c1">#     elif typ[i] == 1 : # D</span>
    <span class="c1">#         ptat[:,i] = pam.reshape(2)</span>
    <span class="c1">#         phet[:,i] = pbm.reshape(2)</span>

    <span class="c1"># tahetest = np.dstack((ptat.T,phet.T)).swapaxes(1,2)</span>
    <span class="c1"># if np.sum(tahe-tahetest) != 0:</span>
    <span class="c1">#     import ipdb</span>
    <span class="c1">#     ipdb.set_trace()</span>
    
    <span class="c1"># determine the 2 side of the polygon ( top/bottom = tahe[0]/tahe[-1])</span>
    <span class="c1">#vl and vr are 2 director vector lying on the polygon side.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">ccw</span><span class="p">(</span><span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">^</span>
            <span class="n">geu</span><span class="o">.</span><span class="n">ccw</span><span class="p">(</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">):</span>
        <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># vr = ( pta[:,0],phe[:,-1])</span>
        <span class="c1"># vl = ( phe[:,0],pta[:,-1])</span>
        <span class="c1"># twisted = True</span>
        <span class="c1">#lef = sh.LineString((pta[:,0],pta[:,-1]))</span>
        <span class="c1">#rig = sh.LineString((phe[:,0],phe[:,-1]))</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span> <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">phe</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span> <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># vr = ( pta[:,0],pta[:,-1])</span>
        <span class="c1"># vl = ( phe[:,0],phe[:,-1])</span>
        <span class="c1"># twisted = False</span>
        <span class="c1">#lef = sh.LineString((pta[:,0],phe[:,-1]))</span>
        <span class="c1">#rig = sh.LineString((pta[:,-1],phe[:,0]))</span>
        
       


    <span class="c1"># looking situation where Tail and head are not inside the polygon</span>
    <span class="c1"># =&gt; both tahe are left of vr and vl</span>
    <span class="c1">#=&gt;   both tahe are right of vr and vl</span>
    <span class="n">lta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">isleft</span><span class="p">(</span><span class="n">pta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">vl</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="bp">None</span><span class="p">],</span><span class="n">vl</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="bp">None</span><span class="p">])</span>
    <span class="n">rta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">isleft</span><span class="p">(</span><span class="n">pta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">vr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="bp">None</span><span class="p">],</span><span class="n">vr</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="bp">None</span><span class="p">])</span>
    <span class="n">lhe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">isleft</span><span class="p">(</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">vl</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="bp">None</span><span class="p">],</span><span class="n">vl</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="bp">None</span><span class="p">])</span>
    <span class="n">rhe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">isleft</span><span class="p">(</span><span class="n">phe</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">vr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="bp">None</span><span class="p">],</span><span class="n">vr</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="bp">None</span><span class="p">])</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">lta</span> <span class="o">&amp;</span> <span class="n">lhe</span> <span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">rta</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">rhe</span><span class="p">)</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="o">~</span><span class="n">out</span>

    <span class="c1"># #debug</span>
    <span class="c1"># plt.ion()</span>
    <span class="c1"># plt.gcf()</span>
    <span class="c1"># #plt.title(str(cond))</span>
    <span class="c1"># #Ok plot_lines(ax=plt.gca(),ob=lines)</span>
    <span class="c1"># plot_lines(ax=plt.gca(),ob=[lef],color=&#39;g&#39;)</span>
    <span class="c1"># plot_lines(ax=plt.gca(),ob=[rig],color=&#39;r&#39;)</span>
    <span class="c1"># plt.scatter(pta[0,:],pta[1,:],marker=&#39;d&#39;,s=70,label=&#39;tail&#39;)</span>
    <span class="c1"># plt.scatter(phe[0,:],phe[1,:],marker=&#39;s&#39;,s=70,label=&#39;head&#39;)</span>
    <span class="c1"># plu.displot(vl[0].reshape(2,1),vl[1].reshape(2,1),arrow=True)</span>
    <span class="c1"># plu.displot(vr[0].reshape(2,1),vr[1].reshape(2,1),arrow=True)</span>
    <span class="c1"># plt.legend()</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">inside</span><span class="p">)</span>






<span class="k">class</span> <span class="nc">Signatures</span><span class="p">(</span><span class="n">PyLayers</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; set of Signature given 2 Gt cycle (convex) indices</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    L : gis.Layout</span>
<span class="sd">    source : int</span>
<span class="sd">        source convex cycle</span>
<span class="sd">    target : int</span>
<span class="sd">        target convex cycle</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Signatures.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__init__.html#pylayers.antprop.signature.Signatures.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        source : int</span>
<span class="sd">            cycle number</span>
<span class="sd">        target : int</span>
<span class="sd">            cycle index</span>
<span class="sd">        cutoff : int</span>
<span class="sd">            limiting depth level in graph exploration (default 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.sig&#39;</span></div>

<div class="viewcode-block" id="Signatures.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__repr__.html#pylayers.antprop.signature.Signatures.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">fun1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;----------&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="c1">#s = s + str(self.__sizeof__())+&#39;\n&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;from cycle : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to cycle &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># nl x 2 x nsig</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;   &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;   &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signatures.__len__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__len__.html#pylayers.antprop.signature.Signatures.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nsig</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span><span class="p">(</span><span class="n">nsig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signatures.num"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.num.html#pylayers.antprop.signature.Signatures.num">[docs]</a>    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine the number of signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsig</span> <span class="o">+=</span> <span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nint</span> <span class="o">+=</span> <span class="n">size</span><span class="o">*</span><span class="n">k</span></div>

<div class="viewcode-block" id="Signatures.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.info.html#pylayers.antprop.signature.Signatures.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print &quot;Signatures for scenario defined by :&quot;</span>
        <span class="c1"># print &quot;Layout&quot;</span>
        <span class="c1"># print &quot;======&quot;</span>
        <span class="c1"># L = self.L.info()</span>
        <span class="c1"># print &quot;================================&quot;</span>
        <span class="c1"># print &quot;source : &quot;, self.source</span>
        <span class="c1"># print &quot;target : &quot;, self.target</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;----------&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="c1">#s = s + str(self.__sizeof__())+&#39;\n&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">print</span> <span class="s1">&#39;from cycle : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to cycle &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s1">&#39;Reflection&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">BLUE</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;  &#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s1">&#39;Transmission&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">GREEN</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;  &#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s1">&#39;Diffraction&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
        <span class="k">print</span> <span class="s1">&#39;  </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># nl x 2 x nsig</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>

                <span class="n">nstr</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">typ</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="k">print</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">BLUE</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">GREEN</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
                <span class="k">print</span> <span class="s1">&#39;]&#39;</span>
            <span class="k">print</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span></div>
                <span class="c1"># s = s + &#39;   &#39;+ str(a[i,0,:]) + &#39;\n&#39;</span>

                <span class="c1"># s = s + &#39;   &#39;+ str(a[i,1,:]) + &#39;\n&#39;</span>

    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">OK</span> <span class="o">=</span> <span class="n">Signatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="n">KO</span> <span class="o">=</span> <span class="n">Signatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        
            <span class="n">sigs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sigs</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">sigs</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">,:]</span>

                <span class="n">ok</span> <span class="o">=</span> <span class="n">valid</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ok</span> <span class="p">:</span>
                    <span class="k">try</span> <span class="p">:</span>
                        <span class="n">OK</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">OK</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">sig</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">OK</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">OK</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">sig</span>
                        <span class="k">pass</span>
                <span class="k">else</span> <span class="p">:</span>

                    <span class="k">try</span> <span class="p">:</span>
                        <span class="n">KO</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">KO</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">sig</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">KO</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">KO</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">sig</span>
                        <span class="k">pass</span>
        <span class="k">return</span> <span class="n">OK</span><span class="p">,</span><span class="n">KO</span>

<div class="viewcode-block" id="Signatures.saveh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.saveh5.html#pylayers.antprop.signature.Signatures.saveh5">[docs]</a>    <span class="k">def</span> <span class="nf">saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save signatures in hdf5 format</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">_filename</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Signature: issue when writting h5py file&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signatures.loadh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.loadh5.html#pylayers.antprop.signature.Signatures.loadh5">[docs]</a>    <span class="k">def</span> <span class="nf">loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; load signatures hdf5 format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRSIG&#39;</span><span class="p">])</span>

        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][:]})</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Signature: issue when reading h5py file&#39;</span><span class="p">)</span>


        <span class="n">_fileL</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.ini&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">_fileL</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span></div>


<div class="viewcode-block" id="Signatures._saveh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures._saveh5.html#pylayers.antprop.signature.Signatures._saveh5">[docs]</a>    <span class="k">def</span> <span class="nf">_saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save in hdf5 compliant with Links</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filenameh5</span>
<span class="sd">        hrpname</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c1"># if grpname == &#39;&#39;:</span>
        <span class="c1">#     grpname = str(self.source) +&#39;_&#39;+str(self.target) +&#39;_&#39;+ str(self.cutoff)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># file management</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grpname</span> <span class="ow">in</span> <span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">grpname</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span> <span class="o">+</span><span class="s1">&#39;already exists in &#39;</span><span class="o">+</span><span class="n">filenameh5</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span><span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>

            <span class="c1"># write data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">_filename</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Signature: issue when writting h5py file&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Signatures._loadh5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures._loadh5.html#pylayers.antprop.signature.Signatures._loadh5">[docs]</a>    <span class="k">def</span> <span class="nf">_loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load signatures in hdf5 format compliant with class Links</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filenameh5 : string</span>
<span class="sd">            filename of the h5py file (from Links Class)</span>
<span class="sd">        grpname : string</span>
<span class="sd">            groupname of the h5py file (from Links Class)</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.links</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c1"># if grpname ==&#39;&#39;:</span>
        <span class="c1">#     grpname = str(self.source) +&#39;_&#39;+str(self.target) +&#39;_&#39;+ str(self.cutoff)</span>

        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span><span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][:]})</span>
            <span class="n">Lname</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Signature: issue when reading h5py file&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">Lname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span></div>


<div class="viewcode-block" id="Signatures.save"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.save.html#pylayers.antprop.signature.Signatures.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
          <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">L</span></div>

<div class="viewcode-block" id="Signatures.load"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.load.html#pylayers.antprop.signature.Signatures.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; load signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">sitmp</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span><span class="s1">&#39; does not exist&#39;</span><span class="p">)</span>


        <span class="c1"># to load a dictionary, use update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sitmp</span><span class="p">)</span>


        <span class="n">_fileL</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.ini&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">_fileL</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span></div>

<div class="viewcode-block" id="Signatures.sp"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.sp.html#pylayers.antprop.signature.Signatures.sp">[docs]</a>    <span class="k">def</span> <span class="nf">sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; algorithm for signature determination</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : Graph</span>
<span class="sd">        source : tuple or int</span>
<span class="sd">        target : tuple or int</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.antprop.signature.run3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">source</span><span class="p">])):</span>
                        <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                    <span class="c1"># yield visited +[target]</span>
                <span class="k">elif</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">source</span><span class="p">])):</span>
                        <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span></div>



<div class="viewcode-block" id="Signatures.procone"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.procone.html#pylayers.antprop.signature.Signatures.procone">[docs]</a>    <span class="k">def</span> <span class="nf">procone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target looking backward</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;source :&quot;,source</span>
        <span class="c1">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="c1"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="c1"># while the list of iterators is not void</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
            <span class="c1"># children is the last iterator of stack</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c1">#print &quot;child : &quot;,child</span>
            <span class="c1">#print &quot;visited :&quot;,visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c1"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c1"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># remove from visited list</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span> <span class="c1"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c1"># if child is the target point - YIELD A SIGNATURE</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="c1"># output signature</span>
                <span class="k">else</span><span class="p">:</span>
                <span class="c1">#elif child not in visited: # else visit other node - CONTINUE APPEND CHILD</span>
                    <span class="c1"># getting signature until last point</span>
                    <span class="n">diff</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span>
                    <span class="c1"># looking backward with a cone</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># warning visited is also appended visited[-2] is the</span>
                        <span class="c1"># last node</span>
                        <span class="n">brin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">evf</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                        <span class="n">ta</span><span class="p">,</span><span class="n">he</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
                        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                        <span class="n">segchild</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">segvm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">segchild</span><span class="p">,</span><span class="n">segvm1</span><span class="p">)</span>
                        <span class="n">typ</span><span class="p">,</span><span class="n">proba</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">ta</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="c1">#fig,ax = plu.displot(ta,he)</span>
                        <span class="c1">#fig,ax = cn.show(fig=fig,ax=ax)</span>
                        <span class="c1">#plt.show()</span>
                        <span class="c1">#pdb.set_trace()</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c1"># child no valid (do nothing)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># child valid (append child to visited and go forward)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span></div>


<div class="viewcode-block" id="Signatures.short_propath"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.short_propath.html#pylayers.antprop.signature.Signatures.short_propath">[docs]</a>    <span class="k">def</span> <span class="nf">short_propath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; updated dijkstra</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">==</span><span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">({</span><span class="n">source</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]})</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary of final distances</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]}</span>  <span class="c1"># dictionary of paths</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">fringe</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># use heapq with (distance,label) tuples</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">fringe</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="n">source</span><span class="p">))</span>
        <span class="n">firstloop</span><span class="o">=</span><span class="bp">True</span>
        <span class="k">while</span> <span class="n">fringe</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="n">oldv</span> <span class="o">=</span> <span class="n">v</span>
            <span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">=</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">fringe</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dist</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c1"># already searched this node.</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1">#for ignore,w,edgedata in G.edges_iter(v,data=True):</span>
            <span class="c1">#is about 30% slower than the following</span>
            <span class="k">if</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="n">edata</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">edata</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">oldv</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">edgedata</span> <span class="ow">in</span> <span class="n">edata</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weight</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                        <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">edgedata</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="c1">#+ edgedata.get(weight,1) #&lt;= proba should be add here</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vw_dist</span><span class="o">&gt;</span><span class="n">cutoff</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vw_dist</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Contradictory paths found:&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;negative weights?&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">or</span> <span class="n">vw_dist</span> <span class="o">&lt;</span> <span class="n">seen</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">seen</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">vw_dist</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">fringe</span><span class="p">,(</span><span class="n">vw_dist</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">firstloop</span><span class="o">=</span><span class="bp">False</span>


        <span class="k">if</span> <span class="n">paths</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dout</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])):</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">]])</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">dout</span></div>


<div class="viewcode-block" id="Signatures.propaths"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths.html#pylayers.antprop.signature.Signatures.propaths">[docs]</a>    <span class="k">def</span> <span class="nf">propaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;source :&quot;,source</span>
        <span class="c1">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c1"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c1"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># while the list of iterators is not void</span>
        <span class="c1"># import ipdb</span>
        <span class="c1"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
            <span class="c1"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c1"># update number of useful segments</span>
            <span class="c1"># if there is airwall in visited</span>
            <span class="c1">#</span>

            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c1"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c1"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c1"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c1"># if child is the target point</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="c1"># output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c1"># else visit other node</span>
                    <span class="c1"># only visit output nodes except if bt</span>
                    <span class="c1">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c1">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="c1"># check if child (current segment) is an airwall</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span></div>

<div class="viewcode-block" id="Signatures.propaths3"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths3.html#pylayers.antprop.signature.Signatures.propaths3">[docs]</a>    <span class="k">def</span> <span class="nf">propaths3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek shortest path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Gi : graph of interactions</span>
<span class="sd">        source : source interaction</span>
<span class="sd">        target : target interaction</span>
<span class="sd">        cutoff : cutoff</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nextlevel</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="n">Gi</span><span class="p">[</span><span class="n">source</span><span class="p">]}</span>   <span class="c1"># list of nodes to check at next level</span>
        <span class="n">paths</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]}</span>         <span class="c1"># paths dictionary  (paths to key from source)</span>

        <span class="k">while</span> <span class="n">nextlevel</span><span class="p">:</span>
            <span class="n">thislevel</span> <span class="o">=</span> <span class="n">nextlevel</span>
            <span class="n">nextlevel</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="c1"># reach a node which is not in paths</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                        <span class="n">nextlevel</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                        <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">cutoff</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">):</span>  <span class="k">break</span></div>


<div class="viewcode-block" id="Signatures.propaths2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths2.html#pylayers.antprop.signature.Signatures.propaths2">[docs]</a>    <span class="k">def</span> <span class="nf">propaths2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dout : dictionnary</span>
<span class="sd">            key : int</span>
<span class="sd">               number of interactions</span>
<span class="sd">            values : list</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;source :&quot;,source</span>
        <span class="c1">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>


        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c1"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c1"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># while the list of iterators is not void</span>
        <span class="c1"># import ipdb</span>
        <span class="c1"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
            <span class="c1"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># next child</span>

            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c1"># update number of useful segments</span>
            <span class="c1"># if there is airwall in visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c1"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c1"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c1"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c1"># if child is the target point</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="c1">#yield visited + [target] # output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c1"># else visit other node</span>
                    <span class="c1"># only visit output nodes except if bt</span>
                    <span class="c1">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c1">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="c1"># check if child (current segment) is an airwall</span>
                    <span class="c1"># warning not efficient if many airwalls</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c1">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="c1">#yield visited + [target]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">dout</span></div>



    <span class="c1"># def propaths2015(self,G, source, target,dout={}, cutoff=1):</span>
    <span class="c1">#     &quot;&quot;&quot; seek all simple_path from source to target</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>

    <span class="c1">#     G : networkx Graph Gi</span>
    <span class="c1">#     dout : dictionnary</span>
    <span class="c1">#         ouput dictionnary</span>
    <span class="c1">#     source : tuple</span>
    <span class="c1">#         interaction (node of Gi)</span>
    <span class="c1">#     target : tuple</span>
    <span class="c1">#         interaction (node of Gi)</span>
    <span class="c1">#     cutoff : int</span>
    <span class="c1">#     bt : bool</span>
    <span class="c1">#         allow backtrace (visite nodes already visited)</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>

    <span class="c1">#     dout : dictionnary</span>
    <span class="c1">#         key : int</span>
    <span class="c1">#            number of interactions</span>
    <span class="c1">#         values : list of numpy array</span>



    <span class="c1">#     Notes</span>
    <span class="c1">#     -----</span>

    <span class="c1">#     adapted from all_simple_path of networkx</span>

    <span class="c1">#     1- Determine all nodes connected to Gi</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     #print &quot;source :&quot;,source</span>
    <span class="c1">#     #print &quot;target :&quot;,target</span>

    <span class="c1">#     if cutoff &lt; 1:</span>
    <span class="c1">#         return</span>


    <span class="c1">#     visited = [source]</span>
    <span class="c1">#     # stack is a list of iterators</span>
    <span class="c1">#     stack = [iter(G[source])]</span>
    <span class="c1">#     # lawp = list of airwall position in visited</span>
    <span class="c1">#     lawp = []</span>

    <span class="c1">#     # while the list of iterators is not void</span>
    <span class="c1">#     # import ipdb</span>
    <span class="c1">#     # ipdb.set_trace()</span>
    <span class="c1">#     while stack: #</span>
    <span class="c1">#         # children is the last iterator of stack</span>

    <span class="c1">#         children = stack[-1]</span>
    <span class="c1">#         # next child</span>

    <span class="c1">#         child = next(children, None)</span>

    <span class="c1">#         # update number of useful segments</span>
    <span class="c1">#         # if there is airwall in visited</span>
    <span class="c1">#         if child is None  : # if no more child</span>
    <span class="c1">#             stack.pop()   # remove last iterator</span>
    <span class="c1">#             visited.pop() # remove from visited list</span>
    <span class="c1">#             try:</span>
    <span class="c1">#                 lawp.pop()</span>
    <span class="c1">#             except:</span>
    <span class="c1">#                 pass</span>

    <span class="c1">#         elif (len(visited) &lt; (cutoff + sum(lawp))):# if visited list length is less than cutoff</span>
    <span class="c1">#             if child == target:  # if child is the target point</span>
    <span class="c1">#                 #print visited + [target]</span>
    <span class="c1">#                 path = visited + [target]</span>

    <span class="c1">#                 try:</span>
    <span class="c1">#                     dout[len(path)][0]=np.vstack((dout[len(path)][0],np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)))</span>
    <span class="c1">#                 except:</span>
    <span class="c1">#                     dout[len(path)]=[np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)]</span>

    <span class="c1">#                 #yield visited + [target] # output signature</span>

    <span class="c1">#             elif (child not in visited): # else visit other node</span>
    <span class="c1">#                 # only visit output nodes except if bt</span>
    <span class="c1">#                 #pdb.set_trace()</span>
    <span class="c1">#                 try:</span>
    <span class="c1">#                     dintpro = G[visited[-1]][child][&#39;output&#39;]</span>
    <span class="c1">#                 except:</span>
    <span class="c1">#                     dintpro ={}</span>
    <span class="c1">#                 stack.append(iter(dintpro.keys()))</span>
    <span class="c1">#                 #stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
    <span class="c1">#                 visited.append(child)</span>
    <span class="c1">#                 if child[0] in self.L.name[&#39;AIR&#39;]:</span>
    <span class="c1">#                     lawp.append(1)</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     lawp.append(0)</span>




    <span class="c1">#         else: #len(visited) == cutoff (visited list is too long)</span>
    <span class="c1">#             if child == target or target in children:</span>
    <span class="c1">#                 path = visited + [target]</span>

    <span class="c1">#                 try:</span>
    <span class="c1">#                     dout[len(path)][0]=np.vstack((dout[len(path)][0],np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)))</span>
    <span class="c1">#                 except:</span>
    <span class="c1">#                     dout[len(path)]=[np.array([[p[0],len(p)] for p in path],ndmin=3,dtype=&#39;uint16&#39;)]</span>

    <span class="c1">#                 #print visited + [target]</span>
    <span class="c1">#                 #yield visited + [target]</span>

    <span class="c1">#             stack.pop()</span>
    <span class="c1">#             visited.pop()</span>
    <span class="c1">#             try:</span>
    <span class="c1">#                 lawp.pop()</span>
    <span class="c1">#             except:</span>
    <span class="c1">#                 pass</span>
    <span class="c1">#     return dout</span>


<div class="viewcode-block" id="Signatures.propaths2015_2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths2015_2.html#pylayers.antprop.signature.Signatures.propaths2015_2">[docs]</a>    <span class="k">def</span> <span class="nf">propaths2015_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span><span class="n">M</span><span class="o">=</span><span class="p">{},</span><span class="n">Mmap</span><span class="o">=</span><span class="p">[],</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dout : dictionnary</span>
<span class="sd">            key : int</span>
<span class="sd">               number of interactions</span>
<span class="sd">            values : list of numpy array</span>



<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;source :&quot;,source</span>
        <span class="c1">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>


        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c1"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c1"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># while the list of iterators is not void</span>
        <span class="c1"># import ipdb</span>
        <span class="c1"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
            <span class="c1"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># next child</span>

            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c1"># update number of useful segments</span>
            <span class="c1"># if there is airwall in visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c1"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c1"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>


            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c1"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c1"># if child is the target point</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="c1"># M = np.zeros((1,NGs),dtype=&#39;bool&#39;)</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

                    <span class="k">if</span> <span class="n">Mmap</span> <span class="o">!=</span><span class="p">[]:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">out</span><span class="p">]]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">out</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)))</span>
                        <span class="c1"># dnvi[len(path)].append([[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()])</span>
                        <span class="c1"># out = [i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]</span>
                        <span class="c1"># M[path[-2][0],path[-1][0],out]=True</span>
                        <span class="c1"># dnvi[len(path)]=np.vstack((dnvi[len(path)],M))</span>

                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
                        <span class="c1"># dnvi[len(path)]=[[[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]</span>
                        <span class="c1"># dnvi[len(path)]=M</span>

                    <span class="c1">#yield visited + [target] # output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">):</span> <span class="c1"># else visit other node</span>
                    <span class="c1"># only visit output nodes except if bt</span>
                    <span class="c1">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c1">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff (visited list is too long)</span>
                <span class="c1"># if child == (56, 8, 14):</span>
                <span class="c1">#     import ipdb</span>
                <span class="c1">#     ipdb.set_trace()</span>
                <span class="c1"># print list(children)</span>
                <span class="c1"># print ((child == target) or (target in children))</span>

                <span class="n">CC</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">target</span> <span class="ow">in</span> <span class="n">CC</span><span class="p">)):</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>

                    <span class="c1"># M = np.zeros((1,NGs),dtype=&#39;bool&#39;)</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                    <span class="k">if</span> <span class="n">Mmap</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="n">Mmap</span><span class="p">[</span><span class="n">out</span><span class="p">]]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">M</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">out</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)))</span>
                        <span class="c1"># dnvi[len(path)].append([[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()])</span>
                        <span class="c1"># dnvi[len(path)].append(np.unique([i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]))</span>
                        <span class="c1"># M[:,[i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]=True</span>
                        <span class="c1"># dnvi[len(path)]=np.vstack((dnvi[len(path)],M))</span>

                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
                        <span class="c1"># dnvi[len(path)]=[[[i[0],len(i)] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]</span>
                        <span class="c1"># dnvi[len(path)]=[np.unique([i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()])]</span>
                        <span class="c1"># M[:,[i[0] for i in G[visited[-1]][child][&#39;output&#39;].keys()]]=True</span>
                        <span class="c1"># dnvi[len(path)]=M</span>

                    <span class="c1">#print visited + [target]</span>
                    <span class="c1">#yield visited + [target]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">dout</span></div>

<div class="viewcode-block" id="Signatures.procone2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.procone2.html#pylayers.antprop.signature.Signatures.procone2">[docs]</a>    <span class="k">def</span> <span class="nf">procone2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target looking backward</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print &quot;source :&quot;,source</span>
        <span class="c1">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="c1"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="c1"># while the list of iterators is not void</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
            <span class="c1"># children is the last iterator of stack</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c1">#print &quot;child : &quot;,child</span>
            <span class="c1">#print &quot;visited :&quot;,visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c1"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c1"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># remove from visited list</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span> <span class="c1"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c1"># if child is the target point - YIELD A SIGNATURE</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="c1">#yield visited + [target] # output signature</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                <span class="c1">#elif child not in visited: # else visit other node - CONTINUE APPEND CHILD</span>
                    <span class="c1"># getting signature until last point</span>
                    <span class="n">diff</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span>
                    <span class="c1"># looking backward with a cone</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># warning visited is also appended visited[-2] is the</span>
                        <span class="c1"># last node</span>
                        <span class="n">brin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">evf</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                        <span class="n">ta</span><span class="p">,</span><span class="n">he</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
                        <span class="n">segchild</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">segvm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">segchild</span><span class="p">,</span><span class="n">segvm1</span><span class="p">)</span>
                        <span class="n">typ</span><span class="p">,</span><span class="n">proba</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">ta</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">proba</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c1"># child no valid (do nothing)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># child valid (append child to visited and go forward)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c1">#print visited + [target]</span>
                    <span class="c1">#yield visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dout</span></div>

    <span class="c1"># def propaths(self,G, source, target, cutoff=1, cutprob =0.5):</span>
    <span class="c1">#     &quot;&quot;&quot; seek all simple_path from source to target</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>

    <span class="c1">#     G : networkx Graph Gi</span>
    <span class="c1">#     source : tuple</span>
    <span class="c1">#         interaction (node of Gi)</span>
    <span class="c1">#     target : tuple</span>
    <span class="c1">#         interaction (node of Gi)</span>
    <span class="c1">#     cutoff : int</span>

    <span class="c1">#     Notes</span>
    <span class="c1">#     -----</span>

    <span class="c1">#     adapted from all_simple_path of networkx</span>

    <span class="c1">#     1- Determine all nodes connected to Gi</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     #print &quot;source :&quot;,source</span>
    <span class="c1">#     #print &quot;target :&quot;,target</span>

    <span class="c1">#     if cutoff &lt; 1:</span>
    <span class="c1">#         return</span>

    <span class="c1">#     visited = [source]</span>
    <span class="c1">#     # stack is a list of iterators</span>
    <span class="c1">#     stack = [iter(G[source])]</span>
    <span class="c1">#     ps = [iter([1.0]*len((G[source])))]</span>
    <span class="c1">#     # lawp = list of airwall position in visited</span>
    <span class="c1">#     lawp = []</span>

    <span class="c1">#     # while the list of iterators is not void</span>
    <span class="c1">#     # import ipdb</span>
    <span class="c1">#     # ipdb.set_trace()</span>
    <span class="c1">#     while stack: #</span>
    <span class="c1">#         # children is the last iterator of stack</span>

    <span class="c1">#         children = stack[-1]</span>
    <span class="c1">#         pcd = ps[-1]</span>
    <span class="c1">#         # next child</span>
    <span class="c1">#         child = next(children, None)</span>
    <span class="c1">#         pc = next(pcd,None)</span>
    <span class="c1">#         # update number of useful segments</span>
    <span class="c1">#         # if there is airwall in visited</span>
    <span class="c1">#         #</span>

    <span class="c1">#         if child is None  : # if no more child</span>
    <span class="c1">#             stack.pop()   # remove last iterator</span>
    <span class="c1">#             ps.pop()</span>
    <span class="c1">#             visited.pop() # remove from visited list</span>
    <span class="c1">#             try:</span>
    <span class="c1">#                 lawp.pop()</span>
    <span class="c1">#             except:</span>
    <span class="c1">#                 pass</span>

    <span class="c1">#         elif (pc&gt;cutprob): # check proba</span>
    <span class="c1">#             if (len(visited) &lt; (cutoff + sum(lawp))):# if visited list length is less than cutoff</span>
    <span class="c1">#                 if child == target:  # if child is the target point</span>
    <span class="c1">#                     #print visited + [target]</span>
    <span class="c1">#                     yield visited + [target] # output signature</span>
    <span class="c1">#                 elif child not in visited: # else visit other node</span>
    <span class="c1">#                     # only visit output nodes</span>
    <span class="c1">#                     #pdb.set_trace()</span>
    <span class="c1">#                     try:</span>
    <span class="c1">#                         dintpro = G[visited[-1]][child][&#39;output&#39;]</span>
    <span class="c1">#                     except:</span>
    <span class="c1">#                         dintpro ={}</span>

    <span class="c1">#                     # pnc : probability of next children</span>
    <span class="c1">#                     # pc : proba of current parent</span>
    <span class="c1">#                     # spnc : sum of proba of next children</span>

    <span class="c1">#                     # spnc = sum(dintpro.values())</span>
    <span class="c1">#                     pnc = [(v*pc) for v in dintpro.values()]</span>

    <span class="c1">#                     stack.append(iter(dintpro.keys()))</span>
    <span class="c1">#                     ps.append(iter(pnc))</span>
    <span class="c1">#                     #stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
    <span class="c1">#                     visited.append(child)</span>
    <span class="c1">#                     # check if child (current segment) is an airwall</span>
    <span class="c1">#                     if self.L.di[child][0] in self.L.name[&#39;AIR&#39;]:</span>
    <span class="c1">#                         lawp.append(1)</span>
    <span class="c1">#                     else:</span>
    <span class="c1">#                         lawp.append(0)</span>


    <span class="c1">#             else :</span>
    <span class="c1">#                 stack.pop()</span>
    <span class="c1">#                 ps.pop()</span>
    <span class="c1">#                 visited.pop()</span>
    <span class="c1">#                 lawp.pop()</span>

    <span class="c1">#         else: #len(visited) == cutoff (visited list is too long)</span>
    <span class="c1">#             if child == target or target in children:</span>
    <span class="c1">#                 #print visited + [target]</span>
    <span class="c1">#                 yield visited + [target]</span>

    <span class="c1">#             stack.pop()</span>
    <span class="c1">#             ps.pop()</span>
    <span class="c1">#             visited.pop()</span>
    <span class="c1">#             lawp.pop()</span>

<div class="viewcode-block" id="Signatures.calsig"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.calsig.html#pylayers.antprop.signature.Signatures.calsig">[docs]</a>    <span class="k">def</span> <span class="nf">calsig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="p">{},</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculates signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G   : graph</span>
<span class="sd">        dia : dictionnary of interactions</span>
<span class="sd">        cutoff : integer</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">di</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dia</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;Tx&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s1">&#39;Rx&#39;</span>
        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
<span class="c1">#            pdb.set_trace()</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">lot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
<span class="c1">#                    yield visited + [target]</span>
                <span class="k">elif</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
<span class="c1">#                    yield visited + [target]</span>
                    <span class="n">lot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Signatures.exist"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.exist.html#pylayers.antprop.signature.Signatures.exist">[docs]</a>    <span class="k">def</span> <span class="nf">exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; verifies if seq exists in signatures</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        seq : list or np.array()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span><span class="n">lf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="Signatures.run_exp"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run_exp.html#pylayers.antprop.signature.Signatures.run_exp">[docs]</a>    <span class="k">def</span> <span class="nf">run_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoffbound</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; EXPERIMENTAL</span>
<span class="sd">            Vectorized approach of signature search</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        source: int (-1)</span>
<span class="sd">            source cycle .</span>
<span class="sd">            If =-1 =&gt; self.source used</span>
<span class="sd">        target: int (-1)</span>
<span class="sd">            target cycle .</span>
<span class="sd">            If =-1 =&gt; self.target used</span>
<span class="sd">        cutoff= int (1)</span>
<span class="sd">            max number of interactions per cycle</span>
<span class="sd">            except 1st and last cycle</span>
<span class="sd">        cutoffbound= int (1)</span>
<span class="sd">            max number of interactions in 1st and last cycle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing, fill self</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.simul.link import *</span>
<span class="sd">        &gt;&gt;&gt; L=Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; DL=DLink(L=L)</span>
<span class="sd">        &gt;&gt;&gt; DL.ca=8</span>
<span class="sd">        &gt;&gt;&gt; DL.Cb=13</span>
<span class="sd">        &gt;&gt;&gt; DL.eval(force=[&#39;sig&#39;,&#39;ray&#39;,&#39;Ct&#39;,&#39;H&#39;],alg=2015,si_reverb=3,cutoff=2,ra_vectorized=True)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function makes use of graph Gc. Graph of meged cycles.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s2">&quot;Run 2015&quot;</span>
        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="c1"># list of cycle to reach source -&gt; target. this will be imporve next</span>
        <span class="n">lcil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="n">llcil</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="c1"># G=nx.Graph(self.L.Gt)</span>

        <span class="c1"># G.remove_node(0)</span>
        <span class="c1"># lcil = nx.dijkstra_path(G,source,target)</span>
        <span class="c1"># llcil=len(lcil)</span>

        <span class="c1">#2 determine input signatures for each cycles</span>
        <span class="c1">#di key = [input seg, input room, output seg, output room]</span>
        <span class="n">di</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1"># number of points and seg of layout</span>
        <span class="n">NGs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Ns</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Np</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NGs</span><span class="p">,</span><span class="n">NGs</span><span class="p">,</span><span class="n">NGs</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1">### Find interactions per cycles</span>
        <span class="c1">###</span>
        <span class="k">if</span> <span class="n">llcil</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Signatures.run2015 doesn</span><span class="se">\&#39;</span><span class="s1">t work when source==target&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">icy</span><span class="p">,</span><span class="n">cy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lcil</span><span class="p">):</span>

            <span class="n">vinT</span><span class="o">=</span><span class="p">[]</span>
            <span class="c1">#valid &#39;out&#39; interatcion</span>
            <span class="n">voutT</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;merged&#39;</span><span class="p">):</span>
                <span class="n">cym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gc</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cym</span><span class="p">][</span><span class="s1">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
                <span class="p">[</span><span class="n">inter</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;inter&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="n">cy</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span>
            <span class="n">sGi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">inter</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">icy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># the interactions of 1st cycle are kept appart</span>
                <span class="c1"># di0 = {}</span>

                <span class="n">outR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">outD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                <span class="n">vinT</span> <span class="o">=</span> <span class="n">outR</span> <span class="o">+</span> <span class="n">outD</span>

                <span class="n">kdi0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">voutT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">voutT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">voutT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

                <span class="c1">#for each reverb/diffract interaction,</span>
                <span class="c1"># inside 1st cycle, search the output interactions</span>
                
                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">voutT</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vinT</span><span class="p">:</span>
                        <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>


                    <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                    <span class="c1"># add direct signature</span>
                    <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&lt;</span><span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

                <span class="c1">#valid &#39;in&#39; interatcion</span>

                <span class="c1"># select input signatures in regard of selected</span>
                <span class="n">inR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">inD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>
                <span class="n">outR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">outD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>


                <span class="c1"># keep only interactions in identified interesting cycles</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>

                <span class="c1"># for each (identified interesting ) input interactions of the cycle</span>
                <span class="c1">#find all path to each (identified interesting) output interactions</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vinT</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">voutT</span><span class="p">:</span>
                        <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                            <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                            <span class="c1"># dni[i[0],i[1],i[2],o[0],o[1],o[2]] = ino</span>

            <span class="c1"># the interactions of last cycle are kept appart</span>
            <span class="k">elif</span> <span class="n">icy</span> <span class="o">==</span> <span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="n">inR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">inD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">fcy</span><span class="p">)</span>
                <span class="n">voutT</span> <span class="o">=</span> <span class="n">inR</span> <span class="o">+</span> <span class="n">inD</span>
                <span class="n">kdif</span> <span class="o">=</span> <span class="p">(</span><span class="n">vinT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">vinT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">vinT</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#keep trace of last segments</span>
                <span class="n">sinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vinT</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vinT</span><span class="p">))])</span>
                <span class="c1"># for each (identified interesting ) input interactions,</span>
                <span class="c1">#find path to each reverb/diffract interaction of last cycle</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vinT</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">voutT</span><span class="p">:</span>
                        <span class="n">io</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                    <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
                    <span class="c1"># add direct signature</span>
                    <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

                <span class="c1"># dni[i[0],i[1],i[2],0,0,0] = ino</span>


        <span class="c1">#dictionnary of interactions id keys</span>
        <span class="c1"># interaction id key are build as tuple Transmission inter in ,</span>
        <span class="c1"># Transmission interaction id input ,  Transmission interaction id output</span>
        <span class="c1"># e.g. (34, 13, 12, 36, 12, 11).</span>
        <span class="c1">#(0,0,0,X,X,X) stands for all interactions from the source</span>
        <span class="c1">#(X,X,X,0,0,0) stands for all interactions from the target</span>
        <span class="n">kdi</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># Create 2 arrays with</span>
        <span class="c1"># input and output interactions id respectively</span>
        <span class="n">adi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdi0</span><span class="p">)</span>
        <span class="n">adif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kdif</span><span class="p">)</span>
        <span class="n">adi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">adii</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">adio</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">lsig</span><span class="o">=</span><span class="p">{}</span>

        <span class="c1">#initialize loop on the 1st interaction id(0,0,0,X,X,X)</span>

        <span class="c1"># uinit = np.unique(np.where(adi[:,:3]==0)[0])</span>
        <span class="n">uinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">oldout</span><span class="o">=</span><span class="n">uinit</span>
        <span class="n">stop</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">dsigiosave</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">dsigiosave</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]:</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uinit</span><span class="p">})</span>

        <span class="k">def</span> <span class="nf">filldinda</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d0</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kd1</span><span class="p">):</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">],</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span>

        <span class="n">firstloop</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>

            <span class="c1"># for all detected valid output</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldout</span><span class="p">:</span>

                <span class="n">us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">adii</span><span class="o">-</span><span class="n">adio</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">keep</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">iuus</span><span class="p">,</span><span class="n">uus</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="p">:</span>
                    <span class="n">bue</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span><span class="o">==</span><span class="n">adi</span><span class="p">[</span><span class="n">out</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span>
                    <span class="n">ue</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bue</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ue</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iuus</span><span class="p">)</span>
                <span class="n">us</span> <span class="o">=</span> <span class="n">us</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

                <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="c1">#     print ue</span>
                <span class="c1">#     if len(ue) == 0:</span>
                <span class="c1">#         keep.append(ue)</span>
                <span class="c1">#</span>
                <span class="c1">#     else:</span>
                <span class="c1">#         pass</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
                <span class="c1"># us=us[keep]</span>
                <span class="k">for</span> <span class="n">uus</span> <span class="ow">in</span> <span class="n">us</span><span class="p">:</span>
                    <span class="c1">#1st input interactions to all identified a outputs</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lsig</span><span class="o">=</span><span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:]]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">lsig</span> <span class="o">=</span> <span class="n">dsigiosave</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:]]</span>
                    <span class="c1"># lni=dni[kdi[k]]</span>
                    <span class="n">sigio</span><span class="o">=</span><span class="p">{}</span>
                    <span class="c1"># loop on input interactions</span>
                    <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">lsig</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c1">#loop on output interactions</span>
                        <span class="k">for</span> <span class="n">ko</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                            <span class="c1"># remove impossible signature in terms of cones</span>
                            <span class="n">lin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
                            <span class="n">lout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">])</span>
                            <span class="c1"># manage case 1st interaction with no previous</span>

                            <span class="k">if</span> <span class="n">ki</span> <span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ko</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">uso</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">uout</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][:,</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],:][:,</span><span class="n">uout</span><span class="p">]</span>

                                <span class="n">suvi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uvi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">lin</span><span class="p">,</span><span class="n">lout</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
                                <span class="n">suvi</span> <span class="o">=</span> <span class="n">lin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lout</span><span class="p">)</span>

                            <span class="k">for</span> <span class="n">uv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lout</span><span class="p">):</span>
                                <span class="n">ri</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">uvi</span><span class="p">[:,</span><span class="n">uv</span><span class="p">]]</span>
                                <span class="n">ro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][</span><span class="n">uv</span><span class="p">],(</span><span class="n">suvi</span><span class="p">[</span><span class="n">uv</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

                                <span class="c1"># ri = np.repeat(lsig[ki][uvi[:,uv]],suvi[uv],axis=0)</span>
                                <span class="c1"># ro = np.tile(di[kdi[uus]][ko],(lin,1,1))</span>

                                <span class="c1"># uvi=uvi.reshape(lin*lout,order=&#39;F&#39;)</span>

                                <span class="c1"># ri=ri[uvi]</span>
                                <span class="c1"># ro=ro[uvi]</span>

                                <span class="n">asig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ri</span><span class="p">,</span><span class="n">ro</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]))</span>

                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">asig</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">asig</span>

                            <span class="c1"># ri = np.repeat(lsig[ki],lout,axis=0)</span>
                            <span class="c1"># ro = np.tile(di[kdi[uus]][ko],(lin,1,1))</span>

                            <span class="c1"># uvi=uvi.reshape(lin*lout,order=&#39;F&#39;)</span>

                            <span class="c1"># ri=ri[uvi]</span>
                            <span class="c1"># ro=ro[uvi]</span>

                            <span class="c1"># asig=np.hstack((ri,ro[:,1:]))</span>

                            <span class="c1"># try:</span>
                            <span class="c1">#     sigio[ki+ko-1]=np.vstack((sigio[ki+ko-1],asig))</span>
                            <span class="c1"># except:</span>
                            <span class="c1">#     sigio[ki+ko-1]=asig</span>
                    <span class="c1"># key is the output segment</span>
                    <span class="k">if</span> <span class="n">dsigio</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]):</span>
                        <span class="n">filldinda</span><span class="p">(</span><span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]],</span><span class="n">sigio</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]]</span><span class="o">=</span><span class="n">sigio</span>

            <span class="n">dsigiosave</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dsigio</span><span class="p">)</span>
            <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">firstloop</span><span class="o">=</span><span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">adi</span><span class="p">[</span><span class="n">out</span><span class="p">][:,</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">stop</span><span class="o">=</span><span class="bp">True</span>
                    <span class="k">break</span>

            <span class="n">oldout</span><span class="o">=</span><span class="n">out</span>
            <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span>



            <span class="c1"># # attempt to limit the combinatory</span>
            <span class="n">survive1</span><span class="o">=</span><span class="n">adi</span><span class="p">[</span><span class="n">oldout</span><span class="p">][:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">survive2</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[</span><span class="n">oldout</span><span class="p">][:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># survive2 = np.ones((len(oldout)),dtype=bool)</span>
            <span class="n">survive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">survive1</span><span class="o">&amp;</span><span class="n">survive2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">oldout</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">oldout</span><span class="p">)[</span><span class="n">survive</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>




        <span class="n">sig</span><span class="o">=</span><span class="n">dsigiosave</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="c1">#reshaping to be compliant with signatures format</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">}</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig2</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sig2</span><span class="p">)</span>
        <span class="c1">#for debug</span>
        <span class="k">return</span> <span class="n">sig2</span></div>


<div class="viewcode-block" id="Signatures.run_exp2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run_exp2.html#pylayers.antprop.signature.Signatures.run_exp2">[docs]</a>    <span class="k">def</span> <span class="nf">run_exp2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">target</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cutoffbound</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; EXPERIMENTAL</span>
<span class="sd">            Vectorized approach of signature search</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        source: int (-1)</span>
<span class="sd">            source cycle .</span>
<span class="sd">            If =-1 =&gt; self.source used</span>
<span class="sd">        target: int (-1)</span>
<span class="sd">            target cycle .</span>
<span class="sd">            If =-1 =&gt; self.target used</span>
<span class="sd">        cutoff= int (1)</span>
<span class="sd">            max number of interactions per cycle</span>
<span class="sd">            except 1st and last cycle</span>
<span class="sd">        cutoffbound= int (1)</span>
<span class="sd">            max number of interactions in 1st and last cycle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Nothing, fill self</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.simul.link import *</span>
<span class="sd">        &gt;&gt;&gt; L=Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; DL=DLink(L=L)</span>
<span class="sd">        &gt;&gt;&gt; DL.ca=8</span>
<span class="sd">        &gt;&gt;&gt; DL.Cb=13</span>
<span class="sd">        &gt;&gt;&gt; DL.eval(force=[&#39;sig&#39;,&#39;ray&#39;,&#39;Ct&#39;,&#39;H&#39;],alg=2015,si_reverb=3,cutoff=2,ra_vectorized=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">print</span> <span class="s2">&quot;run2015_2&quot;</span>
        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Signatures.run2015 doesn</span><span class="se">\&#39;</span><span class="s1">t work when source==target&#39;</span><span class="p">)</span>
        <span class="c1"># # approach 1</span>
        <span class="c1"># # list of cycle to reach source -&gt; target. this will be imporve next</span>
        <span class="n">lcil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">)</span>
        <span class="n">llcil</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="c1"># #approach 2</span>
        <span class="c1"># #2.1- make a shortest path from source to target cycles</span>
        <span class="c1"># G=nx.Graph(self.L.Gt)</span>
        <span class="c1"># G.remove_node(0)</span>
        <span class="c1"># lcil = nx.dijkstra_path(G,source,target)</span>
        <span class="c1"># llcil=len(lcil)</span>
        <span class="c1"># nlcil=[]</span>
        <span class="c1"># # 2.2- for all cycle in the shortest path, find cycle intersected</span>
        <span class="c1"># for ll in range(llcil-1) :</span>
        <span class="c1">#     nlcil.extend(self.L.cycleinline(lcil[ll],lcil[ll+1])[:-1])</span>
        <span class="c1"># #add target exclued in the loop above</span>
        <span class="c1"># nlcil.extend([target])</span>
        <span class="c1"># lcil = nlcil</span>
        <span class="n">llcil</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="c1">#2 determine input signatures for each cycles</span>
        <span class="c1">#di key = [input seg, input room, output seg, output room]</span>
        <span class="n">di</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1"># number of points and seg of layout</span>
        <span class="n">allpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span> <span class="p">))</span>
        <span class="c1">#mapping segemnts</span>
        <span class="n">segmapp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span>
        <span class="c1"># mapping diffraction</span>
        <span class="n">diffmapp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
        <span class="n">diffmapp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ldiffin</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Ns</span><span class="o">+</span><span class="mi">1</span>
        <span class="c1"># common mapping diff and segments</span>
        <span class="n">mapp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">segmapp</span><span class="p">,</span><span class="n">diffmapp</span><span class="p">))</span>
        <span class="n">lapt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">allpt</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lapt</span><span class="p">,</span><span class="n">lapt</span><span class="p">,</span><span class="n">lapt</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

        <span class="c1">###</span>
        <span class="c1">### Find interactions per cycles</span>
        <span class="c1">###</span>

        <span class="k">def</span> <span class="nf">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Difraction In Diffraction Out</span>
<span class="sd">                determine, for merged cycles, which diffrxtion</span>
<span class="sd">                points get out / in of a cycle</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">                cy : integer</span>
<span class="sd">                    cycle to investigate</span>
<span class="sd">                lcy : list</span>
<span class="sd">                    list of original cycles before merge ( in Gc)</span>

<span class="sd">            Return</span>
<span class="sd">            ------</span>
<span class="sd">                insideD: listr of diffraction inside cy</span>
<span class="sd">                inD: list of diffraction points in going in cy</span>
<span class="sd">                outD: list of diffraction points out going from cy</span>
<span class="sd">                ddin : a dcitionnary for naming ingoing diff poitns (points,cy in , cy out)</span>
<span class="sd">                dd : a dcitionnary for naming outgoing diff poitns (points,cy in , cy out)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lcy</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                <span class="n">lcy</span><span class="o">=</span><span class="p">[</span><span class="n">lcy</span><span class="p">]</span>
            <span class="n">outR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>
            <span class="c1"># keep diff points</span>
            <span class="n">D</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">ddin</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">ddout</span><span class="o">=</span><span class="p">{}</span>
            <span class="c1">#outgoing diffraction</span>
            <span class="n">outD</span><span class="o">=</span><span class="p">[]</span>
            <span class="c1">#ingoing diffraction</span>
            <span class="n">inD</span><span class="o">=</span><span class="p">[]</span>
            <span class="c1"># inside cycle diffraction</span>
            <span class="n">insideD</span><span class="o">=</span><span class="p">[]</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                <span class="c1"># get cycles involved in diff point d</span>
                <span class="n">dcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">ptGs2cy</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="c1"># keep only current cycle and its merged neighbords in Gc</span>
                <span class="n">dcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">,</span><span class="n">dcy</span><span class="p">)</span>
                <span class="c1">#remove the current cycle</span>
                <span class="n">dcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">cy</span><span class="p">,</span><span class="n">dcy</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span> <span class="p">(</span><span class="n">dcy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">outD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>
                    <span class="n">inD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>
                    <span class="k">for</span> <span class="n">ud</span> <span class="ow">in</span> <span class="n">dcy</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ddout</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">ud</span><span class="p">))</span>
                            <span class="n">ddin</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">ud</span><span class="p">,</span><span class="n">cy</span><span class="p">))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">ddout</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">=</span><span class="p">[(</span><span class="n">d</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">ud</span><span class="p">)]</span>
                            <span class="n">ddin</span><span class="p">[(</span><span class="n">d</span><span class="p">,)]</span><span class="o">=</span><span class="p">[(</span><span class="n">d</span><span class="p">,</span><span class="n">ud</span><span class="p">,</span><span class="n">cy</span><span class="p">)]</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">insideD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span>
        <span class="c1">#####END dido</span>

        <span class="k">for</span> <span class="n">icy</span><span class="p">,</span><span class="n">cy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lcil</span><span class="p">):</span>

            <span class="n">vinT</span><span class="o">=</span><span class="p">[]</span>
            <span class="c1">#valid &#39;out&#39; interatcion</span>
            <span class="n">voutT</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;merged&#39;</span><span class="p">):</span>
                <span class="n">cym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gc</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cym</span><span class="p">][</span><span class="s1">&#39;merged&#39;</span><span class="p">]</span>
                <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
                <span class="p">[</span><span class="n">inter</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;inter&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lcy</span> <span class="o">=</span> <span class="n">cy</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span>
            <span class="n">sGi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">inter</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">icy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># the interactions of 1st cycle are kept appart</span>
                <span class="c1"># di0 = {}</span>

                <span class="n">insideR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span><span class="o">=</span><span class="n">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">)</span>


                <span class="c1">#outgoing inter</span>
                <span class="n">vout</span><span class="o">=</span><span class="n">voutT</span><span class="o">+</span><span class="n">outD</span>
                <span class="c1">#inside inter</span>
                <span class="n">insideRD</span> <span class="o">=</span> <span class="n">insideR</span> <span class="o">+</span> <span class="n">insideD</span>
                <span class="c1">#for each reverb/diffract interaction,</span>
                <span class="c1"># inside 1st cycle, search the output interactions</span>

                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">vout</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">insideRD</span><span class="p">:</span>
                        <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                        <span class="c1"># add direct signature</span>
                        <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="k">for</span> <span class="n">oo</span> <span class="ow">in</span> <span class="n">ddout</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                            <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                            <span class="n">di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">icy</span> <span class="o">&lt;</span><span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

                <span class="c1">#valid &#39;in&#39; interatcion</span>

                <span class="c1"># select input signatures in regard of selected</span>
                <span class="n">insideR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>
                <span class="n">insideR</span><span class="p">,</span><span class="n">outT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>

                <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span><span class="o">=</span><span class="n">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">)</span>


                <span class="c1"># keep only interactions in identified interesting cycles</span>
                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">outT</span><span class="p">)</span>
                    <span class="n">voutT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcy</span><span class="p">)</span>

                <span class="c1">#forbiden interactions</span>

                <span class="n">dfi</span><span class="o">=</span><span class="p">{}</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">inD</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dfi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dfi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

                <span class="c1">#incoming Transmission and diffraction</span>
                <span class="n">vin</span> <span class="o">=</span> <span class="n">vinT</span> <span class="o">+</span> <span class="n">inD</span>
                <span class="c1">#outgoing Transmission and diffraction</span>
                <span class="n">vout</span> <span class="o">=</span> <span class="n">voutT</span> <span class="o">+</span> <span class="n">outD</span>
                <span class="c1"># for each (identified interesting ) input interactions of the cycle</span>
                <span class="c1">#find all path to each (identified interesting) output interactions</span>
                
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vin</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">vout</span><span class="p">:</span>
                        <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                        <span class="c1"># no difraction</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># no backward</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">!=</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">!=</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">io</span>
                        <span class="c1"># input diffraction</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dfi</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ddin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                    <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">o</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                        <span class="c1"># output diffraction</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dfi</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                                <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">oo</span> <span class="ow">in</span> <span class="n">ddout</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                                    <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                        <span class="c1"># input and output diffraction</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">!=</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">:</span>
                                <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ddin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                    <span class="k">for</span> <span class="n">oo</span> <span class="ow">in</span> <span class="n">ddout</span><span class="p">[</span><span class="n">o</span><span class="p">]:</span>
                                        <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">oo</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">io</span>
                                <span class="c1"># dni[i[0],i[1],i[2],o[0],o[1],o[2]] = ino</span>

            <span class="c1"># the interactions of last cycle are kept appart</span>
            <span class="k">elif</span> <span class="n">icy</span> <span class="o">==</span> <span class="n">llcil</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="n">insideR</span><span class="p">,</span><span class="n">inT</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercyGc2Gt</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>
                
                <span class="n">insideD</span><span class="p">,</span><span class="n">inD</span><span class="p">,</span><span class="n">outD</span><span class="p">,</span><span class="n">ddin</span><span class="p">,</span><span class="n">ddout</span><span class="o">=</span><span class="n">dido</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span><span class="n">lcy</span><span class="p">)</span>


                <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
                    <span class="c1"># fcy = filter(lambda x: (cycle == x[2]) and (x[1] in lcil),inT)</span>
                    <span class="n">fcy</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cycle</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">inT</span><span class="p">)</span>
                    <span class="n">vinT</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">fcy</span><span class="p">)</span>


                <span class="n">insideRD</span> <span class="o">=</span> <span class="n">insideR</span> <span class="o">+</span> <span class="n">insideD</span>
                <span class="n">vin</span> <span class="o">=</span> <span class="n">vinT</span> <span class="o">+</span> <span class="n">inD</span>

                <span class="c1"># for each (identified interesting ) input interactions,</span>
                <span class="c1">#find path to each reverb/diffract interaction of last cycle</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vin</span><span class="p">:</span>
                    <span class="n">io</span><span class="o">=</span><span class="p">{}</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">insideRD</span><span class="p">:</span>
                            <span class="n">io</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                        <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
                        <span class="c1"># add direct signature</span>
                        <span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">else</span> <span class="p">:</span> 
                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">insideRD</span><span class="p">:</span>
                            <span class="n">io</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths2015_2</span><span class="p">(</span><span class="n">sGi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">o</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">io</span><span class="p">,</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span><span class="n">Mmap</span><span class="o">=</span><span class="n">mapp</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoffbound</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ddin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
                            <span class="c1"># add direct signature</span>
                            <span class="n">di</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ii</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="n">ndmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="c1"># dni[i[0],i[1],i[2],0,0,0] = ino</span>

        <span class="c1">#dictionnary of interactions id keys</span>
        <span class="c1"># interaction id key are build as tuple Transmission inter in ,</span>
        <span class="c1"># Transmission interaction id input ,  Transmission interaction id output</span>
        <span class="c1"># e.g. (34, 13, 12, 36, 12, 11).</span>
        <span class="c1">#(0,0,0,X,X,X) stands for all interactions from the source</span>
        <span class="c1">#(X,X,X,0,0,0) stands for all interactions from the target</span>
        <span class="n">kdi</span> <span class="o">=</span> <span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># Create 2 arrays with</span>
        <span class="c1"># input and output interactions id respectively</span>
        <span class="n">adi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">adii</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">adio</span> <span class="o">=</span> <span class="n">adi</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">lsig</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1">#initialize loop on the 1st interaction id(0,0,0,X,X,X)</span>
        <span class="c1"># uinit = np.unique(np.where(adi[:,:3]==0)[0])</span>
        <span class="n">uinit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">adi</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">oldout</span><span class="o">=</span><span class="n">uinit</span>
        <span class="n">stop</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">dsigiosave</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">dsigiosave</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]:</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uinit</span><span class="p">})</span>

        <span class="k">def</span> <span class="nf">filldinda</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d0</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kd1</span><span class="p">):</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">],</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">filldinda2</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span><span class="n">d1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d0</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kd1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">kkd1</span> <span class="ow">in</span> <span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kkd1</span><span class="p">):</span>
                            <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">],</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">][</span><span class="n">kkd1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d0</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">kd1</span><span class="p">]</span>

        <span class="n">lastloop</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">outall</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">stop</span><span class="p">:</span>
            <span class="c1"># for all detected valid output</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldout</span><span class="p">:</span>

                <span class="c1">#if not last loop, </span>
                <span class="c1">#find all the output interaction with a given in interaction (adi[k])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                    <span class="n">us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">adii</span><span class="o">-</span><span class="n">adio</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">keep</span><span class="o">=</span><span class="p">[]</span>
                    <span class="c1"># remove output interaction already visited</span>
                    <span class="c1">#for lightned computation</span>
                    <span class="k">for</span> <span class="n">iuus</span><span class="p">,</span><span class="n">uus</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">uus</span> <span class="ow">in</span> <span class="n">outall</span> <span class="p">:</span>
                            <span class="k">if</span> <span class="n">adi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">lastloop</span><span class="p">:</span>
                                <span class="n">keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iuus</span><span class="p">)</span>
                                <span class="n">outall</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uus</span><span class="p">)</span>

                    <span class="n">us</span> <span class="o">=</span> <span class="n">us</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">us</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="c1"># else output interaction is the inner interactions</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">us</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">uus</span> <span class="ow">in</span> <span class="n">us</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                        <span class="n">lsig</span> <span class="o">=</span> <span class="n">dsigiosave</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">:]]</span>
                    <span class="k">else</span> <span class="p">:</span> 
                        <span class="n">lsig</span> <span class="o">=</span> <span class="n">dsigiosave</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="mi">3</span><span class="p">]]</span>
                    <span class="n">sigio</span><span class="o">=</span><span class="p">{}</span>
                    <span class="c1"># loop on input interactions</span>
                    <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">lsig</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c1">#loop on output interactions</span>
                        <span class="k">for</span> <span class="n">ko</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                          <span class="c1"># remove impossible signature in terms of cones</span>
                            <span class="n">lin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">])</span>
                            <span class="n">lout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">])</span>
                            <span class="c1"># manage case 1st interaction with no previous</span>
                            <span class="k">if</span> <span class="n">ki</span> <span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">ko</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">uso</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">uout</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][:,</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span>

                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">mapp</span><span class="p">[</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]],</span><span class="n">mapp</span><span class="p">[</span><span class="n">uso</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],:][:,</span><span class="n">mapp</span><span class="p">[</span><span class="n">uout</span><span class="p">]]</span>
                                <span class="n">suvi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uvi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="n">uvi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">lin</span><span class="p">,</span><span class="n">lout</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
                                <span class="n">suvi</span> <span class="o">=</span> <span class="n">lin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lout</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">uv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lout</span><span class="p">):</span>
                                <span class="n">ri</span> <span class="o">=</span> <span class="n">lsig</span><span class="p">[</span><span class="n">ki</span><span class="p">][</span><span class="n">uvi</span><span class="p">[:,</span><span class="n">uv</span><span class="p">]]</span>
                                <span class="n">ro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">]][</span><span class="n">ko</span><span class="p">][</span><span class="n">uv</span><span class="p">],(</span><span class="n">suvi</span><span class="p">[</span><span class="n">uv</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                                <span class="n">asig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ri</span><span class="p">,</span><span class="n">ro</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]))</span>

                                    <span class="c1"># ri = lsig[ki][uvi[:,uv]]</span>
                                    <span class="c1"># ro = np.tile(di[kdi[uus]][ko][uv],(suvi[uv],1,1))</span>

                                <span class="c1"># ri = np.repeat(lsig[ki][uvi[:,uv]],suvi[uv],axis=0)</span>
                                <span class="c1"># ro = np.tile(di[kdi[uus]][ko],(lin,1,1))</span>

                                <span class="c1"># uvi=uvi.reshape(lin*lout,order=&#39;F&#39;)</span>

                                <span class="c1"># ri=ri[uvi]</span>
                                <span class="c1"># ro=ro[uvi]</span>


                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">asig</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">sigio</span><span class="p">[</span><span class="n">ki</span><span class="o">+</span><span class="n">ko</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">asig</span>

                    <span class="c1"># key is the output segment</span>
                    <span class="k">if</span> <span class="n">dsigio</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]):</span>
                        <span class="n">filldinda</span><span class="p">(</span><span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]],</span><span class="n">sigio</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dsigio</span><span class="p">[</span><span class="n">kdi</span><span class="p">[</span><span class="n">uus</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]]</span><span class="o">=</span><span class="n">sigio</span>

            <span class="n">filldinda2</span><span class="p">(</span><span class="n">dsigiosave</span><span class="p">,</span><span class="n">dsigio</span><span class="p">)</span>
            <span class="n">dsigio</span><span class="o">=</span><span class="p">{}</span>


            <span class="k">if</span> <span class="n">lastloop</span><span class="p">:</span>
                <span class="n">stop</span><span class="o">=</span><span class="bp">True</span>
                <span class="k">break</span>

            <span class="n">oldout</span><span class="o">=</span><span class="n">out</span>
            <span class="n">out</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span>

            <span class="k">if</span> <span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">lcil</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">lastloop</span><span class="o">=</span><span class="bp">True</span>

            <span class="c1">#filtering for avoiding computing extra </span>
            <span class="c1">#interaction in/out couples</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">adi</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">adi</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            <span class="c1"># input cycle interaction must be in the already visited list of cycles (lcil)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">|</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ii</span><span class="p">)</span>
            <span class="c1"># output cycle interaction must be in the remaining list of cycles (lcil)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ii</span><span class="p">)</span>
            <span class="c1"># output cycle interaction must bethe next cycle in  list of cycles (lcil)</span>
            <span class="c1"># or code 0 for inner interaction of last cycle</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span> <span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">|</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ii</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">|</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">&amp;</span> <span class="n">tmp</span>
            <span class="c1">#consider only insteraction from the current cycle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lastloop</span><span class="p">:</span>
                <span class="n">bo</span> <span class="o">=</span> <span class="n">bo</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">adi</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">adi</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="n">lcil</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="n">oldout</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>



        <span class="n">sig</span><span class="o">=</span><span class="n">dsigiosave</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="c1">#reshaping to be compliant with signatures format</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">}</span>
        <span class="n">sig2</span><span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sig2</span><span class="p">)</span>
        <span class="c1">#for debug</span>
        <span class="k">return</span> <span class="n">sig2</span></div>


<div class="viewcode-block" id="Signatures.run_old"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run_old.html#pylayers.antprop.signature.Signatures.run_old">[docs]</a>    <span class="k">def</span> <span class="nf">run_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s1">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s2">&quot;run old&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.sig&#39;</span>

        <span class="c1"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c1"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c1">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c1">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c1">#</span>
        <span class="c1"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c1"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c1"># lis=lis+lit</span>
        <span class="c1"># lit=lis+lit</span>
        <span class="c1">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c1">#for target interaction in list of target interactions</span>
            <span class="c1">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c1">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c1"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s1">&#39;~</span><span class="si">%d</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s1">&#39;</span><span class="si">%6.3f</span><span class="s1"> </span><span class="si">%6.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c1"># if source and target interaction are different</span>
                <span class="c1"># and R | T</span>
                <span class="c1">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s1">&#39;new&#39;</span><span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">procone2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;old&#39;</span> <span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s1">&#39;dij&#39;</span><span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">short_propath</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                        <span class="c1"># dout = self.short_propath(Gi,source=t,target=s,dout=dout,cutoff=cutoff)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dout</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">adout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">shad</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">adout</span><span class="p">)</span>
            <span class="c1"># manage the case of signatures with only 1 interaction</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">adout</span> <span class="o">=</span> <span class="n">adout</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="n">shad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">adout</span><span class="p">)</span>
            <span class="c1"># rehape (rays * 2 , interaction)</span>
            <span class="c1"># the 2 dimensions come from the signature definition :</span>
            <span class="c1"># 1st row = segment index</span>
            <span class="c1"># 2nd row = type of interaction</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">adout</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shad</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">shad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>




    <span class="c1"># @profile                    </span>
    <span class="k">def</span> <span class="nf">run_old1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s2">&quot;run&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.sig&#39;</span>

        <span class="c1"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c1"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c1">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c1">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c1">#</span>
        <span class="c1"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c1"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c1">#for interaction source  in list of source interactions</span>

        <span class="c1"># signature counter</span>
        <span class="n">cptsig</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c1">#for target interaction in list of target interactions</span>
            <span class="c1">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c1">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c1"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s1">&#39;~</span><span class="si">%d</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s1">&#39;</span><span class="si">%6.3f</span><span class="s1"> </span><span class="si">%6.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c1"># if source and target interaction are different</span>
                <span class="c1"># and R | T</span>
                <span class="c1"># if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">tahe</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])]</span>
                <span class="c1"># R is a list which contains reflextion matrices(Sn) and translation matrices(vn)</span>
                <span class="c1"># for mirror</span>
                <span class="c1"># R=[[S0,v0],[S1,v1],...]</span>
                <span class="n">R</span><span class="o">=</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))]</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>

                    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                    <span class="c1"># stack is a list of iterators</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">])]</span>
                    <span class="c1"># lawp = list of airwall position in visited</span>
                    <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># while the list of iterators is not void</span>
                    <span class="c1"># import ipdb</span>
                    <span class="c1"># ipdb.set_trace()</span>
                    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
                        <span class="c1"># children is the last iterator of stack</span>
                        <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        
                        <span class="c1"># next child</span>

                        <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                        <span class="c1"># update number of useful segments</span>
                        <span class="c1"># if there is airwall in visited</span>
                        <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c1"># if no more child</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c1"># remove last iterator</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># remove from visited list</span>
                            <span class="n">tahe</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">R</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>



                        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">)))</span> <span class="p">:</span><span class="c1"># if visited list length is less than cutoff</span>
                            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>  <span class="c1"># if child is the target point</span>
                                <span class="c1">#print visited + [target]</span>
                                <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                                <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="n">cptsig</span> <span class="o">+=</span><span class="mi">1</span>
                                <span class="c1">#print path,cptsig</span>
                                <span class="c1">#print &quot;O&quot;,</span>
                                <span class="c1">#try:</span>
                                <span class="c1">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                                <span class="c1">#except:</span>
                                <span class="c1">#    dout[len(path)]=[]</span>
                                <span class="c1">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                                <span class="c1">#yield visited + [target] # output signature</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c1"># else visit other node</span>
                                <span class="c1"># only visit output nodes except if bt</span>
                                <span class="c1">#pdb.set_trace()</span>
                                
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">nexti</span>  <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                    <span class="c1"># keyprob  = Gi[visited[-1]][child][&#39;output&#39;].items()</span>
                                    <span class="c1"># nexti = map(lambda x:x[0]</span>
                                    <span class="c1">#               ,filter(lambda x</span>
                                    <span class="c1">#                       :x[1]&gt;threshold,keyprob))</span>

                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">nexti</span> <span class="o">=</span> <span class="p">[]</span>


                                <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                                <span class="c1">#print visited</span>

                                <span class="n">seg</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


                                <span class="c1"># Testing the type of interaction at rank -2 </span>
                                <span class="c1"># R is a list which contains a rotation matrix </span>
                                <span class="c1"># and a translation vector for doing the mirroring </span>
                                <span class="c1"># operation</span>

                                <span class="c1">#diff</span>
                               
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span>
                                    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">th</span><span class="p">,</span><span class="n">th</span><span class="p">])</span>
                                    <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>

                                <span class="c1">#refl</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>

                                    <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                    <span class="c1">#th (Npt x xy)</span>
                                    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                                    <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">axmat</span><span class="p">(</span><span class="n">tahe</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">tahe</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
  
                                <span class="c1"># trans</span>
                                <span class="k">else</span> <span class="p">:</span> 
                                    <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                                    <span class="c1"># for uniformity purpose </span>
                                    <span class="c1"># dummy mirroring (no effect)</span>
                                    <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>

                                <span class="c1"># apply symmetry</span>
                                <span class="c1"># th are current segment tail-head coordinates</span>
                                <span class="c1"># tahe is a list of well mirrored tail-head coordinates</span>
                                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">R</span><span class="p">:</span> 
                                    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,ij-&gt;kj&#39;</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">tahe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>

                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
                                    <span class="c1"># import ipdb</span>
                                    <span class="c1"># ipdb.set_trace()    </span>
                                    <span class="n">v</span> <span class="o">=</span> <span class="n">valid</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">tahe</span><span class="p">)</span> 
                                    <span class="c1">#print v</span>
                                <span class="k">else</span><span class="p">:</span> 
                                    <span class="n">v</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="c1"># signature of length 3 are necessarily valid</span>

                                <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nexti</span><span class="p">))</span>
                                

                                    <span class="c1"># import ipdb</span>
                                    <span class="c1"># ipdb.set_trace()</span>


                                    <span class="c1"># check if child (current segment) is an airwall</span>
                                    <span class="c1"># warning not efficient if many airwalls</span>
                                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]:</span>
                                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="c1">#print  &quot;X&quot;,</span>
                                    <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                                    <span class="n">tahe</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                                    <span class="n">R</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                        <span class="k">else</span><span class="p">:</span> <span class="c1">#len(visited) == cutoff (visited list is too long)</span>
                            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                                <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                                <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">cptsig</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="c1">#print path,cptsig</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="c1">#print &quot;non existing : &quot;,len(path)</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="c1">#print visited + [target]</span>
                                <span class="c1">#yield visited + [target]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">pass</span>
                                <span class="c1">#print &quot;Cutoff &quot;,visited</span>
                                <span class="c1">#print  &quot;C&quot;,</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">tahe</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">R</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>


                <span class="k">else</span><span class="p">:</span> <span class="c1"># s==t  (Same source and target)vi</span>
                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c1">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>


    <span class="c1"># @profile</span>
<div class="viewcode-block" id="Signatures.run"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run.html#pylayers.antprop.signature.Signatures.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s1">&#39;.sig&#39;</span>

        <span class="c1"># list of interactions visible from source</span>
        <span class="n">lisR</span><span class="p">,</span><span class="n">lisT</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c1"># list of interactions visible from target</span>
        <span class="n">litR</span><span class="p">,</span><span class="n">litT</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c1">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c1">#print &quot;target,lit :&quot;,self.target,lit</span>
        <span class="c1"># for u in lit: </span>
        <span class="c1">#     print u</span>
        <span class="c1"># print &quot;-------------&quot;</span>

        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c1">#</span>
        <span class="c1"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c1"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c1">#for interaction source  in list of source interactions</span>

        <span class="c1"># signature counter</span>
        <span class="n">cptsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c1"># if (us%20)==0:</span>
            <span class="c1">#     print us,&#39;/&#39;,len(lis)</span>
            <span class="c1"># us counter</span>
            <span class="c1"># s : interaction </span>
            <span class="c1"># s[0] : point or segment</span>
            <span class="c1"># pts : list of neighbour nodes</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">tahe</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tahe</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])]</span>
            <span class="c1">#R is a list which contains reflexion matrices (Sn) and translation matrices(vn)</span>
            <span class="c1">#for mirroring </span>
            <span class="c1">#R=[[S0,v0],[S1,v1],...]</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))]</span>

            <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">lit</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
                <span class="n">anstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">visited</span><span class="p">))</span>
                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">visited</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">anstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">anstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                <span class="n">cptsig</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="c1"># stack is a list of iterators</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">])]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">ipdb</span>
                <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="c1"># lawp = list of airwall position in visited</span>
            <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># while the stack of iterators is not void</span>
            <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c1">#</span>
                <span class="c1"># iter_on_interactions is the last iterator in the stack</span>
                <span class="n">iter_on_interactions</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># next interaction child</span>
                <span class="n">interaction</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_on_interactions</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">cond1</span> <span class="o">=</span> <span class="n">interaction</span> <span class="ow">is</span> <span class="bp">None</span>
                <span class="c1"># test whether the interaction has already been visited (reverberation)</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">interaction</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bt</span>
                <span class="c1"># test the cutoff condition</span>
                <span class="n">cond3</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))</span>
                <span class="c1">#print cond1,cond2,cond3</span>
                <span class="c1">#print &quot;vis :&quot;,visited,interaction</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond3</span><span class="p">):</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
                        <span class="c1">#print visited,len(stack)</span>
                        <span class="k">if</span> <span class="n">interaction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]:</span>
                            <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># update number of useful segments</span>
                        <span class="c1"># if there is airwall in visited</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="n">interaction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># Testing the type of interaction at rank -2 </span>
                        <span class="c1"># R is a list which contains a rotation matrix </span>
                        <span class="c1"># and a translation vector for doing the mirroring </span>
                        <span class="c1"># operation</span>

                        <span class="c1">#diffraction (retrieve a point)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr</span><span class="p">]</span>
                            <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">th</span><span class="p">,</span><span class="n">th</span><span class="p">])</span>
                            <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>
                        <span class="c1"># reflexion </span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>

                            <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">nstr</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="c1">#th (Npt x xy)</span>
                            <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                            <span class="c1"># reverse order</span>
                            <span class="n">pts2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="n">ta_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts2</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                            <span class="n">he_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                            <span class="n">R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">axmat</span><span class="p">(</span><span class="n">ta_seg</span><span class="p">,</span><span class="n">he_seg</span><span class="p">))</span>
                            <span class="c1"># direct order</span>
                            <span class="c1">#R.append(geu.axmat(tahe[-1][0],tahe[-1][1]))</span>
                        <span class="c1"># transmission</span>
                        <span class="k">else</span> <span class="p">:</span> 
                            <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">nstr</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>

                        <span class="c1"># apply current chain of symmetries</span>
                        <span class="c1"># th is the current segment tail-head coordinates</span>
                        <span class="c1"># tahe is a list of well mirrored tail-head coordinates</span>
                        <span class="c1">#pdb.set_trace()</span>
                        <span class="c1">#for r in R[::-1]: </span>
                        <span class="c1">#for r in R:</span>
                        <span class="c1">#    th = np.einsum(&#39;ki,ij-&gt;kj&#39;,th,r[0])+r[1]</span>
                        <span class="c1">#pdb.set_trace()</span>
                        <span class="n">ik</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="n">ik</span><span class="p">]</span>
                        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>     
                            <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,ij-&gt;kj&#39;</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">ik</span> <span class="o">=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">r</span>  <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="n">ik</span><span class="p">]</span>
                        <span class="c1">#vlp vrpdb.set_trace()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tahe</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
                            <span class="n">tahe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
                            <span class="n">valid_bool</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">pta0</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># tail first segment</span>
                            <span class="n">phe0</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># head first segment</span>
                            <span class="n">pta_</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># tail last segment</span>
                            <span class="n">phe_</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># head last segment </span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">ccw</span><span class="p">(</span><span class="n">pta0</span><span class="p">,</span><span class="n">phe0</span><span class="p">,</span><span class="n">phe_</span><span class="p">)</span> <span class="o">^</span>
                                    <span class="n">geu</span><span class="o">.</span><span class="n">ccw</span><span class="p">(</span><span class="n">phe0</span><span class="p">,</span><span class="n">phe_</span><span class="p">,</span><span class="n">pta_</span><span class="p">)</span> <span class="p">):</span>
                                <span class="c1"># vr = (pta0,pta_)</span>
                                <span class="c1"># vl = (phe0,phe_)</span>
                                <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pta0</span><span class="p">,</span><span class="n">phe_</span><span class="p">)</span>
                                <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span><span class="n">phe0</span><span class="p">,</span><span class="n">pta_</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>  <span class="c1"># twisted case</span>
                                <span class="c1"># vr = (pta0,phe_)</span>
                                <span class="c1"># vl = (phe0,pta_)</span>
                                <span class="n">vr</span> <span class="o">=</span> <span class="p">(</span><span class="n">pta0</span><span class="p">,</span><span class="n">pta_</span><span class="p">)</span>
                                <span class="n">vl</span> <span class="o">=</span> <span class="p">(</span><span class="n">phe0</span><span class="p">,</span><span class="n">phe_</span><span class="p">)</span>

                            <span class="c1"># lta = geu.isleft(th[0][:,None],vl[0][:,None],vl[1][:,None])</span>
                            <span class="c1"># rta = geu.isleft(th[0][:,None],vr[0][:,None],vr[1][:,None])</span>
                            <span class="c1"># lhe = geu.isleft(th[1][:,None],vl[0][:,None],vl[1][:,None])</span>
                            <span class="c1"># rhe = geu.isleft(th[1][:,None],vr[0][:,None],vr[1][:,None])</span>

                            <span class="c1"># out = (lta &amp; lhe ) | (~rta &amp; ~rhe)</span>
                            <span class="c1"># inside = ~out</span>
                            <span class="c1">#if inside:   # new segment is inside the beam</span>
                            <span class="n">linel</span> <span class="o">=</span> <span class="p">(</span><span class="n">vl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">liner</span> <span class="o">=</span> <span class="p">(</span><span class="n">vr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">seg</span>   <span class="o">=</span> <span class="p">(</span><span class="n">th</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">th</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="c1">#pdb.set_trace()</span>
                            <span class="n">kl</span><span class="p">,</span><span class="n">p_int_left</span>  <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">intersect_line_seg</span><span class="p">(</span><span class="n">linel</span><span class="p">,</span><span class="n">seg</span><span class="p">)</span>
                            <span class="n">kr</span><span class="p">,</span><span class="n">p_int_right</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">intersect_line_seg</span><span class="p">(</span><span class="n">liner</span><span class="p">,</span><span class="n">seg</span><span class="p">)</span>
                            <span class="n">valid_bool</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">kl</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">kr</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)):</span> <span class="c1"># 0 intersection points </span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">kl</span><span class="o">*</span><span class="n">kr</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                                    <span class="n">tha</span> <span class="o">=</span> <span class="n">th</span>
                                    <span class="n">tahe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tha</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span> <span class="c1"># outside cone</span>
                                    <span class="n">valid_bool</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">kl</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">kr</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)):</span> <span class="c1"># 2 intersection points </span>
                                <span class="n">tha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">p_int_left</span><span class="p">,</span><span class="n">p_int_right</span><span class="p">))</span>
                                <span class="n">tahe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tha</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">kl</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">kr</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)):</span>
                                <span class="k">if</span> <span class="n">kr</span><span class="o">&lt;</span><span class="n">kl</span><span class="p">:</span>
                                    <span class="n">tha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">th</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p_int_left</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">tha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">p_int_left</span><span class="p">,</span><span class="n">th</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="n">tahe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tha</span><span class="p">)</span>
                            <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">kr</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">kl</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)):</span>
                                <span class="k">if</span> <span class="n">kl</span><span class="o">&lt;</span><span class="n">kr</span><span class="p">:</span>
                                    <span class="n">tha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">th</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p_int_right</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">tha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">p_int_right</span><span class="p">,</span><span class="n">th</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="n">tahe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tha</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">valid_bool</span><span class="p">:</span>
                            <span class="c1">#showsig2(visited,self.L,tahe)</span>
                            <span class="c1">#pdb.set_trace()  </span>
                            <span class="c1"># sequence is valid and last interaction is in the list of targets   </span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">interaction</span> <span class="ow">in</span> <span class="n">lit</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">interaction</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
                                <span class="n">anstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">visited</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">visited</span><span class="p">))</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">anstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">anstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="n">cptsig</span> <span class="o">+=</span><span class="mi">1</span>
                                <span class="c1">#print visited,len(stack),cptsig  </span>

                            <span class="c1"># move forward even when arrived in the target cycle</span>
                            
                            <span class="n">outint</span> <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">interaction</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="n">proint</span> <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">interaction</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                            <span class="c1">#nexti  = [it for k,it in enumerate(outint) if ((it[0]&gt;0) and (proint[k]&gt;threshold))]</span>
                            <span class="n">nexti</span>  <span class="o">=</span> <span class="p">[</span><span class="n">it</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">it</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outint</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">proint</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">)]</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nexti</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#ltahe = tahe+[th]</span>
                            <span class="c1">#showsig2(visited,self.L,ltahe)</span>
                            <span class="c1">#pdb.set_trace()  </span>
                            <span class="c1"># go back</span>
                            <span class="c1">#pdb.set_trace()</span>
                            <span class="c1">#print visited</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                                    <span class="n">R</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">last</span> <span class="o">=</span> <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="c1">#tahe.pop()</span>
                            <span class="c1">#R.pop()</span>
                            <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print visited</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                            <span class="n">R</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">tahe</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="c1">#R.pop()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span></div>

            
             

    <span class="k">def</span> <span class="nf">plot_cones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="p">[],</span><span class="n">ax</span><span class="o">=</span><span class="p">[],</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; display cones of an unfolded signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : int</span>
<span class="sd">            the interaction block</span>
<span class="sd">        s : int</span>
<span class="sd">            the signature number in the block</span>
<span class="sd">        fig :</span>
<span class="sd">        ax  :</span>
<span class="sd">        figsize :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ax</span> <span class="o">==</span><span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>


        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># create a global array or tahe segments</span>

        <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pta</span><span class="p">,</span><span class="n">phe</span><span class="p">))</span>
        <span class="n">lensi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">seg</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">lensi</span><span class="p">):</span>
            <span class="n">pseg0</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pseg1</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c1">#</span>
            <span class="c1"># create the cone seg0 seg1</span>
            <span class="c1">#</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
            <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span> <span class="o">=</span> <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="n">figsize</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>


<div class="viewcode-block" id="Signatures.unfold"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.unfold.html#pylayers.antprop.signature.Signatures.unfold">[docs]</a>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; unfold a given signature</span>

<span class="sd">        return 2 np.ndarray of pta and phe &quot;aligned&quot;</span>
<span class="sd">        (reflexion interaction are mirrored)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : int</span>
<span class="sd">            the interaction block</span>
<span class="sd">        s : int</span>
<span class="sd">            the signature number in the block</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pta,phe</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.unfold</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">si</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">):(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">si</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
        
        
        <span class="k">return</span> <span class="n">pta</span><span class="p">,</span><span class="n">phe</span></div>

    <span class="k">def</span> <span class="nf">pltunfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">shapely.ops</span> <span class="kn">as</span> <span class="nn">sho</span>
        <span class="kn">from</span> <span class="nn">descartes.patch</span> <span class="kn">import</span> <span class="n">PolygonPatch</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">plot_lines</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">[]):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ob</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span><span class="mi">0</span> <span class="p">:</span> 
                        <span class="n">c</span> <span class="o">=</span><span class="s1">&#39;g&#39;</span>
                    <span class="k">elif</span> <span class="n">ii</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span><span class="s1">&#39;r&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">=</span> <span class="s1">&#39;k&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">color</span>

                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">xy</span>
                
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">solid_capstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>
        <span class="k">def</span> <span class="nf">plot_poly</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">[]):</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ob</span><span class="p">):</span>
                
                <span class="n">pp</span> <span class="o">=</span> <span class="n">PolygonPatch</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">ax</span>
        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="n">ML</span> <span class="o">=</span><span class="n">sh</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">([((</span><span class="n">pta</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">pta</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]),(</span><span class="n">phe</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">phe</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">fig</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_lines</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">ML</span><span class="p">)</span>

        <span class="n">s0</span><span class="o">=</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">([(</span><span class="n">pta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),(</span><span class="n">phe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">phe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">s1</span><span class="o">=</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">([(</span><span class="n">phe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),(</span><span class="n">pta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">pta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="k">if</span> <span class="n">s0</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
            <span class="n">s0</span><span class="o">=</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">([(</span><span class="n">pta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">pta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),(</span><span class="n">pta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">pta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">s1</span><span class="o">=</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">([(</span><span class="n">phe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">phe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),(</span><span class="n">phe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">phe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">([</span><span class="n">s0</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">ML</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ML</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">poly</span><span class="o">=</span><span class="n">sho</span><span class="o">.</span><span class="n">polygonize</span><span class="p">(</span><span class="n">cross</span><span class="p">)</span>
        <span class="c1"># ax = plot_lines(ax,cross,color=&#39;b&#39;)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_poly</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">poly</span><span class="p">)</span>

<div class="viewcode-block" id="Signatures.show"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.show.html#pylayers.antprop.signature.Signatures.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot signatures within the simulated environment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : list or -1 (default = all groups)</span>
<span class="sd">            list of interaction group numbers</span>
<span class="sd">        s : list or -1 (default = all sig)</span>
<span class="sd">            list of indices of signature in interaction group</span>
<span class="sd">        ctx : cycle of tx (optional)</span>
<span class="sd">        crx : cycle of rx (optional)</span>
<span class="sd">        graph : type of graph to be displayed</span>
<span class="sd">        color : string</span>
<span class="sd">        alphasig : float</span>
<span class="sd">        widthsig : float</span>
<span class="sd">        colsig : string</span>
<span class="sd">        ms : int</span>
<span class="sd">        ctx  : int</span>
<span class="sd">        crx :int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="s1">&#39;s&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="s1">&#39;fig&#39;</span><span class="p">:[],</span>
                   <span class="s1">&#39;ax&#39;</span><span class="p">:[],</span>
                   <span class="s1">&#39;graph&#39;</span><span class="p">:</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;alphasig&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;widthsig&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span>
                    <span class="s1">&#39;colsig&#39;</span><span class="p">:</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;ms&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                    <span class="s1">&#39;ctx&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;crx&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span>
                   <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># display layout</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ctx&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Tpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ctx&#39;</span><span class="p">]][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">Tpoly</span><span class="o">.</span><span class="n">coul</span><span class="o">=</span><span class="s1">&#39;r&#39;</span>
            <span class="n">Tpoly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;crx&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Rpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;crx&#39;</span><span class="p">]][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">Rpoly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>

        <span class="c1"># i=-1 all rays</span>
        <span class="c1"># else block of interactions i</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">lgrint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lgrint</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]]</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lgrint</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">lsig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsig</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">])</span>
                <span class="n">siga</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                <span class="c1"># sig = np.hstack((self.pTx[0:2].reshape((2, 1)),</span>
                <span class="c1">#                  np.hstack((self[i][&#39;pt&#39;][0:2, :, j],</span>
                <span class="c1">#                  self.pRx[0:2].reshape((2, 1))))</span>
                <span class="c1">#                  ))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">siga</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">siga</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alphasig&#39;</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;colsig&#39;</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;widthsig&#39;</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signatures.showi"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.showi.html#pylayers.antprop.signature.Signatures.showi">[docs]</a>    <span class="k">def</span> <span class="nf">showi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">uni</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">us</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; interactive show</span>

<span class="sd">        press n to visit signatures sequentially</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        uni : index of interaction dictionnary keys</span>
<span class="sd">        us : signature index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

        <span class="n">nit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
        <span class="n">ust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">polyS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">polyS</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">polyT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">polyT</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">st</span><span class="o">=</span><span class="s1">&#39;a&#39;</span>

        <span class="k">while</span> <span class="n">st</span> <span class="o">!=</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">graph</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;# interaction :&#39;</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="s1">&#39;signature #&#39;</span><span class="p">,</span><span class="n">us</span><span class="p">,</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="n">ust</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">ptx</span>
            <span class="c1"># draw terminal points (centroid of source and target cycle)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;xr&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;xb&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ni</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">print</span> <span class="s2">&quot;incorrect number of interactions&quot;</span>
            <span class="n">pos</span><span class="o">=</span><span class="p">{}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">us</span><span class="o">*</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">u</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]})</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]))))</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span><span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][(</span><span class="n">us</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;signature index out of bounds of signature&quot;</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line</span><span class="p">,</span><span class="n">prx</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">line</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">line</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">print</span> <span class="n">inter</span>
            <span class="n">st</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">us</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">ust</span><span class="p">:</span>
                    <span class="n">us</span><span class="o">=</span><span class="n">us</span><span class="o">+</span><span class="mi">2</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">uni</span> <span class="o">=</span> <span class="n">uni</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ni</span> <span class="o">=</span> <span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
                        <span class="n">ust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                        <span class="n">us</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">uni</span><span class="o">=</span><span class="mi">0</span>
                        <span class="n">ni</span><span class="o">=</span><span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
                        <span class="n">us</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39;press n for next signature&#39;</span></div>


<div class="viewcode-block" id="Signatures.rays"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.rays.html#pylayers.antprop.signature.Signatures.rays">[docs]</a>    <span class="k">def</span> <span class="nf">rays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ptx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">prx</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; from signatures dict to 2D rays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptx : numpy.array or int</span>
<span class="sd">            Tx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(tx)=int</span>
<span class="sd">        prx :  numpy.array or int</span>
<span class="sd">            Rx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            sigtype(rx)=int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rays : Rays</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        In the same time the signature of the ray is stored in the Rays object</span>

<span class="sd">        Todo : Find the best memory implemntation</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.sig2ray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ptx</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">prx</span><span class="p">])</span>

        <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># detect LOS situation</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># cycle on a line between 2 cycles</span>
        <span class="c1"># lc  = self.L.cycleinline(self.source,self.target)</span>

        <span class="c1">#</span>
        <span class="c1"># if source and target in the same merged cycle</span>
        <span class="c1"># and ptx != prx</span>
        <span class="c1">#</span>
        <span class="n">los</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="c1"># convex cycle of each point</span>
        <span class="n">cyptx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span>
        <span class="n">cyprx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span>

        <span class="c1"># merged cycle of each point</span>
        <span class="n">polyctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyptx</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">polycrx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyprx</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>

        <span class="n">dtxrx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dtxrx</span><span class="o">&gt;</span><span class="mf">1e-15</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cyptx</span><span class="o">==</span><span class="n">cyprx</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">los</span><span class="p">):</span>
                    <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># k : Loop on interaction group</span>
        <span class="c1">#   l : loop on signature</span>
        <span class="c1"># ---&gt;</span>
        <span class="c1">#  this part should be a generator</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># print &#39;block#&#39;,k</span>
            <span class="c1"># if k ==3:</span>
            <span class="c1">#     import ipdb</span>
            <span class="c1">#     ipdb.set_trace()</span>
            <span class="c1"># get signature block with k interactions</span>
            <span class="n">tsig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">shsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tsig</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shsig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">tsig</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,:]</span>
                <span class="n">ns0</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nse</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">validtx</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">validrx</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">ns0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">pD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ns0</span><span class="p">]</span>
                    <span class="n">TxD</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">pD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pD</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">TxD</span><span class="p">)</span>
                    <span class="n">validtx</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">almost_equals</span><span class="p">(</span><span class="n">TxD</span><span class="p">,</span><span class="n">decimal</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validtx</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c1">#print &quot;Signature.rays&quot;: ns0</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">nse</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">pD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nse</span><span class="p">]</span>
                    <span class="n">DRx</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">pD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pD</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">validrx</span> <span class="o">=</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DRx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validrx</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c1">#print nse</span>

                <span class="k">if</span> <span class="n">validtx</span> <span class="o">&amp;</span> <span class="n">validrx</span><span class="p">:</span>
                    <span class="c1">#    print sig</span>
                    <span class="c1">#    print pD</span>
                    <span class="n">s</span>  <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1"># Transform signature into a ray</span>
                    <span class="c1"># --&gt; sig2ray</span>

                    <span class="n">isray</span><span class="p">,</span><span class="n">Yi</span>  <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sig2ray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">ptx</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">prx</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">isray</span><span class="p">:</span>
                        <span class="n">Yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rays</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Yi3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Yi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))))</span>
                            <span class="n">Yi3d</span> <span class="o">=</span> <span class="n">Yi3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span> <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">],</span> <span class="n">Yi3d</span><span class="p">))</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span> <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">],</span>
                                                        <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>

                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pt&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                       <span class="s1">&#39;sig&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)}</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="n">rays</span><span class="o">.</span><span class="n">nb_origin_sig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">return</span> <span class="n">rays</span></div>


<div class="viewcode-block" id="Signatures.raysv"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.raysv.html#pylayers.antprop.signature.Signatures.raysv">[docs]</a>    <span class="k">def</span> <span class="nf">raysv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ptx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">prx</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; transfrom dict of signatures into 2D rays - default vectorized version</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptx : numpy.array or int</span>
<span class="sd">            Tx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(tx)=int</span>
<span class="sd">        prx :  numpy.array or int</span>
<span class="sd">            Rx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(rx)=int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rays : Rays</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This is a vectorized version of Signatures.rays.</span>
<span class="sd">        This implementation takes advantage of the np.ndarray</span>
<span class="sd">        and calculates images and backtrace for block of signatures.</span>
<span class="sd">        A block of signatures gathers all signatures with the same number of interactions.</span>

<span class="sd">        For mathematical details see :</span>

<span class="sd">        @phdthesis{amiot:tel-00971809,</span>
<span class="sd">          TITLE = {{Design of simulation platform joigning site specific radio propagation and human mobility for localization applications}},</span>
<span class="sd">          AUTHOR = {Amiot, Nicolas},</span>
<span class="sd">          URL = {https://tel.archives-ouvertes.fr/tel-00971809},</span>
<span class="sd">          NUMBER = {2013REN1S125},</span>
<span class="sd">          SCHOOL = {{Universit{\&#39;e} Rennes 1}},</span>
<span class="sd">          YEAR = {2013},</span>
<span class="sd">          MONTH = Dec,</span>
<span class="sd">          KEYWORDS = {Electromagnetic wave propagation simulation ; Human mobility simulation ; Wireless localization methods ; Position estimation methods in wireless networks ; Vectorized computation ; Ray-tracing ; Ultra wide band ; Simulateur de propagation {\&#39;e}lectromagn{\&#39;e}tique ; Simulateur de mobilit{\&#39;e} humaine ; M{\&#39;e}thodes de localisation sans fils ; M{\&#39;e}thodes d&#39;estimation de la position dans les r{\&#39;e}seaux sans fils ; Calcul informatique vectoris{\&#39;e} ; Outil de trac{\&#39;e} de rayons ; Ultra large bande},</span>
<span class="sd">          TYPE = {Theses},</span>
<span class="sd">          HAL_ID = {tel-00971809},</span>
<span class="sd">          HAL_VERSION = {v1},</span>
<span class="sd">        }</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signatures.image</span>
<span class="sd">        Signatures.backtrace</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ptx</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">prx</span><span class="p">])</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ptx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ptx</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">prx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">prx</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]</span>

        <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># detect LOS situation</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># cycle on a line between 2 cycles</span>
        <span class="c1"># lc  = self.L.cycleinline(self.source,self.target)</span>

        <span class="c1">#</span>
        <span class="c1"># if source and target are in the same merged cycle</span>
        <span class="c1"># and ptx != prx</span>
        <span class="c1">#</span>

        <span class="n">los</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="c1"># convex cycle of each point</span>
        <span class="n">cyptx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span>
        <span class="n">cyprx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span>


        <span class="n">polyctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyptx</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">polycrx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyprx</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>

        <span class="n">dtxrx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dtxrx</span><span class="o">&gt;</span><span class="mf">1e-15</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">los</span><span class="p">):</span>
                <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">False</span>


        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image2</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backtrace</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">nb_origin_sig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">return</span> <span class="n">rays</span></div>

    <span class="k">def</span> <span class="nf">backtrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; backtracing betwen tx and rx </span>

<span class="sd">        Warning :</span>
<span class="sd">            This is an attempt to vectorize the backtrace process.</span>
<span class="sd">            Despite it has been tested on few cases with succes,</span>
<span class="sd">            this is quite new need to be validated !!!</span>


<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">                tx : ndarray</span>
<span class="sd">                    position of tx (2,)</span>
<span class="sd">                rx : ndarray</span>
<span class="sd">                    position of tx (2,)</span>
<span class="sd">                M : dict</span>
<span class="sd">                    position of intermediate points obtained from self.image()</span>

<span class="sd">            Return</span>
<span class="sd">            -------</span>

<span class="sd">                rayp : dict</span>
<span class="sd">                key = number_of_interactions</span>
<span class="sd">                value =ndarray positions of interactions for creating rays</span>

<span class="sd">            Notes</span>
<span class="sd">            -----</span>

<span class="sd">            dictionnary of intermediate coordinated :</span>
<span class="sd">            key = number_of_interactions</span>
<span class="sd">            value = nd array M with shape : (2,nb_signatures,nb_interactions)</span>
<span class="sd">            and 2 represent x and y coordinates</span>

<span class="sd">            See Also</span>
<span class="sd">            --------</span>

<span class="sd">            pylayers.antprop.signature.image</span>

<span class="sd">        &#39;&#39;&#39;</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">rx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">rayp</span><span class="o">=</span><span class="p">{}</span>

        <span class="c1"># loop on number of interactions</span>
        <span class="k">for</span> <span class="n">ninter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">signatures</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">])</span>
            <span class="c1">#get segment ids of signature with ninter interactions</span>
            <span class="c1"># seg = self[ninter][::2]</span>
            <span class="c1"># unegseg=np.where(seg&lt;0)</span>
            <span class="c1"># uninegseg,idx = np.unique(seg[unegseg],return_inverse=True)</span>
            <span class="c1"># pneg = np.array([self.L.Gs.pos[x] for x in uninegseg])</span>

            <span class="c1"># nsig = len(seg)</span>

            <span class="c1"># # determine positions of points limiting the semgments</span>
            <span class="c1"># #1 get index in L.tahe</span>
            <span class="c1"># # 2 get associated position in L.pt</span>


            <span class="c1"># utahe = self.L.tahe[:,self.L.tgs[seg]]</span>
            <span class="c1"># # pt : (xycoord (2),pt indexes (2),nb_signatures,nb_interactions)</span>
            <span class="c1"># pt = self.L.pt[:,utahe]</span>
            

            <span class="c1"># ####WARNING BIG TRICK HERE :</span>
            <span class="c1"># #### pa and pb are not set as the same value </span>
            <span class="c1"># #### to avoid a singular matrixnext.</span>
            <span class="c1"># #### set pa =-pb has no incidence but avoid complex and vain code </span>
            <span class="c1"># #### modification for handling diffractions</span>
            <span class="c1"># try:</span>
            <span class="c1">#     pt[:,0,unegseg[0],unegseg[1]]=pneg[idx].T</span>
            <span class="c1">#     pt[:,1,unegseg[0],unegseg[1]]=-pneg[idx].T</span>
            <span class="c1"># except:</span>
            <span class="c1">#     pass</span>
            <span class="c1"># pt shape =</span>
            <span class="c1"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c1"># 1 : 2 points (linking the semgnet) a=0,b=1</span>
            <span class="c1">#2 : nb of found signatures/segments</span>
            <span class="c1"># 3 : nb interaction</span>



            <span class="c1">################################</span>
            <span class="c1">###############################</span>
            <span class="c1">####### This part between hash has been copy/paste from self.image2</span>
            <span class="c1">###### should be considered to become a function</span>

            <span class="c1">#get segment ids of signature with ninter interactions</span>
            <span class="c1"># nid = node id</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>


            <span class="c1"># pt shape =</span>
            <span class="c1"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c1"># 1 : 2 points (linking the nidment) a=0,b=1</span>
            <span class="c1"># 2 : nb of found signatures/nidments</span>
            <span class="c1"># 3 : nb interactions</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="p">))</span>


            <span class="c1"># 1 negative points</span>
            <span class="c1"># seek for diffraction </span>
            <span class="c1"># negative index points are diffraction points</span>
            <span class="n">upoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nid</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">unipoint</span><span class="p">,</span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="n">upoint</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1">#get their coordinates</span>
            <span class="c1">#</span>
            <span class="c1"># TO BE FIXED </span>
            <span class="c1">#</span>
            <span class="c1">#upointcoord = self.L.iupnt[-unipoint]</span>
            <span class="c1">#pointcoord = self.L.pt[:,upointcoord]</span>

            <span class="n">pointcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unipoint</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># #### WARNING BIG TRICK HERE :</span>
            <span class="c1"># #### pa and pb are not set as the same value </span>
            <span class="c1"># #### to avoid a singular matrixnext.</span>
            <span class="c1"># #### set pa =-pb has no incidence but avoid complex and vain code </span>
            <span class="c1"># #### modification for handling diffractions</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">upoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">upoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pointcoord</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="n">upoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">upoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pointcoord</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>


            <span class="c1"># 2 positive points</span>
            <span class="c1"># seek for segments</span>
            <span class="n">useg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nid</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># removing duplicates ( for increasing speed)</span>
            <span class="n">uniseg</span><span class="p">,</span><span class="n">idxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="n">useg</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1"># determine positions of points limiting the nidments</span>
            <span class="c1">#1 get index in L.tahe</span>
            <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">uniseg</span><span class="p">]]</span>
            <span class="n">segcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="n">utahe</span><span class="p">]</span>

            <span class="n">pt</span><span class="p">[:,:,</span><span class="n">useg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">useg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">segcoord</span><span class="p">[:,:,</span><span class="n">idxp</span><span class="p">]</span>

            <span class="c1">###################################</span>
            <span class="c1">########################################</span>



            <span class="c1"># how to do this into a while loop</span>
            <span class="n">p</span><span class="o">=</span><span class="n">rx</span>

            <span class="c1"># creating W matrix required in eq (2.70) thesis Nicolas AMIOT</span>
            <span class="c1">#Warning W is rolled after and becomes (nsig,4,4)</span>
            <span class="n">W</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">nsig</span><span class="p">))</span>
            <span class="n">I</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nsig</span><span class="p">))</span>
            <span class="n">W</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
            <span class="n">W</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>

            <span class="c1"># once rolled :</span>
            <span class="c1"># W (nsig,4,4)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


            <span class="n">kinter</span><span class="o">=</span><span class="n">ninter</span><span class="o">-</span><span class="mi">1</span>

            <span class="n">ptr</span> <span class="o">=</span> <span class="n">pt</span>
            <span class="n">Mr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

            <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span>
            <span class="n">rayp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="p">))</span>
            <span class="c1"># rayp_i[:2,:,-1]=rx[:,None]</span>
            <span class="c1">#backtrace process</span>
            <span class="c1"># if ninter == 6:</span>
            <span class="c1">#     print np.where(((signatures[:,0]==42) &amp;(signatures[:,1]==-277) &amp; (signatures[:,2]==135) &amp; (signatures[:,3]==21) &amp; (signatures[:,4]==46) &amp; (signatures[:,5]==319)))</span>
            <span class="c1">#     import ipdb</span>
            <span class="c1">#     ipdb.set_trace()</span>

            <span class="k">while</span> <span class="n">kinter</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="c1">#Initilization, using the Tx position</span>
                <span class="k">if</span> <span class="n">kinter</span> <span class="o">==</span> <span class="n">ninter</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">p_min_m</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">-</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">][:,:,</span><span class="n">kinter</span><span class="p">]</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">p_min_m</span> <span class="o">=</span> <span class="n">pvalid</span><span class="p">[:]</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">][:,:,</span><span class="n">kinter</span><span class="p">]</span>

                <span class="n">a_min_b</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]</span><span class="o">-</span><span class="n">ptr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]</span>

                <span class="c1"># Creating W from  eq (2.71)</span>
                <span class="c1"># a_min_b &lt;=&gt; a_{Lh-l}-b_{Lh-l}</span>
                <span class="c1"># p_min_m &lt;=&gt; \tilde{p}_{Lh}-\tilde{b}_{Lh-l}</span>
                <span class="c1"># W (nsig,4,4)</span>
                <span class="c1"># p_min_m (2,nsig)</span>
                <span class="c1"># a_min_b (2,nsig)</span>
                <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_min_m</span><span class="o">.</span><span class="n">T</span>
                <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_min_b</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># create 2nd member from eq (2.72)</span>
                <span class="k">if</span> <span class="n">kinter</span> <span class="o">==</span> <span class="n">ninter</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">p</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nsig</span><span class="p">)),</span><span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pvalid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,</span><span class="n">kinter</span><span class="p">]))</span>

                <span class="c1"># y once transposed :</span>
                <span class="c1"># y (nsig,4)</span>
                <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">T</span>


                <span class="c1"># search and remove point with singular matrix</span>
                <span class="n">invalid_sig</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">W</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1e-15</span><span class="p">)</span>

                <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">],</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">rayp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">rayp_i</span><span class="p">,</span><span class="n">invalid_sig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1">#remove signatures</span>

                <span class="n">usig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">invalid_sig</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">usig</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usig</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
                <span class="n">usig</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usig</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">signatures</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">signatures</span><span class="p">,</span><span class="n">usig</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># detect diffrac</span>
                <span class="n">uD</span> <span class="o">=</span> <span class="n">signatures</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span>
                <span class="n">uuD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signatures</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


                <span class="n">psolved</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

                <span class="c1">#valid ray is : 0 &lt; \alpha &lt; 1 and 0&lt; \beta &lt; 1</span>

                <span class="c1"># alpha</span>
                <span class="n">uvalidA</span> <span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.</span>
                <span class="n">uvalidB</span> <span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="mf">1.</span>
                <span class="c1">#beta</span>
                <span class="n">uvalidC</span> <span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">epsilon</span>
                <span class="n">uvalidD</span> <span class="o">=</span> <span class="n">psolved</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span><span class="mf">1.</span><span class="o">-</span><span class="n">epsilon</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">uvalidA</span> <span class="o">&amp;</span> <span class="n">uvalidB</span> <span class="o">&amp;</span> <span class="n">uvalidC</span> <span class="o">&amp;</span> <span class="n">uvalidD</span>
                <span class="c1"># consider valid diffraction interactions</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">|</span> <span class="n">uD</span>
                <span class="n">uvalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># re-add correct position of diffraction interations</span>
                <span class="c1">#indeed diffraction point should not been solved with linalg, </span>
                <span class="c1"># but by setting pa=-pb, no singular matrix appear</span>
                <span class="c1">#and diffraction points can be re-add thereafter.</span>
                <span class="n">psolved</span><span class="p">[</span><span class="n">uuD</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">uuD</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

                <span class="n">pvalid</span> <span class="o">=</span> <span class="n">psolved</span><span class="p">[</span><span class="n">uvalid</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>


                <span class="c1"># keep only valid rays for ptr and Mr</span>
                <span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">]</span><span class="o">=</span><span class="n">Mr</span><span class="p">[</span><span class="n">ninter</span><span class="p">][:,</span><span class="n">uvalid</span><span class="p">,:]</span>
                <span class="n">ptr</span><span class="o">=</span><span class="n">ptr</span><span class="p">[:,:,</span><span class="n">uvalid</span><span class="p">,:]</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">uvalid</span><span class="p">,:,:]</span>


                <span class="c1"># remove signatures</span>
                <span class="n">usigv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uvalid</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">usigv</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usigv</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
                <span class="n">usigv</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">usigv</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">signatures</span> <span class="o">=</span> <span class="n">signatures</span><span class="p">[</span><span class="n">usigv</span><span class="p">,:]</span>
                <span class="n">rayp_i</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="n">uvalid</span><span class="p">,</span><span class="n">kinter</span><span class="p">]</span> <span class="o">=</span> <span class="n">pvalid</span><span class="o">.</span><span class="n">T</span>
                <span class="n">rayp_i</span> <span class="o">=</span> <span class="n">rayp_i</span><span class="p">[:,</span><span class="n">uvalid</span><span class="p">,:]</span>
                <span class="c1">#if no more rays are valid , then quit block</span>
                <span class="c1"># (kinter &lt;0 is the exit while condition)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvalid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">kinter</span><span class="o">=</span><span class="n">kinter</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">kinter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

            <span class="c1"># rayp_i[:2,:,0]=tx[:,None]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvalid</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">sir1</span><span class="o">=</span><span class="n">signatures</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ninter</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">usigv</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">sir2</span><span class="o">=</span><span class="n">signatures</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ninter</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">usigv</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">ninter</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">usigv</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">sir1</span>
                <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">sir2</span>
                <span class="n">rayp_i</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">rayp_i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">rayp</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ninter</span><span class="p">:{</span><span class="s1">&#39;pt&#39;</span><span class="p">:</span><span class="n">rayp_i</span><span class="p">,</span><span class="s1">&#39;sig&#39;</span><span class="p">:</span><span class="n">sig</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)}})</span>
        <span class="k">return</span> <span class="n">rayp</span>


<div class="viewcode-block" id="Signatures.image2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.image2.html#pylayers.antprop.signature.Signatures.image2">[docs]</a>    <span class="k">def</span> <span class="nf">image2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine rays from images (second implementation)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx : point</span>

<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dM</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1"># loop on number of interactions</span>
        <span class="k">for</span> <span class="n">ninter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c1">#get segment ids of signature with ninter interactions</span>
            <span class="c1"># nid = node id</span>
            <span class="n">nid</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="p">))</span>


            <span class="c1"># pt shape =</span>
            <span class="c1"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c1"># 1 : 2 points (linking the nidment) a=0,b=1</span>
            <span class="c1"># 2 : nb of found signatures/nidments</span>
            <span class="c1"># 3 : nb interactions</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="p">))</span>

            <span class="c1">#1 negative points</span>
            <span class="c1"># seek for diffraction </span>
            <span class="c1"># negative index points are diffraction points</span>
            <span class="n">upoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nid</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">unipoint</span><span class="p">,</span><span class="n">idxpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="n">upoint</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1">#get their coordinates</span>
            <span class="c1">#</span>
            <span class="c1"># To be FIXED</span>
            <span class="c1">#</span>
            <span class="c1">#upointcoord = self.L.iupnt[-unipoint]</span>
            <span class="c1">#pointcoord = self.L.pt[:,upointcoord]</span>

            <span class="n">pointcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unipoint</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>
        
            <span class="c1"># try except to handle the case where there is no diffraction point</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">upoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">upoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pointcoord</span><span class="p">[:,</span><span class="n">idxpt</span><span class="p">]</span>
                <span class="n">pt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="n">upoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">upoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pointcoord</span><span class="p">[:,</span><span class="n">idxpt</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>


            <span class="c1">#2 positive points</span>
            <span class="c1">#seek for segments</span>
            <span class="n">useg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nid</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># removing duplicates ( for increasing speed)</span>
            <span class="n">uniseg</span><span class="p">,</span><span class="n">idxseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nid</span><span class="p">[</span><span class="n">useg</span><span class="p">],</span><span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1"># determine positions of points limiting the nidments</span>
            <span class="c1">#1 get index in L.tahe</span>
            <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">uniseg</span><span class="p">]]</span>
            <span class="n">segcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="n">utahe</span><span class="p">]</span>

            <span class="n">pt</span><span class="p">[:,:,</span><span class="n">useg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">useg</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">segcoord</span><span class="p">[:,:,</span><span class="n">idxseg</span><span class="p">]</span>

            <span class="c1"># check every element of pt is filled</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="c1">#</span>
            <span class="c1"># TODO Upgrading layout for handling slab offsets </span>
            <span class="c1">#</span>
            <span class="c1"># uncomment those two lines when the numpy array L.norm and</span>
            <span class="c1"># L.offset exist</span>
            <span class="c1">#norm    = self.L.normal[:,utahe]</span>
            <span class="c1">#offset  = self.L.offset[:,utahe]</span>
            <span class="c1"># pt = pt + offset*norm</span>


            <span class="c1">############</span>
            <span class="c1">#formula 2.61 -&gt; 2.64 N.AMIOT PH.D thesis</span>
            <span class="c1">############</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">sx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">sy</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1"># den = ((pt[0,0,:,:]-pt[0,1,:,:])**2+(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>
            <span class="c1"># avoiding singularity (should not be possible)</span>
            <span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">den</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">den</span><span class="p">[</span><span class="n">uz</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">b</span><span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                              <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                             <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                              <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                             <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="c1"># a = ((pt[0,0,:,:]-pt[0,1,:,:])**2-(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>
            <span class="c1"># a=a/(1.*den)</span>

            <span class="c1"># b = 2*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,1,:,:]-pt[1,0,:,:])</span>
            <span class="c1"># b=b/(1.*den)</span>

            <span class="c1"># c= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])**2+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,0,:,:]-pt[1,1,:,:]))</span>
            <span class="c1"># c = c/(1.*den)</span>

            <span class="c1"># d= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])*(pt[0,1,:,:]-pt[0,0,:,:])+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])**2)</span>
            <span class="c1"># d= d/(1.*den)</span>

            <span class="c1"># K=np.array([[a,-b],[-b,-a]])</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">],[</span><span class="o">-</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">]])</span>

            <span class="c1"># translation vector v (2.60)</span>
            <span class="n">v</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">]))</span>

            <span class="n">ityp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ninter</span><span class="p">):</span>
                <span class="c1">#get segment ids of signature with ninter interactions</span>
                <span class="n">uT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="n">n</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">=</span><span class="n">tx</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nsig</span><span class="p">))</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">p</span><span class="o">=</span><span class="n">M</span><span class="p">[:,:,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#reflexion 0 (2.67)</span>
                <span class="n">M</span><span class="p">[:,</span><span class="n">uR</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,jk-&gt;ik&#39;</span><span class="p">,</span><span class="n">K</span><span class="p">[:,:,</span><span class="n">uR</span><span class="p">,</span><span class="n">n</span><span class="p">],</span><span class="n">p</span><span class="p">[:,</span><span class="n">uR</span><span class="p">])</span><span class="o">+</span><span class="n">v</span><span class="p">[:,</span><span class="n">uR</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>
                <span class="c1">#transmission 0 (2.67)</span>
                <span class="n">M</span><span class="p">[:,</span><span class="n">uT</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="n">uT</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[:,</span><span class="n">uD</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="n">uD</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>

            <span class="c1"># if ninter==6:</span>
            <span class="c1">#     print np.where(((seg[:,0]==42) &amp; (seg[:,1]==-277) &amp; (seg[:,2]==135) &amp; (seg[:,3]==21)&amp;(seg[:,-1]==319)))</span>
            <span class="c1">#     import ipdb</span>
            <span class="c1">#     ipdb.set_trace()</span>

            <span class="n">dM</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ninter</span><span class="p">:</span><span class="n">M</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">dM</span></div>
<div class="viewcode-block" id="Signatures.image"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.image.html#pylayers.antprop.signature.Signatures.image">[docs]</a>    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.7</span><span class="p">,</span><span class="mf">12.5</span><span class="p">])):</span>
        <span class="sd">&#39;&#39;&#39; Warning :</span>
<span class="sd">            This is an attempt to vectorize the image process.</span>
<span class="sd">            Despite it has been tested on few cases with succes,</span>
<span class="sd">            this is quite new need to be validated !!!</span>


<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">                tx : ndarray</span>
<span class="sd">                    position of tx (2,)</span>

<span class="sd">            Return</span>
<span class="sd">            -------</span>

<span class="sd">                M : dictionnary</span>

<span class="sd">            dictionnary of intermediate coordinated :</span>
<span class="sd">            key = number_of_interactions</span>
<span class="sd">            value = nd array M with shape : (2,nb_signatures,nb_interactions)</span>
<span class="sd">            and 2 represent x and y coordinates</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">nb_split</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">nsp</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">out</span><span class="o">=</span><span class="bp">False</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">res</span><span class="o">=</span><span class="n">a</span><span class="o">%</span><span class="n">nsp</span>
                <span class="k">if</span> <span class="n">res</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">nsp</span><span class="o">=</span><span class="n">nsp</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">=</span><span class="bp">True</span>
            <span class="k">return</span> <span class="n">nsp</span>

        <span class="n">dM</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">ninter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1">#get segment ids of signature with ninter interactions</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">nsig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
            <span class="c1"># determine positions of points limiting the semgments</span>
            <span class="c1">#1 get index in L.tahe</span>
            <span class="c1"># 2 get associated position in L.pt</span>

            <span class="c1">#utahe (2 pt indexes,nb_signatures,nb_interactions)</span>

            <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">seg</span><span class="p">]]</span>



            <span class="c1"># pt : (xycoord (2),pt indexes (2),nb_signatures,nb_interactions)</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="n">utahe</span><span class="p">]</span>

            <span class="c1"># pt shape =</span>
            <span class="c1"># 0 : (x,y) coordinates x=0,y=1</span>
            <span class="c1"># 1 : 2 points (linking the semgnet) a=0,b=1</span>
            <span class="c1">#2 : nb of found signatures/segments</span>
            <span class="c1"># 3 : nb interaction</span>

            <span class="c1">############</span>
            <span class="c1">#formula 2.61 -&gt; 2.64 N.AMIOT thesis</span>
            <span class="c1">############</span>
            <span class="n">den</span> <span class="o">=</span> <span class="p">((</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,:]</span><span class="o">-</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">den</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">den</span><span class="p">[</span><span class="n">uz</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">b</span><span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span>

            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                                <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:])</span> <span class="o">*</span>
                                <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span> <span class="p">:]))</span>
            <span class="c1"># den = ((pt[0,0,:,:]-pt[0,1,:,:])**2+(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>

            <span class="c1"># a = ((pt[0,0,:,:]-pt[0,1,:,:])**2-(pt[1,0,:,:]-pt[1,1,:,:])**2)</span>
            <span class="c1"># a=a/(1.*den)</span>

            <span class="c1"># b = 2*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,1,:,:]-pt[1,0,:,:])</span>
            <span class="c1"># b=b/(1.*den)</span>

            <span class="c1"># c= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])**2+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])*(pt[1,0,:,:]-pt[1,1,:,:]))</span>
            <span class="c1"># c = c/(1.*den)</span>

            <span class="c1"># d= 2*(pt[0,0,:,:]*(pt[1,0,:,:]-pt[1,1,:,:])*(pt[0,1,:,:]-pt[0,0,:,:])+pt[1,0,:,:]*(pt[0,1,:,:]-pt[0,0,:,:])**2)</span>
            <span class="c1"># d= d/(1.*den)</span>

            <span class="c1">#get segment ids of signature with ninter interactions</span>
            <span class="n">ityp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ninter</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">uT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">uR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uD</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1">#create matrix AM which is used to create marix A from eq. 2.65</span>
            <span class="n">AM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">ninter</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nsig</span><span class="p">)</span>

            <span class="c1"># Reflexion MAtrix K (2.59)</span>
            <span class="n">K</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="p">],[</span><span class="o">-</span><span class="n">b</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="p">]])</span>
            <span class="c1"># translation vector v (2.60)</span>
            <span class="n">v</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">]))</span>

            <span class="c1">############</span>
            <span class="c1">#Create matrix A (2.66) which is fill by blocks</span>
            <span class="c1">############</span>



            <span class="n">blocks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">nsig</span><span class="p">,</span><span class="n">ninter</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Reflexion block</span>
            <span class="n">blocks</span><span class="p">[:,:,</span><span class="n">uR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uR</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=-</span><span class="n">K</span><span class="p">[:,:,</span><span class="n">uR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Transmission block</span>
            <span class="n">blocks</span><span class="p">[:,:,</span><span class="n">uT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uT</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">uT</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="c1"># Diff block</span>
            <span class="n">blocks</span><span class="p">[:,:,</span><span class="n">uD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uD</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="mf">0.</span>

            <span class="c1"># fill the AM mda on the diagonal below the mda diagonal....</span>
            <span class="n">A</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">fill_block_diagMDA</span><span class="p">(</span><span class="n">AM</span><span class="p">,</span><span class="n">blocks</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># The 2nd member y is firslty completly fill, without taking into account that the 1st line differst from others.</span>
            <span class="c1"># 1. find which interaction and signature are R|T|D =&gt; create a masked array</span>
            <span class="c1"># 2. repeat is created because to each signature/interaction correspond a 2x1 column. Repeat allow to have the correct size to fill y</span>
            <span class="c1"># 3. fill the 1st line of y to take into consideration that difference.</span>

            <span class="c1">#y is the 2nd memeber from from (2.65) and will be filled following (2.67)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ninter</span><span class="p">,</span><span class="n">nsig</span><span class="p">))</span>

            <span class="c1">#######</span>
            <span class="c1"># Determine where y has to be filed with R|T|D</span>
            <span class="c1">#####</span>
            <span class="c1">#find the position where there is T|R|D. non continuous =&gt; need mask array</span>
            <span class="n">uTf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">uRf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uDf</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1">#postiion in signature &lt;=&gt; 2 lines in y . need to repeat to get the correct size</span>
            <span class="n">uRy2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uRf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uRy1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uRf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uRy1</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">uRy1</span>
            <span class="n">uRy1</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">uRy1</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>

            <span class="n">uDy2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uDf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uDy1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">uDf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">uDy1</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">uDy1</span>
            <span class="n">uDy1</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">uDy1</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">uRy1</span><span class="p">,</span><span class="n">uRy2</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">[:,</span><span class="n">uRf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uRf</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1">#print &#39;no R&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#uT1mr = np.repeat(uT1m.mask,2,axis=1).T</span>
                <span class="c1">#nothing to do. shoould be a zero vector , already initialized by y</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1">#print &#39;no T&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># NEVER TESTED !!!!!!!!!!!</span>
                <span class="n">y</span><span class="p">[</span><span class="n">uDy1</span><span class="p">,</span><span class="n">uDy2</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">uDf</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;signatures.image diffraction line 3672 Not yet tested !&quot;</span>

                <span class="k">pass</span> <span class="c1">#print &#39;no D&#39;</span>

            <span class="c1">######</span>
            <span class="c1">#FIRST LINE specific processing of (2.67)</span>
            <span class="c1">######</span>
            <span class="n">uT0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uR0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uD0</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1">#reflexion 0 (2.67)</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,j-&gt;ik&#39;</span><span class="p">,</span><span class="n">K</span><span class="p">[:,:,</span><span class="n">uR0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">tx</span><span class="p">)</span><span class="o">+</span><span class="n">v</span><span class="p">[:,</span><span class="n">uR0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#trnasmission 0 (2.67)</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uT0</span><span class="p">))</span>
            <span class="c1">#diff 0 (2.67)</span>
            <span class="n">d0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">uD0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#first line</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">uR0</span><span class="p">]</span><span class="o">=</span><span class="n">r0</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">uT0</span><span class="p">]</span><span class="o">=</span><span class="n">t0</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">uD0</span><span class="p">]</span><span class="o">=</span><span class="n">d0</span>

            <span class="c1">#reshape for compliant size with linalg</span>
            <span class="n">A</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">leA</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">res</span><span class="o">=</span><span class="mi">0</span>
            <span class="c1">#trick for memory usage</span>
            <span class="k">if</span> <span class="n">leA</span> <span class="o">&gt;</span> <span class="mf">1e4</span><span class="p">:</span>
                <span class="n">nsp</span> <span class="o">=</span> <span class="n">nb_split</span><span class="p">(</span><span class="n">leA</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nsp</span> <span class="o">!=</span> <span class="n">leA</span><span class="p">:</span>
                    <span class="n">lA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">nsp</span><span class="p">)</span>
                    <span class="n">ly</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">nsp</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">A</span>
                    <span class="k">del</span> <span class="n">y</span>
                    <span class="k">print</span> <span class="n">nsp</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsp</span><span class="p">):</span>

                        <span class="n">lm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">lA</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">ly</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">lm</span><span class="p">))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">lm</span>
                    <span class="k">del</span> <span class="n">lm</span>
                    <span class="k">del</span> <span class="n">lA</span>
                    <span class="k">del</span> <span class="n">ly</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">m</span><span class="p">[:,</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span><span class="n">m</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

            <span class="n">dM</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ninter</span><span class="p">:</span><span class="n">M</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">dM</span></div>


<span class="k">class</span> <span class="nc">Signature</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; class Signature</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    seq : list  of interaction point (edges (&gt;0)  or vertices (&lt;0) [int]</span>
<span class="sd">    typ : list of interaction type 1-R 2-T 3-D  [int]</span>
<span class="sd">    pa  : tail point of interaction segment (2xN) ndarray</span>
<span class="sd">    pb  : head point of interaction segment (2xN) ndarray</span>
<span class="sd">    pc  : center point of interaction segment (2xN) ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Signature.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.__init__.html#pylayers.antprop.signature.Signature.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sig : nd.array or list of interactions</span>

<span class="sd">        &gt;&gt;&gt; seq = np.array([[1,5,1],[1,1,1]])</span>
<span class="sd">        &gt;&gt;&gt; s = Signature(seq)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">typinter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">seginter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">seginter</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">typinter</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Signature.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.__repr__.html#pylayers.antprop.signature.Signature.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="Signature.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.info.html#pylayers.antprop.signature.Signature.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="Signature.ev2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.ev2.html#pylayers.antprop.signature.Signature.ev2">[docs]</a>    <span class="k">def</span> <span class="nf">ev2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature. At that level the coordinates of extremities (tx and rx) is</span>
<span class="sd">        not known yet.</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>
<span class="sd">        pc  the center of segment (2xN)</span>

<span class="sd">        norm normal to the segment if segment</span>
<span class="sd">        in case the interaction is a point the normal is undefined and then</span>
<span class="sd">        set to 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">seqpointa</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nor1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nor1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nor1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pa</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">pc</span><span class="p">,</span><span class="n">norm</span><span class="p">)))</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">seqpointa</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">6</span><span class="p">:,:]</span></div>


<div class="viewcode-block" id="Signature.evf"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.evf.html#pylayers.antprop.signature.Signature.evf">[docs]</a>    <span class="k">def</span> <span class="nf">evf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature (fast version)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature.</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c1"># tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c1"># head</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># segment</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>      <span class="c1"># node</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span></div>

<div class="viewcode-block" id="Signature.ev"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.ev.html#pylayers.antprop.signature.Signature.ev">[docs]</a>    <span class="k">def</span> <span class="nf">ev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature.</span>

<span class="sd">        At that stage coordinates of extremities (tx and rx) is</span>
<span class="sd">        not known yet</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>
<span class="sd">        pc  the center of segment (2xN)</span>

<span class="sd">        norm normal to the segment if segment</span>
<span class="sd">        in case the interaction is a point the normal is undefined and then</span>
<span class="sd">        set to 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO : use map and filter instead of for loop</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c1"># tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c1"># head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c1"># center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># segment</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">norm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">norm1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>      <span class="c1"># node</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span></div>

<div class="viewcode-block" id="Signature.unfold"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.unfold.html#pylayers.antprop.signature.Signature.unfold">[docs]</a>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; unfold a given signature</span>

<span class="sd">        returns 2 np.ndarray of pta and phe &quot;aligned&quot;</span>
<span class="sd">        reflexion interactions are mirrored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pta : np.array</span>
<span class="sd">        phe : np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lensi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>
        <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>

        <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">mirror</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">lensi</span><span class="p">):</span>

            <span class="n">pam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pbm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># R</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mirror</span><span class="p">:</span>
                    <span class="n">pam</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">pbm</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pbm</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                <span class="n">pta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pam</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">phe</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">mirror</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">:</span> <span class="c1"># T</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mirror</span><span class="p">:</span>
                    <span class="n">pam</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">pbm</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pbm</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                <span class="n">pta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pam</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">phe</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span> <span class="c1"># D</span>
                <span class="k">pass</span>
                <span class="c1"># TODO not implemented yet</span>

        <span class="k">return</span> <span class="n">pta</span><span class="p">,</span><span class="n">phe</span></div>

<div class="viewcode-block" id="Signature.evtx"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.evtx.html#pylayers.antprop.signature.Signature.evtx">[docs]</a>    <span class="k">def</span> <span class="nf">evtx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; evaluate transmitter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L  : Layout</span>
<span class="sd">        tx : np.array (2xN)</span>
<span class="sd">        rx : np.array (2xM)</span>

<span class="sd">        DEPRECATED</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">norm1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">norm1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">pb</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])))</span>
        <span class="c1">#</span>
        <span class="c1">#  vecteur entre deux points adjascents de la signature</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">u1</span> <span class="o">*</span> <span class="n">u2</span><span class="p">)</span></div>
        <span class="c1">#return(vn)</span>
        <span class="c1">#return(typ)</span>


<div class="viewcode-block" id="Signature.image"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.image.html#pylayers.antprop.signature.Signature.image">[docs]</a>    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; compute the tx&#39;s images with respect to the signature segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx : numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        M : numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span>
        <span class="n">pab</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pab</span> <span class="o">*</span> <span class="n">pab</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">zalpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">alpha</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">[</span><span class="n">zalpha</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>

        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>
        <span class="c1"># number of interactions</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pa</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># detect diffraction</span>
        <span class="n">usig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">usig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">usig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># detect transmission</span>
        <span class="n">tsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#blocks[tsig, :, :] = np.zeros((2, 2))</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">tsig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># detect reflexion</span>
        <span class="n">rsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">rsig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">rsig</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">fill_block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vc0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">tx</span><span class="p">)</span> <span class="o">+</span> <span class="n">vc0</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1">#y[2 * (i + 1):2 * (i + 1) + 2] = y[2*i:2*i+2]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">M</span></div>

    <span class="k">def</span> <span class="nf">backtrace_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; backtrace given image, tx, and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx :  ndarray (2x1)</span>
<span class="sd">              transmitter</span>
<span class="sd">        rx :  ndarray (2x1)</span>
<span class="sd">              receiver</span>
<span class="sd">        M  :  ndarray (2xN)</span>
<span class="sd">              N image points obtained using self.image method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        isvalid : bool</span>
<span class="sd">            True if the backtrace ends successfully</span>

<span class="sd">        Y : ndarray (2 x (N+2))</span>
<span class="sd">            sequence of points corresponding to the seek ray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.antprop.signature import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout()</span>
<span class="sd">            &gt;&gt;&gt; L.dumpr()</span>
<span class="sd">            &gt;&gt;&gt; seq = np.array([[1,5,1],[1,1,1]])</span>
<span class="sd">            &gt;&gt;&gt; s = Signature(seq)</span>
<span class="sd">            &gt;&gt;&gt; tx = np.array([4,-1])</span>
<span class="sd">            &gt;&gt;&gt; rx = np.array([1,1])</span>
<span class="sd">            &gt;&gt;&gt; s.ev(L)</span>
<span class="sd">            &gt;&gt;&gt; M = s.image(tx)</span>
<span class="sd">            &gt;&gt;&gt; isvalid,Y = s.backtrace(tx,rx,M)</span>
<span class="sd">            &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">            &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">            &gt;&gt;&gt; l1 = ax.plot(tx[0],tx[1],&#39;or&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l2 = ax.plot(rx[0],rx[1],&#39;og&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l3 = ax.plot(M[0,:],M[1,:],&#39;ob&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l4 = ax.plot(Y[0,:],Y[1,:],&#39;xk&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ray = np.hstack((np.hstack((tx.reshape(2,1),Y)),rx.reshape(2,1)))</span>
<span class="sd">            &gt;&gt;&gt; l5 = ax.plot(ray[0,:],ray[1,:],color=&#39;#999999&#39;,alpha=0.6,linewidth=0.6)</span>
<span class="sd">            &gt;&gt;&gt; fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For mathematical details see :</span>

<span class="sd">        @INPROCEEDINGS{6546704,</span>
<span class="sd">        author={Laaraiedh, Mohamed and Amiot, Nicolas and Uguen, Bernard},</span>
<span class="sd">        booktitle={Antennas and Propagation (EuCAP), 2013 7th European Conference on},</span>
<span class="sd">        title={Efficient ray tracing tool for UWB propagation and</span>
<span class="sd">               localization modeling},</span>
<span class="sd">        year={2013},</span>
<span class="sd">        pages={2307-2311},}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#import ipdb</span>
        <span class="c1">#pdb.set_trace()</span>
        <span class="c1">#import pdb</span>

        <span class="n">pa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pa</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">I2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">pkm1</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">pkm1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>          <span class="c1"># interaction counter</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>      <span class="c1"># to enter into the loop</span>
        <span class="n">isvalid</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># signature is asumed being valid by default</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span>
        <span class="c1"># if tuple(self.seq) == ( 42, -277,  135,   21,   46,  319):</span>
        <span class="c1">#     import ipdb</span>
        <span class="c1">#     ipdb.set_trace()</span>
        <span class="c1"># while (((beta &lt;= 1) &amp; (beta &gt;= 0)) &amp; (k &lt; N)):</span>
        <span class="k">while</span> <span class="p">(((</span><span class="n">beta</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">-</span><span class="n">epsilon</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;=</span> <span class="n">epsilon</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)):</span>
            <span class="c1">#if int(typ[k]) != 1: # not a diffraction (surprisingly it works)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># not a diffraction</span>
                <span class="c1"># Formula (25) of paper Eucap 2013</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I2</span><span class="p">,</span> <span class="n">pkm1</span> <span class="o">-</span> <span class="n">M</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">z0</span><span class="p">))</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I2</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span>
                                <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                                <span class="n">pb</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="p">))</span>
                <span class="c1"># print pkm1</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span>
                <span class="n">yk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pkm1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

                <span class="n">deT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">deT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-15</span><span class="p">:</span>
                    <span class="k">return</span><span class="p">(</span><span class="bp">False</span><span class="p">,(</span><span class="n">k</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">yk</span><span class="p">)</span>
                <span class="n">pkm1</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">gk</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="mi">2</span><span class="p">::]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">gk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">gk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">pkm1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># dummy necessary for the test below</span>
                <span class="c1"># fixing #210</span>
                <span class="c1">#Y = np.hstack((Y, pa[:, k].reshape((2, 1))))</span>
                <span class="c1">#pkm1 = pa[:, k].reshape((2, 1))</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
                <span class="n">pkm1</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))):</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">isvalid</span><span class="p">,</span><span class="n">Y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isvalid</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">isvalid</span><span class="p">,(</span><span class="n">k</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>






<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
    <span class="k">print</span> <span class="s2">&quot;testing pylayers/antprop/signature.py&quot;</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
    <span class="k">print</span> <span class="s2">&quot;-------------------------------------&quot;</span>
</pre></div>

          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>
  

    <div class="footer">
        &copy; 2016, PyLayers developer team.
      Last updated on Aug 30, 2016.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5a0. Design by <a href="http://desgrana.es">Desgrana</a>.
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../../../py-modindex.html">
        Previous
      </a>  
    </div>
    
     </div>
     <script type="text/javascript">
       $("div.buttonNext, div.buttonPrevious").hover(
           function () {
               $(this).css('background-color', '#AFFFFF');
           },
           function () {
               $(this).css('background-color', '#AFFFFF');
           }
       );
     </script>
  </body>
</html>