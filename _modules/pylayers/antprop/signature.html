<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pylayers.antprop.signature &mdash; PyLayers</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="PyLayers" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
    PyLayers
<!--
<a href="../../../index.html"><img src="../../../_static/logo.png" height="200" border="0"
    alt="pylayers"/></a>
-->
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">PyLayers Home </a> |&nbsp;</li>
        <li><a href="../../../notebook/index.html">Documentation </a> |&nbsp;</li>
        <li><a href="../../../download.html">Download </a> |&nbsp; </li>
        <li><a href="https://github.com/pylayers/">Developer (Github)</a> </li>

          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pylayers.antprop.signature</h1><div class="highlight"><pre>
<span class="c">#-*- coding:Utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class Signatures</span>
<span class="sd">================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Signatures.__init__</span>
<span class="sd">    Signatures.__repr__</span>
<span class="sd">    Signatures.__len__</span>
<span class="sd">    Signatures.num</span>
<span class="sd">    Signatures.info</span>
<span class="sd">    Signatures.save</span>
<span class="sd">    Signatures.load</span>
<span class="sd">    Signatures.sp</span>
<span class="sd">    Signatures.procone</span>
<span class="sd">    Signatures.propaths</span>
<span class="sd">    Signatures.propaths2</span>
<span class="sd">    Signatures.procone2</span>
<span class="sd">    Signatures.calsig</span>
<span class="sd">    Signatures.run</span>
<span class="sd">    Signatures.run1</span>
<span class="sd">    Signatures.run4</span>
<span class="sd">    Signatures.run5</span>
<span class="sd">    Signatures.run2</span>
<span class="sd">    Signatures.run3</span>
<span class="sd">    Signatures.meta</span>
<span class="sd">    Signatures.lineofcycle</span>
<span class="sd">    Signatures.cones</span>
<span class="sd">    Signatures.unfold</span>
<span class="sd">    Signatures.show</span>
<span class="sd">    Signatures.showi</span>
<span class="sd">    Signatures.rays</span>

<span class="sd">Class Signature</span>
<span class="sd">===============</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    Signature.__init__</span>
<span class="sd">    Signature.__repr__</span>
<span class="sd">    Signature.info</span>
<span class="sd">    Signature.split</span>
<span class="sd">    Signature.ev2</span>
<span class="sd">    Signature.evf</span>
<span class="sd">    Signature.ev</span>
<span class="sd">    Signature.unfold</span>
<span class="sd">    Signature.evtx</span>
<span class="sd">    Signature.image</span>
<span class="sd">    Signature.backtrace</span>
<span class="sd">    Signature.sig2beam</span>
<span class="sd">    Signature.sig2ray</span>

<span class="sd">Utility functions</span>
<span class="sd">=================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated/</span>

<span class="sd">    showsig</span>
<span class="sd">    gidl</span>
<span class="sd">    frontline</span>
<span class="sd">    edgeout2</span>
<span class="sd">    edgeout</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="c">#import scipy as sp</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="kn">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="kn">as</span> <span class="nn">shg</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">pylayers.gis.layout</span> <span class="kn">as</span> <span class="nn">layout</span>
<span class="kn">import</span> <span class="nn">pylayers.util.geomutil</span> <span class="kn">as</span> <span class="nn">geu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.cone</span> <span class="kn">as</span> <span class="nn">cone</span>
<span class="c">#import pylayers.util.graphutil as gph</span>
<span class="kn">import</span> <span class="nn">pylayers.util.pyutil</span> <span class="kn">as</span> <span class="nn">pyu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.plotutil</span> <span class="kn">as</span> <span class="nn">plu</span>
<span class="kn">from</span> <span class="nn">pylayers.antprop.rays</span> <span class="kn">import</span> <span class="n">Rays</span>
<span class="kn">from</span> <span class="nn">pylayers.util.project</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="c">#from numba import autojit</span>

<div class="viewcode-block" id="showsig"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.showsig.html#pylayers.antprop.signature.showsig">[docs]</a><span class="k">def</span> <span class="nf">showsig</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">tx</span><span class="o">=</span><span class="p">[],</span><span class="n">rx</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot; show signature</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L  : Layout</span>
<span class="sd">    s  :</span>
<span class="sd">    tx :</span>
<span class="sd">    rx :</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;thin&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">showGs</span><span class="p">()</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;thin&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;edlabel&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">L</span><span class="o">.</span><span class="n">showGs</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">edlist</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tx</span> <span class="o">!=</span><span class="p">[]:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rx</span> <span class="o">!=</span><span class="p">[]:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">rx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">L</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s">&#39;edlabel&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">False</span>

</div>
<div class="viewcode-block" id="gidl"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.gidl.html#pylayers.antprop.signature.gidl">[docs]</a><span class="k">def</span> <span class="nf">gidl</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; gi without diffraction</span>

<span class="sd">   Returns</span>
<span class="sd">   -------</span>

<span class="sd">   gr</span>

<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">edlist</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">pos</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">edlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">gr</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">edlist</span><span class="p">)</span>
    <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">g</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edlist</span><span class="p">}</span>
    <span class="n">gr</span><span class="o">.</span><span class="n">pos</span><span class="o">=</span><span class="n">dpos</span>
    <span class="k">return</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="frontline"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.frontline.html#pylayers.antprop.signature.frontline">[docs]</a><span class="k">def</span> <span class="nf">frontline</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">nc</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; determine cycle frontline</span>

<span class="sd">    This function calculates the scalar product of the normals of a cycle </span>
<span class="sd">    and returns the indev of segments whith are facing the given direction v.</span>
<span class="sd">    scalar product &lt; 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L : Layout</span>
<span class="sd">    nc : cycle number</span>
<span class="sd">    v : direction vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    nsegf : list</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>

<span class="sd">    &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">    &gt;&gt;&gt; L = Layout()</span>
<span class="sd">    &gt;&gt;&gt; L.dumpr()</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([1,1])</span>
<span class="sd">    &gt;&gt;&gt; frontline(L,0,v)</span>
<span class="sd">    [3, 4]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    run3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npt</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>  <span class="c"># points</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span> <span class="c"># segments</span>
    <span class="n">pt</span>  <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">npt</span> <span class="p">:</span> <span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span><span class="n">npt</span><span class="p">)</span>
    <span class="n">pt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>   <span class="c"># convert in ndarray</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Lr2n</span><span class="p">(</span><span class="n">pt1</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c"># get the normals of the cycle</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">v</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c"># scalar product with vector v</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ps</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>   <span class="c"># keep segment if scalar product &lt;0</span>
    <span class="n">nsegf</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">nseg</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nsegf</span>

</div>
<div class="viewcode-block" id="edgeout2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.edgeout2.html#pylayers.antprop.signature.edgeout2">[docs]</a><span class="k">def</span> <span class="nf">edgeout2</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; filter authorized Gi edges output</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L : Layout</span>
<span class="sd">    g : Digraph Gi</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">    This function checks that this sequence is feasible</span>
<span class="sd">    , whatever the type of nstr0 and nstr1.</span>
<span class="sd">    The feasible outputs from nstr0 to nstr1 are stored in an output field of</span>
<span class="sd">    edge (nstr0,nstr1)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># loop over all edges of Gi</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="c"># extract  both termination interactions nodes</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># list of authorized outputs, initialized void</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># nstr1 : segment number of final interaction</span>
        <span class="k">if</span> <span class="n">nstr1</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">pseg1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">nstr1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nstr0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">pseg0</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">nstr0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="c"># test if nstr0 and nstr1 are connected segments</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">nstr0</span><span class="p">),</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">nstr1</span><span class="p">)))</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                    <span class="c"># not connected</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># connected</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">from2csegs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr0</span><span class="p">])</span>
                <span class="n">cn</span><span class="o">.</span><span class="n">fromptseg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>

            <span class="c"># list all potential successor of interaction i1</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
            <span class="n">ipoints</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">,</span><span class="n">i2</span><span class="p">)</span>
            <span class="c">#istup = filter(lambda x : type(eval(x))==tuple,i2)</span>
            <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="n">i2</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isegments</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">isegments</span><span class="p">)</span>
                <span class="n">pta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span>
                <span class="n">phe</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">:,:]</span>
                <span class="c">#print points</span>
                <span class="c">#print segments</span>
                <span class="c">#cn.show()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="n">bs</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span><span class="n">phe</span><span class="p">)</span>
                    <span class="c">#if bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                    <span class="c">#if ~bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;k&#39;)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">Mpta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">Mphe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pseg1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">bs</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">Mpta</span><span class="p">,</span><span class="n">Mphe</span><span class="p">)</span>
                    <span class="c">#print i0,i1</span>
                    <span class="c">#if ((i0 == (6, 0)) &amp; (i1 == (7, 0))):</span>
                    <span class="c">#    pdb.set_trace()</span>
                    <span class="c">#if bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                    <span class="c">#if ~bs.any():</span>
                    <span class="c">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;m&#39;)</span>
                    <span class="c">#    plt.show()</span>
                    <span class="c">#    pdb.set_trace()</span>

                <span class="n">isegkeep</span> <span class="o">=</span> <span class="n">isegments</span><span class="p">[</span><span class="n">bs</span><span class="p">]</span>
                <span class="n">output</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isegkeep</span> <span class="p">,</span><span class="n">i2</span><span class="p">)</span>
                <span class="c"># keep all segment above nstr1 and in Cone if T</span>
                <span class="c"># keep all segment below nstr1 and in Cone if R</span>

        <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">g</span><span class="p">)</span></div>
<div class="viewcode-block" id="edgeout"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.edgeout.html#pylayers.antprop.signature.edgeout">[docs]</a><span class="k">def</span> <span class="nf">edgeout</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; filter authorized Gi edges output </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    L : Layout</span>
<span class="sd">    g : Digraph Gi</span>

<span class="sd">    Notes </span>
<span class="sd">    -----</span>

<span class="sd">    Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">    This function checks that this sequence is feasible</span>
<span class="sd">    , whatever the type of nstr0 and nstr1.</span>
<span class="sd">    The feasible outputs from nstr0 to nstr1 are stored in an output field of </span>
<span class="sd">    edge (nstr0,nstr1)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># loop over all edges of Gi</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="c"># extract  both termination interactions nodes</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Transmission</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">typ</span><span class="o">=</span><span class="mi">2</span>
            <span class="c"># Reflexion    </span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">typ</span><span class="o">=</span><span class="mi">1</span>
        <span class="c"># Diffraction        </span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="c"># list of authorized outputs, initialized void</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># nstr1 : segment number of final interaction</span>
        <span class="k">if</span> <span class="n">nstr1</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c">#cn = cone.Cone()</span>
            <span class="c">#cn.from2segs(pseg0,pseg1)</span>
            <span class="c"># segment unitary vector</span>
            <span class="c"># l1 : unitary vector along structure segments  </span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">seguv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nstr1</span><span class="p">]))</span>
            <span class="c">#</span>
            <span class="c"># unitary vector along the ray (nstr0,nstr1)</span>
            <span class="c">#</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr0</span><span class="p">])</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr1</span><span class="p">])</span>
            <span class="n">v01</span>  <span class="o">=</span> <span class="n">p1</span><span class="o">-</span><span class="n">p0</span>
            <span class="n">v01m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v01</span><span class="p">,</span><span class="n">v01</span><span class="p">))</span>
            <span class="n">v01n</span> <span class="o">=</span> <span class="n">v01</span><span class="o">/</span><span class="n">v01m</span>
            <span class="n">v10n</span> <span class="o">=</span> <span class="o">-</span><span class="n">v01n</span>
            <span class="c"># next interaction</span>
            <span class="c"># considering all neighbors of i1 in Gi </span>
            <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">i1</span><span class="p">)):</span>

                <span class="n">i2</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
                    <span class="n">nstr2</span> <span class="o">=</span> <span class="n">i2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nstr2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr2</span><span class="p">])</span>
                <span class="n">v12</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-</span><span class="n">p1</span>
                <span class="n">v12m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span><span class="n">v12</span><span class="p">))</span>
                <span class="n">v12n</span> <span class="o">=</span> <span class="n">v12</span><span class="o">/</span><span class="n">v12m</span>

                <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v01n</span><span class="p">,</span><span class="n">l1</span><span class="p">)</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span><span class="n">v12n</span><span class="p">)</span>

                <span class="c"># if (reflexion is forward) or (reflexion return to its origin)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">d1</span><span class="o">*</span><span class="n">d2</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nstr0</span> <span class="o">==</span> <span class="n">nstr2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">typ</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
<span class="c">#                elif d1*d2&gt;=-0.2 and typ ==2:</span>
                <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&lt;</span><span class="mf">0.9</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span> <span class="o">&lt;</span><span class="mf">0.9</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="n">d1</span><span class="o">*</span><span class="n">d2</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">:</span>
                            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i0</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span><span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</div>
<span class="k">class</span> <span class="nc">Signatures</span><span class="p">(</span><span class="n">PyLayers</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; set of Signature given 2 Gt cycle (convex) indices</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    L : gis.Layout</span>
<span class="sd">    source : int</span>
<span class="sd">        source convex cycle</span>
<span class="sd">    target : int</span>
<span class="sd">        target convex cycle</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Signatures.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__init__.html#pylayers.antprop.signature.Signatures.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        source : int</span>
<span class="sd">            cycle number</span>
<span class="sd">        target : int</span>
<span class="sd">            cycle index</span>
<span class="sd">        cutoff : int</span>
<span class="sd">            limiting depth level in graph exploration (default 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>
</div>
<div class="viewcode-block" id="Signatures.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__repr__.html#pylayers.antprop.signature.Signatures.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">fun1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="s">&#39;D&#39;</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39;----------&#39;</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="c">#s = s + str(self.__sizeof__())+&#39;\n&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;from cycle : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; to cycle &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># nl x 2 x nsig</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;   &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#39;   &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.__len__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.__len__.html#pylayers.antprop.signature.Signatures.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nsig</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span><span class="p">(</span><span class="n">nsig</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.num"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.num.html#pylayers.antprop.signature.Signatures.num">[docs]</a>    <span class="k">def</span> <span class="nf">num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine the number of signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsig</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsig</span> <span class="o">+=</span> <span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nint</span> <span class="o">+=</span> <span class="n">size</span><span class="o">*</span><span class="n">k</span>
</div>
<div class="viewcode-block" id="Signatures.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.info.html#pylayers.antprop.signature.Signatures.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># print &quot;Signatures for scenario defined by :&quot;</span>
        <span class="c"># print &quot;Layout&quot;</span>
        <span class="c"># print &quot;======&quot;</span>
        <span class="c"># L = self.L.info()</span>
        <span class="c"># print &quot;================================&quot;</span>
        <span class="c"># print &quot;source : &quot;, self.source</span>
        <span class="c"># print &quot;target : &quot;, self.target</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39;----------&#39;</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="c">#s = s + str(self.__sizeof__())+&#39;\n&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">print</span> <span class="s">&#39;from cycle : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; to cycle &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s">&#39;Reflection&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">BLUE</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;  &#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s">&#39;Transmission&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">GREEN</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;  &#39;</span>
        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="s">&#39;Diffraction&#39;</span><span class="p">,</span><span class="n">pyu</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;  </span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> 
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># nl x 2 x nsig</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>

                <span class="n">nstr</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">typ</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="k">print</span> <span class="s">&#39;[&#39;</span><span class="p">,</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">BLUE</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">GREEN</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="n">pyu</span><span class="o">.</span><span class="n">printout</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">pyu</span><span class="o">.</span><span class="n">RED</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;]&#39;</span>
            <span class="k">print</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                <span class="c"># s = s + &#39;   &#39;+ str(a[i,0,:]) + &#39;\n&#39;</span>

                <span class="c"># s = s + &#39;   &#39;+ str(a[i,1,:]) + &#39;\n&#39;</span>
</div>
    <span class="k">def</span> <span class="nf">saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save signatures in hdf5 format</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>

        <span class="c"># try/except to avoid loosing the h5 file if</span>
        <span class="c"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;source&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when writting h5py file&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; load signatures hdf5 format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>

        <span class="c"># try/except to avoid loosing the h5 file if </span>
        <span class="c"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][:]})</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when reading h5py file&#39;</span><span class="p">)</span>


        <span class="n">_fileL</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.ini&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">_fileL</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save in hdf5 compliant with Links</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c"># if grpname == &#39;&#39;:</span>
        <span class="c">#     grpname = str(self.source) +&#39;_&#39;+str(self.target) +&#39;_&#39;+ str(self.cutoff)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># file management</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grpname</span> <span class="ow">in</span> <span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">grpname</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span> <span class="o">+</span><span class="s">&#39;already exists in &#39;</span><span class="o">+</span><span class="n">filenameh5</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span><span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>

            <span class="c"># write data</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;source&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span>
            <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;cutoff&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when writting h5py file&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load signatures in hdf5 format compliant with class Links</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filenameh5 : string</span>
<span class="sd">            filename of the h5py file (from Links Class)</span>
<span class="sd">        grpname : string</span>
<span class="sd">            groupname of the h5py file (from Links Class)</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.links</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c"># if grpname ==&#39;&#39;:</span>
        <span class="c">#     grpname = str(self.source) +&#39;_&#39;+str(self.target) +&#39;_&#39;+ str(self.cutoff)</span>

        <span class="c"># try/except to avoid loosing the h5 file if</span>
        <span class="c"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span><span class="n">fh5</span><span class="p">[</span><span class="s">&#39;sig/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][:]})</span>
            <span class="n">Lname</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;Signature: issue when reading h5py file&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">Lname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>


<div class="viewcode-block" id="Signatures.save"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.save.html#pylayers.antprop.signature.Signatures.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
          <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">L</span>
</div>
<div class="viewcode-block" id="Signatures.load"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.load.html#pylayers.antprop.signature.Signatures.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; load signatures</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">_filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s">&#39;DIRSIG&#39;</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">sitmp</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span><span class="s">&#39; does not exist&#39;</span><span class="p">)</span>


        <span class="c"># to load a dictionary, use update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sitmp</span><span class="p">)</span>


        <span class="n">_fileL</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.ini&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span><span class="n">layout</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">_fileL</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpr</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Signatures.sp"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.sp.html#pylayers.antprop.signature.Signatures.sp">[docs]</a>    <span class="k">def</span> <span class="nf">sp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; algorithm for signature determination</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : Graph</span>
<span class="sd">        source : tuple or int</span>
<span class="sd">        target : tuple or int</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.antprop.signature.run3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">source</span><span class="p">])):</span>
                        <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                    <span class="c"># yield visited +[target]</span>
                <span class="k">elif</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">source</span><span class="p">])):</span>
                        <span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>


</div>
<div class="viewcode-block" id="Signatures.procone"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.procone.html#pylayers.antprop.signature.Signatures.procone">[docs]</a>    <span class="k">def</span> <span class="nf">procone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target looking backward</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c">#print &quot;child : &quot;,child</span>
            <span class="c">#print &quot;visited :&quot;,visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span> <span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point - YIELD A SIGNATURE</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="c"># output signature</span>
                <span class="k">else</span><span class="p">:</span>
                <span class="c">#elif child not in visited: # else visit other node - CONTINUE APPEND CHILD</span>
                    <span class="c"># getting signature until last point</span>
                    <span class="n">diff</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span>
                    <span class="c"># looking backward with a cone</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                        <span class="c"># warning visited is also appended visited[-2] is the</span>
                        <span class="c"># last node</span>
                        <span class="n">brin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">evf</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                        <span class="n">ta</span><span class="p">,</span><span class="n">he</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
                        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                        <span class="n">segchild</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">segvm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">segchild</span><span class="p">,</span><span class="n">segvm1</span><span class="p">)</span>
                        <span class="n">typ</span><span class="p">,</span><span class="n">proba</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">ta</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="c">#fig,ax = plu.displot(ta,he)</span>
                        <span class="c">#fig,ax = cn.show(fig=fig,ax=ax)</span>
                        <span class="c">#plt.show()</span>
                        <span class="c">#pdb.set_trace()</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c"># child no valid (do nothing)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c"># child valid (append child to visited and go forward)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

</div>
    <span class="k">def</span> <span class="nf">short_propath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; updated dijkstra</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">==</span><span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">({</span><span class="n">source</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]})</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># dictionary of final distances</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]}</span>  <span class="c"># dictionary of paths</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
        <span class="n">fringe</span><span class="o">=</span><span class="p">[]</span> <span class="c"># use heapq with (distance,label) tuples</span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">fringe</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="n">source</span><span class="p">))</span>
        <span class="n">firstloop</span><span class="o">=</span><span class="bp">True</span>
        <span class="k">while</span> <span class="n">fringe</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="n">oldv</span> <span class="o">=</span> <span class="n">v</span>
            <span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">=</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">fringe</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dist</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># already searched this node.</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c">#for ignore,w,edgedata in G.edges_iter(v,data=True):</span>
            <span class="c">#is about 30% slower than the following</span>
            <span class="k">if</span> <span class="n">firstloop</span><span class="p">:</span>
                <span class="n">edata</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">edata</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">oldv</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span><span class="n">edgedata</span> <span class="ow">in</span> <span class="n">edata</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weight</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">firstloop</span><span class="p">:</span>
                        <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">edgedata</span> 
                    <span class="k">else</span> <span class="p">:</span>
                        <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="c">#+ edgedata.get(weight,1) #&lt;= proba should be add here</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="n">vw_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vw_dist</span><span class="o">&gt;</span><span class="n">cutoff</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vw_dist</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Contradictory paths found:&#39;</span><span class="p">,</span>
                                         <span class="s">&#39;negative weights?&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">or</span> <span class="n">vw_dist</span> <span class="o">&lt;</span> <span class="n">seen</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">seen</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">vw_dist</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">fringe</span><span class="p">,(</span><span class="n">vw_dist</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
                    <span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
            <span class="n">firstloop</span><span class="o">=</span><span class="bp">False</span>


        <span class="k">if</span> <span class="n">paths</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dout</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])):</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">]])</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">[</span><span class="n">target</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">dout</span>


<div class="viewcode-block" id="Signatures.propaths"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths.html#pylayers.antprop.signature.Signatures.propaths">[docs]</a>    <span class="k">def</span> <span class="nf">propaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="c"># import ipdb</span>
        <span class="c"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c"># update number of useful segments</span>
            <span class="c"># if there is airwall in visited</span>
            <span class="c">#</span>

            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="c"># output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                    <span class="c"># only visit output nodes except if bt</span>
                    <span class="c">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="c"># check if child (current segment) is an airwall</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="k">yield</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
</div>
    <span class="k">def</span> <span class="nf">propaths3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek shortest path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Gi : graph of interactions</span>
<span class="sd">        source : source interaction</span>
<span class="sd">        target : target interaction</span>
<span class="sd">        cutoff : cutoff</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nextlevel</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="n">Gi</span><span class="p">[</span><span class="n">source</span><span class="p">]}</span>   <span class="c"># list of nodes to check at next level</span>
        <span class="n">paths</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:[</span><span class="n">source</span><span class="p">]}</span>         <span class="c"># paths dictionary  (paths to key from source)</span>

        <span class="k">while</span> <span class="n">nextlevel</span><span class="p">:</span>
            <span class="n">thislevel</span> <span class="o">=</span> <span class="n">nextlevel</span>
            <span class="n">nextlevel</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="c"># reach a node which is not in paths</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span><span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                        <span class="n">nextlevel</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                        <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">cutoff</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">):</span>  <span class="k">break</span>


<div class="viewcode-block" id="Signatures.propaths2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.propaths2.html#pylayers.antprop.signature.Signatures.propaths2">[docs]</a>    <span class="k">def</span> <span class="nf">propaths2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>
<span class="sd">        bt : bool</span>
<span class="sd">            allow backtrace (visite nodes already visited)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dout : dictionnary</span>
<span class="sd">            key : int</span>
<span class="sd">               number of interactions</span>
<span class="sd">            values : list</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>


        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>
        <span class="c"># lawp = list of airwall position in visited</span>
        <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="c"># import ipdb</span>
        <span class="c"># ipdb.set_trace()</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>

            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>

            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c"># update number of useful segments</span>
            <span class="c"># if there is airwall in visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="c">#yield visited + [target] # output signature</span>

                <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                    <span class="c"># only visit output nodes except if bt</span>
                    <span class="c">#pdb.set_trace()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dintpro</span> <span class="o">=</span><span class="p">{}</span>

                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dintpro</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="c"># check if child (current segment) is an airwall</span>
                    <span class="c"># warning not efficient if many airwalls</span>
                    <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target]</span>

                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">dout</span>

</div>
<div class="viewcode-block" id="Signatures.procone2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.procone2.html#pylayers.antprop.signature.Signatures.procone2">[docs]</a>    <span class="k">def</span> <span class="nf">procone2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="p">{},</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; seek all simple_path from source to target looking backward</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        G : networkx Graph Gi</span>
<span class="sd">        dout : dictionnary</span>
<span class="sd">            ouput dictionnary</span>
<span class="sd">        source : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        target : tuple</span>
<span class="sd">            interaction (node of Gi)</span>
<span class="sd">        cutoff : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adapted from all_simple_path of networkx</span>

<span class="sd">        1- Determine all nodes connected to Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;source :&quot;,source</span>
        <span class="c">#print &quot;target :&quot;,target</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>

        <span class="c"># stack is a list of iterators</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="c"># while the list of iterators is not void</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
            <span class="c"># children is the last iterator of stack</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># next child</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="c">#print &quot;child : &quot;,child</span>
            <span class="c">#print &quot;visited :&quot;,visited</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span> <span class="c"># if visited list length is less than cutoff</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>  <span class="c"># if child is the target point - YIELD A SIGNATURE</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target] # output signature</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                <span class="c">#elif child not in visited: # else visit other node - CONTINUE APPEND CHILD</span>
                    <span class="c"># getting signature until last point</span>
                    <span class="n">diff</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">brin</span> <span class="o">=</span> <span class="n">visited</span><span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span>
                    <span class="c"># looking backward with a cone</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                        <span class="c"># warning visited is also appended visited[-2] is the</span>
                        <span class="c"># last node</span>
                        <span class="n">brin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">brin</span><span class="p">)</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">evf</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
                        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                        <span class="n">ta</span><span class="p">,</span><span class="n">he</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>
                        <span class="n">segchild</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">segvm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ta</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">segchild</span><span class="p">,</span><span class="n">segvm1</span><span class="p">)</span>
                        <span class="n">typ</span><span class="p">,</span><span class="n">proba</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">ta</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">he</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">proba</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c"># child no valid (do nothing)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c"># child valid (append child to visited and go forward)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="c">#print visited + [target]</span>
                    <span class="c">#yield visited + [target]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dout</span>

    <span class="c"># def propaths(self,G, source, target, cutoff=1, cutprob =0.5):</span>
    <span class="c">#     &quot;&quot;&quot; seek all simple_path from source to target</span>

    <span class="c">#     Parameters</span>
    <span class="c">#     ----------</span>

    <span class="c">#     G : networkx Graph Gi</span>
    <span class="c">#     source : tuple </span>
    <span class="c">#         interaction (node of Gi) </span>
    <span class="c">#     target : tuple </span>
    <span class="c">#         interaction (node of Gi) </span>
    <span class="c">#     cutoff : int</span>

    <span class="c">#     Notes</span>
    <span class="c">#     -----</span>

    <span class="c">#     adapted from all_simple_path of networkx </span>

    <span class="c">#     1- Determine all nodes connected to Gi </span>

    <span class="c">#     &quot;&quot;&quot;</span>
    <span class="c">#     #print &quot;source :&quot;,source</span>
    <span class="c">#     #print &quot;target :&quot;,target</span>

    <span class="c">#     if cutoff &lt; 1:</span>
    <span class="c">#         return</span>

    <span class="c">#     visited = [source]</span>
    <span class="c">#     # stack is a list of iterators</span>
    <span class="c">#     stack = [iter(G[source])]</span>
    <span class="c">#     ps = [iter([1.0]*len((G[source])))] </span>
    <span class="c">#     # lawp = list of airwall position in visited</span>
    <span class="c">#     lawp = []</span>

    <span class="c">#     # while the list of iterators is not void</span>
    <span class="c">#     # import ipdb</span>
    <span class="c">#     # ipdb.set_trace()    </span>
    <span class="c">#     while stack: #</span>
    <span class="c">#         # children is the last iterator of stack</span>

    <span class="c">#         children = stack[-1]</span>
    <span class="c">#         pcd = ps[-1]</span>
    <span class="c">#         # next child</span>
    <span class="c">#         child = next(children, None)</span>
    <span class="c">#         pc = next(pcd,None)</span>
    <span class="c">#         # update number of useful segments</span>
    <span class="c">#         # if there is airwall in visited</span>
    <span class="c">#         # </span>
            
    <span class="c">#         if child is None  : # if no more child</span>
    <span class="c">#             stack.pop()   # remove last iterator</span>
    <span class="c">#             ps.pop()</span>
    <span class="c">#             visited.pop() # remove from visited list</span>
    <span class="c">#             try:</span>
    <span class="c">#                 lawp.pop()</span>
    <span class="c">#             except:</span>
    <span class="c">#                 pass</span>

    <span class="c">#         elif (pc&gt;cutprob): # check proba</span>
    <span class="c">#             if (len(visited) &lt; (cutoff + sum(lawp))):# if visited list length is less than cutoff </span>
    <span class="c">#                 if child == target:  # if child is the target point</span>
    <span class="c">#                     #print visited + [target]</span>
    <span class="c">#                     yield visited + [target] # output signature</span>
    <span class="c">#                 elif child not in visited: # else visit other node</span>
    <span class="c">#                     # only visit output nodes</span>
    <span class="c">#                     #pdb.set_trace()</span>
    <span class="c">#                     try:</span>
    <span class="c">#                         dintpro = G[visited[-1]][child][&#39;output&#39;]</span>
    <span class="c">#                     except:</span>
    <span class="c">#                         dintpro ={}</span>

    <span class="c">#                     # pnc : probability of next children</span>
    <span class="c">#                     # pc : proba of current parent</span>
    <span class="c">#                     # spnc : sum of proba of next children</span>

    <span class="c">#                     # spnc = sum(dintpro.values())</span>
    <span class="c">#                     pnc = [(v*pc) for v in dintpro.values()]</span>

    <span class="c">#                     stack.append(iter(dintpro.keys()))</span>
    <span class="c">#                     ps.append(iter(pnc))</span>
    <span class="c">#                     #stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
    <span class="c">#                     visited.append(child)</span>
    <span class="c">#                     # check if child (current segment) is an airwall</span>
    <span class="c">#                     if self.L.di[child][0] in self.L.name[&#39;AIR&#39;]:</span>
    <span class="c">#                         lawp.append(1)</span>
    <span class="c">#                     else:</span>
    <span class="c">#                         lawp.append(0)</span>


    <span class="c">#             else :</span>
    <span class="c">#                 stack.pop()</span>
    <span class="c">#                 ps.pop()</span>
    <span class="c">#                 visited.pop()</span>
    <span class="c">#                 lawp.pop()</span>

    <span class="c">#         else: #len(visited) == cutoff (visited list is too long)</span>
    <span class="c">#             if child == target or target in children:</span>
    <span class="c">#                 #print visited + [target]</span>
    <span class="c">#                 yield visited + [target]</span>

    <span class="c">#             stack.pop()</span>
    <span class="c">#             ps.pop()</span>
    <span class="c">#             visited.pop()</span>
    <span class="c">#             lawp.pop()</span>
</div>
<div class="viewcode-block" id="Signatures.calsig"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.calsig.html#pylayers.antprop.signature.Signatures.calsig">[docs]</a>    <span class="k">def</span> <span class="nf">calsig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="p">{},</span><span class="n">cutoff</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculates signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        G   : graph</span>
<span class="sd">        dia : dictionnary of interactions</span>
<span class="sd">        cutoff : integer</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">di</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dia</span><span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s">&#39;Tx&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s">&#39;Rx&#39;</span>
        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">])]</span>

        <span class="n">out</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
<span class="c">#            pdb.set_trace()</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="n">lot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
<span class="c">#                    yield visited + [target]</span>
                <span class="k">elif</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
<span class="c">#                    yield visited + [target]</span>
                    <span class="n">lot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">lot</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="n">lot</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">out</span><span class="p">)})</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
    <span class="k">def</span> <span class="nf">exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; verifies if seq exists in signatures</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        seq : list or np.array()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span><span class="n">lf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>


<div class="viewcode-block" id="Signatures.run"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run.html#pylayers.antprop.signature.Signatures.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; run signature calculation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">        dcut : int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lcil</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;run1&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run1</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;run2&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run2</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="n">dcut</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures.run1"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run1.html#pylayers.antprop.signature.Signatures.run1">[docs]</a>    <span class="k">def</span> <span class="nf">run1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dGi</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">buildGi2</span><span class="p">()</span>
        <span class="c"># all the vnodes &gt;0  from the room</span>
        <span class="c">#</span>
        <span class="c">#NroomTx = self.L.pt2ro(tx)</span>
        <span class="c">#NroomRx = self.L.pt2ro(rx)</span>
        <span class="c">#print NroomTx,NroomRx</span>

        <span class="c">#if not self.L.Gr.has_node(NroomTx) or not self.L.Gr.has_node(NroomRx):</span>
        <span class="c">#    raise AttributeError(&#39;Tx or Rx is not in Gr&#39;)</span>

        <span class="c"># list of interaction in roomTx</span>
        <span class="c"># list of interaction in roomRx</span>
        <span class="c">#ndt = self.L.Gt.node[self.L.Gr.node[NroomTx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
        <span class="c">#ndr = self.L.Gt.node[self.L.Gr.node[NroomRx][&#39;cycle&#39;]][&#39;inter&#39;]</span>

        <span class="n">metasig</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">metasig</span> <span class="o">+</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">metasig</span><span class="p">)))</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">metasig</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>

        <span class="c">#print &quot;metasig&quot;,metasig</span>

        <span class="c"># add cycles separated by air walls</span>
        <span class="n">lca</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">metasig</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lca</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">metasig</span> <span class="o">+</span> <span class="n">lca</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">metasig</span><span class="p">)))</span>

        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># source</span>
        <span class="c">#ndt1 = filter(lambda l: len(eval(l))&gt;2,ndt) # Transmission</span>
        <span class="c">#ndt2 = filter(lambda l: len(eval(l))&lt;3,ndt) # Reflexion</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">lisR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># target</span>
        <span class="c"># ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr) # Transmission</span>
        <span class="c"># ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr) # Reflexion</span>

        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">litR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># tx,rx : attaching rule</span>
        <span class="c">#</span>
        <span class="c"># tx attachs to out transmisision point</span>
        <span class="c"># rx attachs to in transmission point</span>

        <span class="c">#</span>
        <span class="c"># WARNING : room number &lt;&gt; cycle number</span>
        <span class="c">#</span>

        <span class="c">#ncytx = self.L.Gr.node[NroomTx][&#39;cycle&#39;]</span>
        <span class="c">#ncyrx = self.L.Gr.node[NroomRx][&#39;cycle&#39;]</span>

        <span class="c">#ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;ncytx,ndt1)</span>
        <span class="c">#ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;ncyrx,ndr1)</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>

        <span class="c">#ndt = ndt1 + ndt2</span>
        <span class="c">#ndr = ndr1 + ndr2</span>
        <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>
        <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>

        <span class="c">#ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        li = np.intersect1d(lis, lit)</span>

        <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">metasig</span><span class="p">:</span>
            <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ms</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">li</span><span class="p">)))</span>

        <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">li</span><span class="p">}</span>

        <span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">li</span><span class="p">)</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">dpos</span>
<span class="c">#        for meta in metasig:</span>
<span class="c">#        Gi = nx.DiGraph()</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi = nx.compose(Gi,self.L.dGi[cycle])</span>

<span class="c">#        # facultative update positions</span>
<span class="c">#        Gi.pos = {}</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi.pos.update(self.L.dGi[cycle].pos)</span>
<span class="c">#        pdb.set_trace()</span>
        <span class="c">#</span>
        <span class="c">#</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="c">#Gi = edgeout(self.L,Gi)</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">edgeout2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="c">#for interaction source  in list of source interaction </span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lis</span><span class="p">:</span>
            <span class="c">#for target interaction in list of target interaction</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lit</span><span class="p">:</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="c">#paths = list(nx.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="c">#paths = list(self.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>

                    <span class="c">#paths = [nx.shortest_path(Gi,source=s,target=t)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#paths = [[nt]]</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]]</span>
                <span class="c">### supress the followinfg loops .</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>

                    <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>

                        <span class="n">it</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#reflexion</span>
                                <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c">#transmission</span>
                                <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">2</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                        <span class="k">elif</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#diffraction</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                    <span class="c">#print sigarr</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">sigarr</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sigarr</span>
</div>
<div class="viewcode-block" id="Signatures.run4"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run4.html#pylayers.antprop.signature.Signatures.run4">[docs]</a>    <span class="k">def</span> <span class="nf">run4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo : string</span>
<span class="sd">            &#39;old&#39; | &#39;new&#39;</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># Determine meta signature</span>
        <span class="c"># this limits the number of cycles</span>

        <span class="c">#metasig = nx.neighbors(self.L.Gt,self.source)</span>
        <span class="c">#metasig = metasig + nx.neighbors(self.L.Gt,self.target)</span>
        <span class="c">#metasig = list(np.unique(np.array(metasig)))</span>
        <span class="c">#metasig = metasig + [self.source] + [self.target]</span>
        <span class="c"># add cycles separated by air walls</span>
        <span class="c">#lca=[]</span>
        <span class="c">#for cy in metasig:</span>
        <span class="c">#    try:</span>
        <span class="c">#        lca.extend(self.L.dca[cy])</span>
        <span class="c">#    except:</span>
        <span class="c">#        pass</span>
        <span class="c">#metasig = metasig + lca</span>
        <span class="c">#metasig = list(np.unique(np.array(metasig)))</span>

        <span class="c"># list of interaction source</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="c"># list of interaction target</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># source</span>
        <span class="c">#ndt1 = filter(lambda l: len(eval(l))&gt;2,ndt) # Transmission</span>
        <span class="c">#ndt2 = filter(lambda l: len(eval(l))&lt;3,ndt) # Reflexion</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">lisR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># target</span>
        <span class="c"># ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr) # Transmission</span>
        <span class="c"># ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr) # Reflexion</span>

        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Transmission</span>
        <span class="n">litR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span> <span class="c"># Reflexion</span>

        <span class="c"># tx,rx : attaching rule</span>
        <span class="c">#</span>
        <span class="c"># tx attachs to out transmisision point</span>
        <span class="c"># rx attachs to in transmission point</span>

        <span class="c">#</span>
        <span class="c"># WARNING : room number &lt;&gt; cycle number</span>
        <span class="c">#</span>

        <span class="c">#ncytx = self.L.Gr.node[NroomTx][&#39;cycle&#39;]</span>
        <span class="c">#ncyrx = self.L.Gr.node[NroomRx][&#39;cycle&#39;]</span>

        <span class="c">#ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;ncytx,ndt1)</span>
        <span class="c">#ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;ncyrx,ndr1)</span>

        <span class="n">lisT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">litT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>

        <span class="c">#ndt = ndt1 + ndt2</span>
        <span class="c">#ndr = ndr1 + ndr2</span>
        <span class="c"># list of interaction visible from source</span>
        <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>
        <span class="c"># list of interaction visible from target</span>
        <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>

        <span class="c">#ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        li = np.intersect1d(lis, lit)</span>

        <span class="c"># list of all interactions</span>
        <span class="c">#li = []</span>
        <span class="c">#for ms in metasig:</span>
        <span class="c">#    li = li + self.L.Gt.node[ms][&#39;inter&#39;]</span>
        <span class="c">#li = list(np.unique(np.array(li)))</span>
        <span class="c">#</span>
        <span class="c"># dictionnary interaction:position</span>
        <span class="c">#dpos = {k:self.L.Gi.pos[k] for k in li}</span>
        <span class="c"># extracting sub graph of Gi corresponding to metasiganture</span>
        <span class="c">#Gi = nx.subgraph(self.L.Gi,li)</span>
        <span class="c">#Gi.pos = dpos</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
<span class="c">#        for meta in metasig:</span>
<span class="c">#        Gi = nx.DiGraph()</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi = nx.compose(Gi,self.L.dGi[cycle])</span>

<span class="c">#        # facultative update positions</span>
<span class="c">#        Gi.pos = {}</span>
<span class="c">#        for cycle in metasig:</span>
<span class="c">#            Gi.pos.update(self.L.dGi[cycle].pos)</span>
<span class="c">#        pdb.set_trace()</span>
        <span class="c">#</span>
        <span class="c"># TODO : This has to be changed for handling diffraction</span>
        <span class="c"># </span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="c">#Gi = edgeout(self.L,Gi)</span>
        <span class="c">#Gi = edgeout2(self.L,Gi)</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interaction</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interaction</span>
            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="c">#paths = list(nx.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="c">#paths = list(self.all_simple_paths(Gi,source=s,target=t,cutoff=cutoff))</span>
                    <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s">&#39;new&#39;</span><span class="p">:</span>
                        <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">procone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="p">))</span>

                    <span class="c">#paths = [nx.shortest_path(Gi,source=s,target=t)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#paths = [[nt]]</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]]</span>
                <span class="c">### suppress the following loops .</span>
                <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>

                    <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="c">#print interaction + &#39;-&gt;&#39;,</span>
                        <span class="n">it</span> <span class="o">=</span> <span class="n">interaction</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#reflexion</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c">#transmission</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="mi">2</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#diffraction</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>
                    <span class="c">#print sigarr</span>
                    <span class="c">#print &#39;&#39;</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">sigarr</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sigarr</span>

</div>
<div class="viewcode-block" id="Signatures.run5"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run5.html#pylayers.antprop.signature.Signatures.run5">[docs]</a>    <span class="k">def</span> <span class="nf">run5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c"># lis=lis+lit</span>
        <span class="c"># lit=lis+lit</span>
        <span class="c">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">algo</span><span class="o">==</span><span class="s">&#39;new&#39;</span><span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">procone2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s">&#39;old&#39;</span> <span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propaths2</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="n">bt</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">algo</span> <span class="o">==</span> <span class="s">&#39;dij&#39;</span><span class="p">:</span>
                        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">short_propath</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">dout</span><span class="o">=</span><span class="n">dout</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
                        <span class="c"># dout = self.short_propath(Gi,source=t,target=s,dout=dout,cutoff=cutoff)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                        <span class="n">dout</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dout</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">adout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">dout</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
            <span class="n">shad</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">adout</span><span class="p">)</span>
            <span class="c"># manage the case of signatures with only 1 interaction</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">adout</span> <span class="o">=</span> <span class="n">adout</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="n">shad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">adout</span><span class="p">)</span>
            <span class="c"># rehape (rays * 2 , interaction)</span>
            <span class="c"># the 2 dimensions come from the signature definition :</span>
            <span class="c"># 1st row = segment index</span>
            <span class="c"># 2nd row = type of interaction</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">adout</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shad</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">shad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</div>
    <span class="k">def</span> <span class="nf">run7</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">algo</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        algo: string</span>
<span class="sd">            &#39;old&#39; : call propaths2</span>
<span class="sd">            &#39;new&#39; : call procone2</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span>   <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="c">#print &quot;source,lis :&quot;,self.source,lis</span>
        <span class="c">#print &quot;target,lit :&quot;,self.target,lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="c"># initialize dout dictionnary</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># progresss stuff...</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
                    <span class="c"># stack is a list of iterators</span>
                    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">])]</span>
                    <span class="c"># lawp = list of airwall position in visited</span>
                    <span class="n">lawp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c"># while the list of iterators is not void</span>
                    <span class="c"># import ipdb</span>
                    <span class="c"># ipdb.set_trace()</span>
                    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> <span class="c">#</span>
                        <span class="c"># children is the last iterator of stack</span>
                        <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c"># next child</span>

                        <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                        <span class="c"># update number of useful segments</span>
                        <span class="c"># if there is airwall in visited</span>
                        <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">None</span>  <span class="p">:</span> <span class="c"># if no more child</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>   <span class="c"># remove last iterator</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># remove from visited list</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">cutoff</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lawp</span><span class="p">))):</span><span class="c"># if visited list length is less than cutoff</span>
                            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>  <span class="c"># if child is the target point</span>
                                <span class="c">#print visited + [target]</span>
                                <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                                <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="c">#try:</span>
                                <span class="c">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                                <span class="c">#except:</span>
                                <span class="c">#    dout[len(path)]=[]</span>
                                <span class="c">#    dout[len(path)].append([[p[0],len(p)] for p in path])</span>
                                <span class="c">#yield visited + [target] # output signature</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bt</span><span class="p">):</span> <span class="c"># else visit other node</span>
                                <span class="c"># only visit output nodes except if bt</span>
                                <span class="c">#pdb.set_trace()</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">nexti</span>  <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">child</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                    <span class="c">#prob  = Gi[visited[-1]][child][&#39;output&#39;].values()</span>
                                    <span class="c">#nexti = map(lambda x:x[0]</span>
                                    <span class="c">#               ,filter(lambda x</span>
                                    <span class="c">#                       :x[1]&gt;threshold,zip(out,prob)))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="n">nexti</span> <span class="o">=</span> <span class="p">[]</span>

                                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nexti</span><span class="p">))</span>
                                <span class="c">#stack.append(iter(G[visited[-1]][child][&#39;output&#39;]))</span>
                                <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                                <span class="c"># check if child (current segment) is an airwall</span>
                                <span class="c"># warning not efficient if many airwalls</span>
                                <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s">&#39;AIR&#39;</span><span class="p">]:</span>
                                    <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">lawp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



                        <span class="k">else</span><span class="p">:</span> <span class="c">#len(visited) == cutoff (visited list is too long)</span>
                            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                                <span class="n">path</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
                                <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">path</span><span class="p">))</span>
                                <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">path</span><span class="p">))</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="k">except</span><span class="p">:</span>
                                    <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                                    <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                <span class="c">#print visited + [target]</span>
                                <span class="c">#yield visited + [target]</span>

                            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">lawp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>

                <span class="k">else</span><span class="p">:</span> <span class="c"># s==t</span>
                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c">#print &quot;non existing : &quot;,len(path)</span>
                        <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">run6</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">progress</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">diffraction</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cutoff : int</span>
<span class="sd">            limit the exploration of all_simple_path</span>
<span class="sd">        bt : bool</span>
<span class="sd">            backtrace (allow to visit already visited nodes in simple path algorithm)</span>
<span class="sd">        progress : bool</span>
<span class="sd">            display the time passed in the loop</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigslist :  numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.link.Dlink.eval</span>
<span class="sd">        pylayers.antprop.signature.Signatures.propath2</span>
<span class="sd">        pylayers.antprop.signature.Signatures.procone2</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">+</span><span class="s">&#39;.sig&#39;</span>

        <span class="c"># list of interactions visible from source</span>
        <span class="n">lisT</span><span class="p">,</span><span class="n">lisR</span><span class="p">,</span><span class="n">lisD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;source&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lis</span>  <span class="o">=</span> <span class="n">lisT</span> <span class="o">+</span> <span class="n">lisR</span>

        <span class="c"># list of interactions visible from target</span>
        <span class="n">litT</span><span class="p">,</span><span class="n">litR</span><span class="p">,</span><span class="n">litD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">intercy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s">&#39;target&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">diffraction</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litD</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">lit</span>  <span class="o">=</span> <span class="n">litT</span> <span class="o">+</span> <span class="n">litR</span>
        <span class="k">print</span> <span class="s">&quot;source,lis :&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">lis</span>
        <span class="k">print</span> <span class="s">&quot;target,lit :&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span><span class="n">lit</span>


        <span class="n">Gi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span>
        <span class="c">#</span>
        <span class="c"># remove diffractions from Gi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diffraction</span><span class="p">:</span>
            <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>

        <span class="n">lmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tic0</span> <span class="o">=</span> <span class="n">tic</span>
        <span class="c">#for interaction source  in list of source interactions</span>
        <span class="k">for</span> <span class="n">us</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lis</span><span class="p">):</span>
            <span class="c">#for target interaction in list of target interactions</span>
            <span class="c">#print &quot;---&gt; &quot;,s</span>

            <span class="k">for</span> <span class="n">ut</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lit</span><span class="p">):</span>
                <span class="c">#print &quot;   ---&gt; &quot;,t</span>
                <span class="c"># progress bar</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="p">:</span>

                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((((</span><span class="n">us</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lit</span><span class="p">)</span><span class="o">+</span><span class="n">ut</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">lmax</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;</span> <span class="n">pe</span><span class="p">:</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">ratio</span>
                        <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                        <span class="k">print</span> <span class="s">&#39;~</span><span class="si">%d</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ratio</span><span class="o">*</span><span class="mi">10</span><span class="p">),</span>
                        <span class="k">print</span> <span class="s">&#39;%&#39;</span><span class="p">,</span>
                        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%6.3f</span><span class="s"> </span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">toc</span><span class="o">-</span><span class="n">tic</span><span class="p">,</span> <span class="n">toc</span><span class="o">-</span><span class="n">tic0</span><span class="p">)</span>
                        <span class="n">tic</span> <span class="o">=</span> <span class="n">toc</span>

                <span class="c"># if source and target interaction are different</span>
                <span class="c"># and R | T</span>
                <span class="c">#if ((type(eval(s))==tuple) &amp; (s != t)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">nextlevel</span><span class="o">=</span><span class="p">{</span><span class="n">s</span><span class="p">:</span><span class="n">Gi</span><span class="p">[</span><span class="n">s</span><span class="p">]}</span>   <span class="c"># list of nodes to check at next level</span>
                    <span class="n">paths</span><span class="o">=</span><span class="p">{</span><span class="n">s</span><span class="p">:[</span><span class="n">s</span><span class="p">]}</span>         <span class="c"># paths dictionary  (paths to key from source)</span>

                    <span class="n">getout</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">while</span> <span class="n">nextlevel</span><span class="p">:</span>
                        <span class="n">thislevel</span> <span class="o">=</span> <span class="n">nextlevel</span>
                        <span class="n">nextlevel</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">thislevel</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                                <span class="c"># reach a node which is not in paths</span>
                                <span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
                                <span class="n">out</span>  <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                <span class="n">prob</span> <span class="o">=</span> <span class="n">Gi</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="s">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                                <span class="n">nextlevel</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                                   <span class="p">,</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span>
                                                           <span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.6</span><span class="p">,</span><span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">prob</span><span class="p">)))</span>
                                <span class="c"># get to target</span>
                                <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                                    <span class="n">typ</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">paths</span><span class="p">[</span><span class="n">w</span><span class="p">]))</span>
                                    <span class="n">getout</span> <span class="o">=</span> <span class="bp">True</span>
                                    <span class="c">#del(paths[w])</span>
                                    <span class="k">try</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)],</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                                    <span class="k">except</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span><span class="n">typ</span><span class="p">))</span>
                        <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="o">+</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">cutoff</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">):</span>  <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="c">#try:</span>
                    <span class="c">#    if [s[0],len(s)] not in dout[1]:</span>
                    <span class="c">#        dout[1].append([s[0],len(s)])</span>
                    <span class="c">#except:</span>
                    <span class="c">#    dout[1]=[]</span>
                    <span class="c">#    dout[1].append([s[0],len(s)])</span>

<div class="viewcode-block" id="Signatures.run2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run2.html#pylayers.antprop.signature.Signatures.run2">[docs]</a>    <span class="k">def</span> <span class="nf">run2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            cutoff : limit the exploration of all_simple_path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">            sigslist = numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="c">#        try:</span>
<span class="c">#            self.L.dGi</span>
<span class="c">#        except:</span>
<span class="c">#            self.L.buildGi2()</span>

        <span class="c"># all the vnodes &gt;0  from the room</span>
        <span class="c">#</span>
        <span class="c">#NroomTx = self.L.pt2ro(tx)</span>
        <span class="c">#NroomRx = self.L.pt2ro(rx)</span>
        <span class="c">#print NroomTx,NroomRx</span>

        <span class="c">#if not self.L.Gr.has_node(NroomTx) or not self.L.Gr.has_node(NroomRx):</span>
        <span class="c">#    raise AttributeError(&#39;Tx or Rx is not in Gr&#39;)</span>

        <span class="c"># list of interaction in roomTx</span>
        <span class="c"># list of interaction in roomRx</span>
        <span class="c">#ndt = self.L.Gt.node[self.L.Gr.node[NroomTx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
        <span class="c">#ndr = self.L.Gt.node[self.L.Gr.node[NroomRx][&#39;cycle&#39;]][&#39;inter&#39;]</span>


<span class="c">#        lisT = filter(lambda l: len(eval(l))&gt;2,lis) # Transmission</span>
<span class="c">#        lisR = filter(lambda l: len(eval(l))&lt;3,lis) # Reflexion</span>

<span class="c">#        # target</span>
<span class="c">#        # ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr) # Transmission</span>
<span class="c">#        # ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr) # Reflexion</span>

<span class="c">#        litT = filter(lambda l: len(eval(l))&gt;2,lit) # Transmission</span>
<span class="c">#        litR = filter(lambda l: len(eval(l))&lt;3,lit) # Reflexion</span>

<span class="c">#        # tx,rx : attaching rule</span>
<span class="c">#        #</span>
<span class="c">#        # tx attachs to out transmisision point</span>
<span class="c">#        # rx attachs to in transmission point</span>

<span class="c">#        #</span>
<span class="c">#        # WARNING : room number &lt;&gt; cycle number</span>
<span class="c">#        #</span>

<span class="c">#        #ncytx = self.L.Gr.node[NroomTx][&#39;cycle&#39;]</span>
<span class="c">#        #ncyrx = self.L.Gr.node[NroomRx][&#39;cycle&#39;]</span>

<span class="c">#        #ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;ncytx,ndt1)</span>
<span class="c">#        #ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;ncyrx,ndr1)</span>

<span class="c">#        lisT = filter(lambda l: eval(l)[2]&lt;&gt;self.source,lisT)</span>
<span class="c">#        litT = filter(lambda l: eval(l)[1]&lt;&gt;self.target,litT)</span>

<span class="c">#        #ndt = ndt1 + ndt2</span>
<span class="c">#        #ndr = ndr1 + ndr2</span>
<span class="c">#        lis  = lisT + lisR</span>
<span class="c">#        lit  = litT + litR</span>

<span class="c">#        #ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        li = np.intersect1d(lis, lit)</span>


<span class="c">#        for meta in metasig:</span>
<span class="c">#            Gi = nx.DiGraph()</span>
<span class="c">#            for cycle in meta:</span>
<span class="c">#                Gi = nx.compose(Gi,self.L.dGi[cycle])</span>
<span class="c">#            # facultative update positions</span>
<span class="c">#            Gi.pos = {}</span>
<span class="c">#            for cycle in meta:</span>
<span class="c">#                Gi.pos.update(self.L.dGi[cycle].pos)</span>
<span class="c">#            #</span>
<span class="c">#            #</span>
<span class="c">#            #</span>
<span class="c">#        metasig=self.lineofcycle(cs,ct)</span>

<span class="c">############################################################</span>
<span class="c">##</span>
<span class="c">##      1. the sequence of cycle between cycle source cs and</span>
<span class="c">##      cycle target ct are obtained via cycleinline method</span>
<span class="c">##</span>
<span class="c">##      2. all cycles adjscent at least to one of the previously</span>
<span class="c">##      obtained cycles are appended to the list lca (list of cycle around)</span>
<span class="c">##</span>
<span class="c">##      3. It is then required to add all cycles</span>
<span class="c">##      connected to the previous ones via an air wall.</span>
<span class="c">##</span>
<span class="c">##      lca is used to build the sliding graph of interactions</span>
<span class="c">##      it is important that lcil remains ordered this is not the case</span>
<span class="c">##      for lca</span>



        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="n">lcil</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># list of cycle around</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
            <span class="n">ncy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="n">cy</span><span class="p">)</span>
            <span class="n">lca</span> <span class="o">=</span> <span class="n">lca</span><span class="o">+</span><span class="n">ncy</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lca</span><span class="p">)))</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="n">lcil</span>
        <span class="n">lcair</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lca</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lcair</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="n">lca</span> <span class="o">+</span> <span class="n">lcair</span>
        <span class="n">lca</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lca</span><span class="p">)))</span>
        <span class="c">#</span>
        <span class="c"># extract list of interactions from list of cycles lca</span>
        <span class="c">#</span>
        <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="n">lca</span><span class="p">:</span>
            <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ms</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="c"># enforce unicity of interactions in list li</span>
        <span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">li</span><span class="p">)))</span>

        <span class="c"># extract dictionnary of interactions position</span>
        <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">li</span><span class="p">}</span>

        <span class="c"># build the subgraph of L.Gi with only the selected interactions</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">li</span><span class="p">)</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">dpos</span>

        <span class="n">Gf</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># remove diffractions points from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">edgeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c">#for interaction source  in list of source interaction</span>

<span class="c">############################################################</span>
<span class="c">#        filter list of interactions in termination cycles</span>

        <span class="c"># list of interactions belonging to source</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># list of interactions belonging to target</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># filter lis remove transmission coming from outside</span>
        <span class="n">lli</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lisR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisTo</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="n">cs</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">lli</span> <span class="o">=</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisTo</span>
        <span class="c"># for li in lis:</span>
        <span class="c">#     ei = eval(li)</span>
        <span class="c">#     if len(ei)==2:</span>
        <span class="c">#        lli.append(li)</span>
        <span class="c">#    if len(ei)==3:</span>
        <span class="c">#        if ei[2]&lt;&gt;cs:</span>
        <span class="c">#           lli.append(li)</span>
        <span class="c"># filter lit remove transmission going outside</span>
        <span class="n">llt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">litR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litTi</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">ct</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>
        <span class="n">llt</span> <span class="o">=</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litTi</span>
        <span class="c">#for li in lit:</span>
        <span class="c">#    ei = eval(li)</span>
        <span class="c">#    if len(ei)==2:</span>
        <span class="c">#        llt.append(li)</span>
        <span class="c">#    if len(ei)==3:</span>
        <span class="c">#        if ei[2]==ct:</span>
        <span class="c">#           llt.append(li)</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="n">lli</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="n">llt</span>


<span class="c">#################################################</span>
<span class="c">#       propaths (a.k.a. all simple path) per adjacent cycles along cycles in line</span>
<span class="c">#       Obtaining Gf: filtred graph of Gi with Gc ( rename Gt in Gc )</span>

        <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">lsource</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ltarget</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">linter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
            <span class="c"># determine list of sources</span>
            <span class="k">if</span> <span class="n">ic</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">]][</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;segment&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
                    <span class="n">lsource</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">lis</span>

            <span class="c"># determine list of targets</span>
            <span class="k">if</span> <span class="n">ic</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c">#if ic+3 &lt; len(lcil)-1:</span>
                <span class="n">lt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">]][</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">2</span><span class="p">]][</span><span class="s">&#39;segment&#39;</span><span class="p">]</span>
                <span class="c">#lt = self.L.Gt[lcil[ic+2]][lcil[ic+3]][&#39;segment&#39;]</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">lt</span><span class="p">:</span>
                    <span class="n">ltarget</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">target</span> <span class="p">,</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">2</span><span class="p">])))</span>
                    <span class="c">#ltarget.append(str((target , lcil[ic+2], lcil[ic+3])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">lit</span>

            <span class="n">lt</span>   <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">linter</span><span class="p">)</span>
            <span class="c">#lti = filter(lambda l: eval(l)[2]==lcil[ic+1],lt)</span>
            <span class="n">lto</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span><span class="n">lt</span><span class="p">)</span>
            <span class="n">ltom</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">lto</span><span class="p">)</span>
            <span class="n">ltomp</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">ltom</span><span class="p">)</span>

            <span class="n">lsource</span> <span class="o">=</span> <span class="n">lsource</span> <span class="o">+</span> <span class="n">ltomp</span>
            <span class="c">#pdb.set_trace()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lsource</span> <span class="p">:</span>
                <span class="c">#print s</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ltarget</span><span class="p">:</span>
                    <span class="c">#print t</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">itm1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">itm1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">itm1</span><span class="p">)</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="k">if</span> <span class="n">it</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">itm1</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
                            <span class="n">itm1</span> <span class="o">=</span> <span class="n">it</span>
<span class="c">#                        else:</span>
<span class="c">#                            #paths = [[nt]]</span>
<span class="c">#                            paths = [[s]]</span>


<span class="c">################################################################</span>
<span class="c">#       Obtain position of centroid of cycles source and target</span>


        <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Tx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pcs</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Rx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pct</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="c"># a =[ 0,  1,  2,  1,  4,  1,  6,  1,  8,  1, 10, 1]</span>
        <span class="c"># aa = np.array(a)</span>
        <span class="c"># X=aa.reshape((2,3,2)) # r x i x 2</span>
        <span class="c"># Y=X.swapaxes(0,2) # 2 x i x r</span>



        <span class="bp">self</span><span class="o">.</span><span class="n">Gf</span> <span class="o">=</span> <span class="n">Gf</span>
        <span class="k">print</span> <span class="s">&#39;signatures&#39;</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calsig</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">di</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">co</span><span class="o">+</span><span class="n">dcut</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">:</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">ns</span><span class="o">/</span><span class="n">k</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">nbi</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nbi</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>


        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span>
            <span class="n">a</span><span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">nbr</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbr</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.run3"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.run3.html#pylayers.antprop.signature.Signatures.run3">[docs]</a>    <span class="k">def</span> <span class="nf">run3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dcut</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get signatures (in one list of arrays) between tx and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            cutoff : limit the exploration of all_simple_path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">            sigslist = numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

<span class="c">############################################################</span>
<span class="c">##</span>
<span class="c">##      1. the sequence of cycle between cycle source cs and</span>
<span class="c">##      cycle target ct are obtained via cycleinline method</span>
<span class="c">##</span>
<span class="c">##      2. all cycles adjscent at least to one of the previously</span>
<span class="c">##      obtained cycles are appended to the list lca (list of cycle around)</span>
<span class="c">##</span>
<span class="c">##      3. It is then required to add all cycles</span>
<span class="c">##      connected to the previous ones via an air wall.</span>
<span class="c">##</span>
<span class="c">##      lca is used to build the sliding graph of interactions</span>
<span class="c">##      it is important that lcil remains ordered this is not the case</span>
<span class="c">##      for lca</span>

        <span class="c"># cs : cycle source</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="c"># ct : cycle target</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="c"># cps : centroid point source</span>
        <span class="n">cps</span> <span class="o">=</span> <span class="n">polys</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">polyt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="c"># cpt : centroid point target</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="n">polyt</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cps</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cpt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cpt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-</span><span class="n">ps</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">mv</span>
        <span class="n">lcil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">cycleinline</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="n">ct</span><span class="p">)</span>

        <span class="c"># dac : dictionary of adjascent cycles</span>
        <span class="n">dac</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># dfl : dictionnary of fronlines</span>
        <span class="n">dfl</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lcil</span><span class="p">:</span>
            <span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">nghb</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="n">cy</span><span class="p">)</span>
            <span class="n">dac</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span> <span class="o">=</span> <span class="n">nghb</span>
            <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">cp1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

            <span class="k">for</span> <span class="n">cya</span> <span class="ow">in</span> <span class="n">nghb</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cy</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
                    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cya</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
                <span class="n">cp2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">vp</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-</span><span class="n">p1</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p2</span><span class="o">-</span><span class="n">p1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="o">-</span><span class="n">p1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">vpn</span> <span class="o">=</span> <span class="n">vp</span><span class="o">/</span><span class="n">m2</span>
                <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vpn</span><span class="p">,</span><span class="n">vn</span><span class="p">)</span>
                <span class="c"># if dot(vn,vpn) &gt;0 cycle cya is ahead</span>
                <span class="k">if</span> <span class="n">dp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">lsegso</span> <span class="o">=</span> <span class="n">frontline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">vn</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lsegso</span><span class="p">:</span>
                        <span class="n">cyb</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">cy</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s">&#39;ncycles&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">cyb</span><span class="o">&lt;&gt;</span><span class="p">[]:</span>
                            <span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">s</span><span class="p">,</span><span class="n">cy</span><span class="p">,</span><span class="n">cyb</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dfl</span><span class="p">[</span><span class="n">cy</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c"># # list of interactions belonging to source</span>
        <span class="c"># lis = self.L.Gt.node[lcil[0]][&#39;inter&#39;]</span>

        <span class="c"># # list of interactions belonging to target</span>
        <span class="c"># lit = self.L.Gt.node[lcil[-1]][&#39;inter&#39;]</span>

        <span class="c"># # filter lis remove incoming transmission</span>
        <span class="c"># lli   = []</span>
        <span class="c"># lisR  = filter(lambda l: len(eval(l))==2,lis)</span>
        <span class="c"># lisT  = filter(lambda l: len(eval(l))==3,lis)</span>
        <span class="c"># lisTo = filter(lambda l: eval(l)[2]&lt;&gt;cs,lisT)</span>
        <span class="c"># lis = lisR + lisTo</span>

        <span class="c"># # filter lit remove outgoing transmission</span>
        <span class="c"># llt = []</span>
        <span class="c"># litR  = filter(lambda l: len(eval(l))==2,lit)</span>
        <span class="c"># litT  = filter(lambda l: len(eval(l))==3,lit)</span>
        <span class="c"># litTi = filter(lambda l: eval(l)[2]==ct,litT)</span>
        <span class="c"># lit = litR + litT</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">icy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="n">io</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">icy</span><span class="p">]]</span>
            <span class="n">io_</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">icy</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">print</span> <span class="n">io</span>
            <span class="k">print</span> <span class="n">io_</span>
            <span class="k">if</span> <span class="n">icy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:[[</span><span class="n">k</span><span class="p">]]})</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">io</span><span class="p">]</span>

            <span class="c"># remove keys which are not in front line</span>
            <span class="c"># kds = self.ds.keys()</span>
            <span class="c"># for k in kds :</span>
            <span class="c">#     if k not in io:</span>
            <span class="c">#         self.ds.pop(k)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">io_</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">[[]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">io</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># [self.ds.pop(k) for k in io]</span>

                    <span class="c"># ds[j]</span>
                    <span class="c"># if len(a) == 1:</span>
                    <span class="c">#     if len(ds[j]) &lt;&gt; 0:</span>
                    <span class="c">#         pdb.set_trace()</span>
                    <span class="c">#         [ds[j][k].extend(a[0][:-1]) for k in range(len(ds[j]))]</span>
                    <span class="c">#     else :</span>
                    <span class="c">#         ds[j]=a[0][:-1]</span>
                    <span class="c"># elif len(a)&gt; 1:</span>
                    <span class="c">#     if len(ds[j]) &lt;&gt; 0:</span>
                    <span class="c">#         [[ds[j][k].extend(a[l][:-1]) for k in range(len(ds[j]))] for l in range(len(a))]</span>
                    <span class="c">#     else :</span>
                    <span class="c">#         ds[j]=a[:-1]</span>


            <span class="c"># remove segments which separate two cycles.</span>
            <span class="c"># TODO: See if it worth to implement</span>
            <span class="c">#lsegs = filter(lambda x : x not in interseg,lsegs)</span>
        <span class="c"># add adjascent air cycles</span>
        <span class="c">#lcair=[]</span>
        <span class="c">#for cy in lcil:</span>
        <span class="c">#    try:</span>
        <span class="c">#        lcair.extend(self.L.dca[cy])</span>
        <span class="c">#    except:</span>
        <span class="c">#        pass</span>
        <span class="c">#lca = lca + lcair</span>
        <span class="c">#lca = list(np.unique(np.array(lca)))</span>

        <span class="c">#</span>
        <span class="c"># Reduction of Gi</span>
        <span class="c">#</span>

        <span class="c">#</span>
        <span class="c"># extract list of interactions from list of cycles lca</span>
        <span class="c">#</span>

        <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">dac</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cya</span> <span class="ow">in</span> <span class="n">dac</span><span class="p">[</span><span class="n">cy</span><span class="p">]:</span>
                <span class="n">li</span> <span class="o">=</span> <span class="n">li</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cya</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>
        <span class="c"># enforce unicity of interactions in list li</span>
        <span class="n">li</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">li</span><span class="p">)))</span>

        <span class="c"># extract dictionnary of interactions position</span>
        <span class="n">dpos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">li</span><span class="p">}</span>

        <span class="c"># build the subgraph of L.Gi with only the selected interactions</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">li</span><span class="p">)</span>
        <span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">dpos</span>

        <span class="c"># remove diffractions points from Gi</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">gidl</span><span class="p">(</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c"># add 2nd order output to edges</span>
        <span class="n">Gi</span> <span class="o">=</span> <span class="n">edgeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c">#for interaction source  in list of source interaction</span>

<span class="c">############################################################</span>
<span class="c">#        filter list of interactions in termination cycles</span>

        <span class="c"># list of interactions belonging to source</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># list of interactions belonging to target</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="s">&#39;inter&#39;</span><span class="p">]</span>

        <span class="c"># filter lis remove incoming transmission</span>
        <span class="n">lli</span>   <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lisR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
        <span class="n">lisTo</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&gt;</span><span class="n">cs</span><span class="p">,</span><span class="n">lisT</span><span class="p">)</span>
        <span class="n">lis</span> <span class="o">=</span> <span class="n">lisR</span> <span class="o">+</span> <span class="n">lisTo</span>

        <span class="c"># filter lit remove outgoing transmission</span>
        <span class="n">llt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">litR</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litT</span>  <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span><span class="p">,</span><span class="n">lit</span><span class="p">)</span>
        <span class="n">litTi</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">ct</span><span class="p">,</span><span class="n">litT</span><span class="p">)</span>
        <span class="n">lit</span> <span class="o">=</span> <span class="n">litR</span> <span class="o">+</span> <span class="n">litTi</span>

<span class="c">#################################################</span>
<span class="c">#       propaths (a.k.a. all simple path) per adjacent cycles along cycles in line</span>
<span class="c">#       Obtaining Gf: filtred graph of Gi with Gc ( rename Gt in Gc )</span>

        <span class="c">#</span>
        <span class="c"># Gf : filtered graph</span>
        <span class="c">#</span>
        <span class="n">Gf</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ncycles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcil</span><span class="p">)</span>

        <span class="n">ltarget</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lsource</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncycles</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="c"># determine list of sources and targets</span>
            <span class="c"># The famous so called saute mouton algorithm</span>
            <span class="k">if</span> <span class="n">ic</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">lis</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="n">ic</span><span class="o">==</span><span class="n">ncycles</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">ltarget</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">lit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsource</span> <span class="o">=</span> <span class="n">ltarget</span>
                <span class="n">ltarget</span> <span class="o">=</span> <span class="n">dfl</span><span class="p">[</span><span class="n">lcil</span><span class="p">[</span><span class="n">ic</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lsource</span> <span class="p">:</span>
                <span class="c">#print s</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ltarget</span><span class="p">:</span>
                    <span class="c">#print t</span>
                    <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">propaths</span><span class="p">(</span><span class="n">Gi</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                        <span class="n">itm1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">itm1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">itm1</span><span class="p">)</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">itm1</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="k">if</span> <span class="n">it</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Gf</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                                <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
                            <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">itm1</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
                            <span class="n">itm1</span> <span class="o">=</span> <span class="n">it</span>


<span class="c">################################################################</span>
<span class="c">#       Obtain position of centroid of cycles source and target</span>

        <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Tx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pcs</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cs</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="n">Gf</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="n">Gf</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="s">&#39;Rx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pct</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ct</span><span class="p">][</span><span class="s">&#39;inter&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">culdesac</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="n">Gf</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">culdesac</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">culdesac</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">Gf</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">culdesac</span><span class="p">)</span>
                <span class="k">print</span> <span class="n">culdesac</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c"># a =[ 0,  1,  2,  1,  4,  1,  6,  1,  8,  1, 10, 1]</span>
        <span class="c"># aa = np.array(a)</span>
        <span class="c"># X=aa.reshape((2,3,2)) # r x i x 2</span>
        <span class="c"># Y=X.swapaxes(0,2) # 2 x i x r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gf</span> <span class="o">=</span> <span class="n">Gf</span>
        <span class="k">print</span> <span class="s">&#39;signatures&#39;</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="s">&#39;Tx&#39;</span><span class="p">,</span><span class="s">&#39;Rx&#39;</span><span class="p">)</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calsig</span><span class="p">(</span><span class="n">Gf</span><span class="p">,</span><span class="n">dia</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">di</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="n">co</span><span class="o">+</span><span class="n">dcut</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">:</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">ns</span><span class="o">/</span><span class="n">k</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">nbi</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nbi</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>


        <span class="n">d</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span>
            <span class="n">a</span><span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">nbr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">nbr</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbr</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="Signatures.meta"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.meta.html#pylayers.antprop.signature.Signatures.meta">[docs]</a>    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span>
        <span class="c"># metasig = list(nx.all_simple_paths(self.L.Gt,source=self.source,target=self.target,cutoff=cutoff))</span>
        <span class="c">#for cutoff in range(1,5):</span>
        <span class="n">metasig</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">metasig</span><span class="p">:</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">c</span><span class="p">))))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">try</span> <span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">d</span><span class="p">))))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures.lineofcycle"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.lineofcycle.html#pylayers.antprop.signature.Signatures.lineofcycle">[docs]</a>    <span class="k">def</span> <span class="nf">lineofcycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cs</span><span class="o">=</span><span class="p">[],</span><span class="n">ct</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; shortest path between 2 cycle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cs : list</span>
<span class="sd">        ct : list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cs</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="n">cs</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">ct</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.cones"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.cones.html#pylayers.antprop.signature.Signatures.cones">[docs]</a>    <span class="k">def</span> <span class="nf">cones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="p">[],</span><span class="n">ax</span><span class="o">=</span><span class="p">[],</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; display cones of an unfolded signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : int</span>
<span class="sd">            the interaction block</span>
<span class="sd">        s : int</span>
<span class="sd">            the signature number in the block</span>
<span class="sd">        fig :</span>
<span class="sd">        ax  :</span>
<span class="sd">        figsize :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span><span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ax</span> <span class="o">==</span><span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>


        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="c"># create a global array or tahe segments</span>

        <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pta</span><span class="p">,</span><span class="n">phe</span><span class="p">))</span>
        <span class="n">lensi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">seg</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">lensi</span><span class="p">):</span>
            <span class="n">pseg0</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pseg1</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[:,</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c">#</span>
            <span class="c"># create the cone seg0 seg1</span>
            <span class="c">#</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
            <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span><span class="n">pseg1</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span> <span class="o">=</span> <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="n">figsize</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signatures.unfold"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.unfold.html#pylayers.antprop.signature.Signatures.unfold">[docs]</a>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; unfold a given signature</span>

<span class="sd">        return 2 np.ndarray of pta and phe &quot;aligned&quot;</span>
<span class="sd">        (reflexion interaction are mirrored)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : int</span>
<span class="sd">            the interaction block</span>
<span class="sd">        s : int</span>
<span class="sd">            the signature number in the block</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pta,phe</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.unfold</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">si</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">):(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">si</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">pta</span><span class="p">,</span><span class="n">phe</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">unfold</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">pta</span><span class="p">,</span><span class="n">phe</span>
</div>
<div class="viewcode-block" id="Signatures.show"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.show.html#pylayers.antprop.signature.Signatures.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot signatures within the simulated environment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        i : list or -1 (default = all groups)</span>
<span class="sd">            list of interaction group numbers</span>
<span class="sd">        s : list or -1 (default = all sig)</span>
<span class="sd">            list of indices of signature in interaction group</span>
<span class="sd">        ctx : cycle of tx (optional)</span>
<span class="sd">        crx : cycle of rx (optional)</span>
<span class="sd">        graph : type of graph to be displayed</span>
<span class="sd">        color : string</span>
<span class="sd">        alphasig : float</span>
<span class="sd">        widthsig : float</span>
<span class="sd">        colsig : string</span>
<span class="sd">        ms : int</span>
<span class="sd">        ctx  : int</span>
<span class="sd">        crx :int</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;i&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="s">&#39;s&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                   <span class="s">&#39;fig&#39;</span><span class="p">:[],</span>
                   <span class="s">&#39;ax&#39;</span><span class="p">:[],</span>
                   <span class="s">&#39;graph&#39;</span><span class="p">:</span><span class="s">&#39;s&#39;</span><span class="p">,</span>
                    <span class="s">&#39;color&#39;</span><span class="p">:</span><span class="s">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s">&#39;alphasig&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s">&#39;widthsig&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span>
                    <span class="s">&#39;colsig&#39;</span><span class="p">:</span><span class="s">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s">&#39;ms&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                    <span class="s">&#39;ctx&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s">&#39;crx&#39;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span>
                   <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># display layout</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;ctx&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Tpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;ctx&#39;</span><span class="p">]][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">Tpoly</span><span class="o">.</span><span class="n">coul</span><span class="o">=</span><span class="s">&#39;r&#39;</span>
            <span class="n">Tpoly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;crx&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">Rpoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;crx&#39;</span><span class="p">]][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">Rpoly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;g&#39;</span><span class="p">)</span>

        <span class="c"># i=-1 all rays</span>
        <span class="c"># else block of interactions i</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">lgrint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lgrint</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">]]</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lgrint</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">lsig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lsig</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">])</span>
                <span class="n">siga</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                <span class="c"># sig = np.hstack((self.pTx[0:2].reshape((2, 1)),</span>
                <span class="c">#                  np.hstack((self[i][&#39;pt&#39;][0:2, :, j],</span>
                <span class="c">#                  self.pRx[0:2].reshape((2, 1))))</span>
                <span class="c">#                  ))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">siga</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">siga</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;alphasig&#39;</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;colsig&#39;</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;widthsig&#39;</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s">&#39;off&#39;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signatures.showi"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.showi.html#pylayers.antprop.signature.Signatures.showi">[docs]</a>    <span class="k">def</span> <span class="nf">showi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">uni</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">us</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; interactive show</span>

<span class="sd">        press n to visit signatures sequentially</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        uni : index of interaction dictionnary keys</span>
<span class="sd">        us : signature index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

        <span class="n">nit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
        <span class="n">ust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">polyS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">polyS</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">polyT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">polyT</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">cp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">st</span><span class="o">=</span><span class="s">&#39;a&#39;</span>

        <span class="k">while</span> <span class="n">st</span> <span class="o">!=</span> <span class="s">&#39;q&#39;</span><span class="p">:</span>
            <span class="n">inter</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">graph</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;# interaction :&#39;</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="s">&#39;signature #&#39;</span><span class="p">,</span><span class="n">us</span><span class="p">,</span><span class="s">&#39;/&#39;</span><span class="p">,</span><span class="n">ust</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">ptx</span>
            <span class="c"># draw terminal points (centroid of source and target cycle)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;xr&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;xb&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ni</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">print</span> <span class="s">&quot;incorrect number of interactions&quot;</span>
            <span class="n">pos</span><span class="o">=</span><span class="p">{}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">us</span><span class="o">*</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">u</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]})</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]))))</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span><span class="n">node_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][(</span><span class="n">us</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">inter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;D&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;signature index out of bounds of signature&quot;</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">line</span><span class="p">,</span><span class="n">prx</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">line</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">line</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">print</span> <span class="n">inter</span>
            <span class="n">st</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="s">&#39;n&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">us</span><span class="o">+</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">ust</span><span class="p">:</span>
                    <span class="n">us</span><span class="o">=</span><span class="n">us</span><span class="o">+</span><span class="mi">2</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">uni</span> <span class="o">=</span> <span class="n">uni</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ni</span> <span class="o">=</span> <span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
                        <span class="n">ust</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                        <span class="n">us</span><span class="o">=</span><span class="mi">0</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">uni</span><span class="o">=</span><span class="mi">0</span>
                        <span class="n">ni</span><span class="o">=</span><span class="n">nit</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
                        <span class="n">us</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;press n for next signature&#39;</span>

</div>
<div class="viewcode-block" id="Signatures.rays"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signatures.rays.html#pylayers.antprop.signature.Signatures.rays">[docs]</a>    <span class="k">def</span> <span class="nf">rays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ptx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">prx</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; from signatures dict to 2D rays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptx : numpy.array or int</span>
<span class="sd">            Tx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(tx)=int</span>
<span class="sd">        prx :  numpy.array or int</span>
<span class="sd">            Rx coordinates is the center of gravity of the cycle number if</span>
<span class="sd">            type(rx)=int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rays : Rays</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        In the same time the signature of the ray is stored in the Rays object</span>

<span class="sd">        Todo : Find the best memory implemntation</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.sig2ray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">ptx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ptx</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">prx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">prx</span><span class="p">])</span>

        <span class="n">rays</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">ptx</span><span class="p">,</span><span class="n">prx</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># detect LOS situation</span>
        <span class="c">#</span>
        <span class="c">#</span>
        <span class="c"># cycle on a line between 2 cycles</span>
        <span class="c"># lc  = self.L.cycleinline(self.source,self.target)</span>

        <span class="c">#</span>
        <span class="c"># if source and target in the same merged cycle</span>
        <span class="c"># and ptx != prx</span>
        <span class="c">#</span>
        <span class="n">los</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="c"># convex cycle of each point</span>
        <span class="n">cyptx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">ptx</span><span class="p">)</span>
        <span class="n">cyprx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">pt2cy</span><span class="p">(</span><span class="n">prx</span><span class="p">)</span>

        <span class="c"># merged cycle of each point</span>
        <span class="n">polyctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyptx</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">polycrx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyprx</span><span class="p">][</span><span class="s">&#39;polyg&#39;</span><span class="p">]</span>

        <span class="n">dtxrx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ptx</span><span class="o">-</span><span class="n">prx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dtxrx</span><span class="o">&gt;</span><span class="mf">1e-15</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cyptx</span><span class="o">==</span><span class="n">cyprx</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">los</span><span class="p">):</span>
                    <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rays</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># k : Loop on interaction group</span>
        <span class="c">#   l : loop on signature</span>
        <span class="c"># ---&gt;</span>
        <span class="c">#  this part should be a generator</span>
        <span class="c">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c"># get signature block with k interactions</span>
            <span class="n">tsig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">shsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tsig</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shsig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">tsig</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">2</span><span class="p">,:]</span>
                <span class="n">ns0</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nse</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">validtx</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">validrx</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">ns0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">pD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ns0</span><span class="p">]</span>
                    <span class="n">TxD</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">ptx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">pD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pD</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">seg</span> <span class="o">=</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">TxD</span><span class="p">)</span>
                    <span class="n">validtx</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">almost_equals</span><span class="p">(</span><span class="n">TxD</span><span class="p">,</span><span class="n">decimal</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validtx</span><span class="p">:</span>
                        <span class="k">print</span> <span class="n">ns0</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">nse</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">pD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nse</span><span class="p">]</span>
                    <span class="n">DRx</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">LineString</span><span class="p">(((</span><span class="n">pD</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pD</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">prx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prx</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="n">validrx</span> <span class="o">=</span> <span class="n">polyctx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DRx</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validrx</span><span class="p">:</span>
                        <span class="k">print</span> <span class="n">nse</span>

                <span class="k">if</span> <span class="n">validtx</span> <span class="o">&amp;</span> <span class="n">validrx</span><span class="p">:</span>
                    <span class="c">#    print sig</span>
                    <span class="c">#    print pD</span>
                    <span class="n">s</span>  <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                    <span class="c">#</span>
                    <span class="c"># Transform signature into a ray</span>
                    <span class="c"># --&gt; sig2ray</span>

                    <span class="n">isray</span><span class="p">,</span><span class="n">Yi</span>  <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sig2ray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">ptx</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">prx</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">isray</span><span class="p">:</span>
                        <span class="n">Yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rays</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">Yi3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Yi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))))</span>
                            <span class="n">Yi3d</span> <span class="o">=</span> <span class="n">Yi3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span> <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;pt&#39;</span><span class="p">],</span> <span class="n">Yi3d</span><span class="p">))</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span> <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;sig&#39;</span><span class="p">],</span>
                                                        <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;pt&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                       <span class="s">&#39;sig&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)}</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yi</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">rays</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;sig&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="n">rays</span><span class="o">.</span><span class="n">nb_origin_sig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">return</span> <span class="n">rays</span>
</div>
<span class="k">class</span> <span class="nc">Signature</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; class Signature</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    seq : list  of interaction point (edges (&gt;0)  or vertices (&lt;0) [int]</span>
<span class="sd">    typ : list of interaction type 1-R 2-T 3-D  [int] </span>
<span class="sd">    pa  : tail point of interaction segmenti (2xN) ndarray</span>
<span class="sd">    pb  : head point of interaction segment  (2xN) ndarray</span>
<span class="sd">    pc  : center point of interaction segment (2xN) ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Signature.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.__init__.html#pylayers.antprop.signature.Signature.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sig : nd.array or list of interactions</span>

<span class="sd">        &gt;&gt;&gt; seq = np.array([[1,5,1],[1,1,1]])</span>
<span class="sd">        &gt;&gt;&gt; s = Signature(seq)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">typinter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">seginter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">seginter</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">typinter</span><span class="p">,</span><span class="n">sig</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Signature.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.__repr__.html#pylayers.antprop.signature.Signature.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> 
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="Signature.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.info.html#pylayers.antprop.signature.Signature.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Signature.ev2"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.ev2.html#pylayers.antprop.signature.Signature.ev2">[docs]</a>    <span class="k">def</span> <span class="nf">ev2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature. At that level the coordinates of extremities (tx and rx) is</span>
<span class="sd">        not known yet.</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>
<span class="sd">        pc  the center of segment (2xN)</span>

<span class="sd">        norm normal to the segment if segment</span>
<span class="sd">        in case the interaction is a point the normal is undefined and then</span>
<span class="sd">        set to 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">seqpointa</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nor1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nor1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nor1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pa</span><span class="p">,</span><span class="n">pb</span><span class="p">,</span><span class="n">pc</span><span class="p">,</span><span class="n">norm</span><span class="p">)))</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">seqpointa</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">6</span><span class="p">:,:]</span>

</div>
<div class="viewcode-block" id="Signature.evf"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.evf.html#pylayers.antprop.signature.Signature.evf">[docs]</a>    <span class="k">def</span> <span class="nf">evf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature (fast version)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the </span>
<span class="sd">        signature. </span>

<span class="sd">        members data </span>

<span class="sd">        pa  tail of segment  (2xN) </span>
<span class="sd">        pb  head of segment  (2xN)  </span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># head</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># segment</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>      <span class="c"># node</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
</div>
<div class="viewcode-block" id="Signature.ev"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.ev.html#pylayers.antprop.signature.Signature.ev">[docs]</a>    <span class="k">def</span> <span class="nf">ev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  evaluation of Signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function converts the sequence of interactions into numpy arrays</span>
<span class="sd">        which contains coordinates of segments extremities involved in the</span>
<span class="sd">        signature.</span>

<span class="sd">        At that stage coordinates of extremities (tx and rx) is</span>
<span class="sd">        not known yet</span>

<span class="sd">        members data</span>

<span class="sd">        pa  tail of segment  (2xN)</span>
<span class="sd">        pb  head of segment  (2xN)</span>
<span class="sd">        pc  the center of segment (2xN)</span>

<span class="sd">        norm normal to the segment if segment</span>
<span class="sd">        in case the interaction is a point the normal is undefined and then</span>
<span class="sd">        set to 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO : use map and filter instead of for loop</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>  <span class="c"># center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># segment</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">norm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;norm&#39;</span><span class="p">])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">norm1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>      <span class="c"># node</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
</div>
<div class="viewcode-block" id="Signature.unfold"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.unfold.html#pylayers.antprop.signature.Signature.unfold">[docs]</a>    <span class="k">def</span> <span class="nf">unfold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; unfold a given signature</span>

<span class="sd">        returns 2 np.ndarray of pta and phe &quot;aligned&quot;</span>
<span class="sd">        reflexion interactions are mirrored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pta : np.array</span>
<span class="sd">        phe : np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lensi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>
        <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">lensi</span><span class="p">))</span>

        <span class="n">pta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">mirror</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">lensi</span><span class="p">):</span>

            <span class="n">pam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pbm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># R</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mirror</span><span class="p">:</span>
                    <span class="n">pam</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">pbm</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pbm</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                <span class="n">pta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pam</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">phe</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">mirror</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">:</span> <span class="c"># T</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mirror</span><span class="p">:</span>
                    <span class="n">pam</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                    <span class="n">pbm</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pbm</span><span class="p">,</span><span class="n">pta</span><span class="p">[:,</span><span class="n">m</span><span class="p">],</span><span class="n">phe</span><span class="p">[:,</span><span class="n">m</span><span class="p">])</span>
                <span class="n">pta</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pam</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">phe</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span> <span class="c"># D</span>
                <span class="k">pass</span>
                <span class="c"># TODO not implemented yet</span>

        <span class="k">return</span> <span class="n">pta</span><span class="p">,</span><span class="n">phe</span>
</div>
<div class="viewcode-block" id="Signature.evtx"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.evtx.html#pylayers.antprop.signature.Signature.evtx">[docs]</a>    <span class="k">def</span> <span class="nf">evtx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; evaluate transmitter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L  : Layout</span>
<span class="sd">        tx : np.array (2xN)</span>
<span class="sd">        rx : np.array (2xM)</span>

<span class="sd">        DEPRECATED</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">norm1</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">norm1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">pb</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">pa</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">norm</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">,</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])))</span>
        <span class="c">#</span>
        <span class="c">#  vecteur entre deux points adjascents de la signature</span>
        <span class="c">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">pc</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vn</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">u1</span> <span class="o">*</span> <span class="n">u2</span><span class="p">)</span>
        <span class="c">#return(vn)</span>
        <span class="c">#return(typ)</span>

</div>
<div class="viewcode-block" id="Signature.image"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.image.html#pylayers.antprop.signature.Signature.image">[docs]</a>    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; compute the tx&#39;s images with respect to the signature segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx : numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        M : numpy.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span>
        <span class="n">pab</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pab</span> <span class="o">*</span> <span class="n">pab</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">zalpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">alpha</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">[</span><span class="n">zalpha</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span>
                            <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>

        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>
        <span class="c"># number of interactions</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pa</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c"># detect diffraction</span>
        <span class="n">usig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">usig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">usig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c"># detect transmission</span>
        <span class="n">tsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">#blocks[tsig, :, :] = np.zeros((2, 2))</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">tsig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c"># detect reflexion</span>
        <span class="n">rsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">blocks</span><span class="p">[</span><span class="n">rsig</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">rsig</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">fill_block_diag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vc0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">tx</span><span class="p">)</span> <span class="o">+</span> <span class="n">vc0</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c">#y[2 * (i + 1):2 * (i + 1) + 2] = y[2*i:2*i+2]</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> 
            <span class="k">if</span> <span class="n">typ</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">M</span>
</div>
<div class="viewcode-block" id="Signature.backtrace"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.backtrace.html#pylayers.antprop.signature.Signature.backtrace">[docs]</a>    <span class="k">def</span> <span class="nf">backtrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; backtrace given image, tx, and rx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        tx :  ndarray (2x1)</span>
<span class="sd">              transmitter</span>
<span class="sd">        rx :  ndarray (2x1)</span>
<span class="sd">              receiver</span>
<span class="sd">        M  :  ndarray (2xN)</span>
<span class="sd">              N image points obtained using self.image method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        isvalid : bool</span>
<span class="sd">            True if the backtrace ends successfully</span>

<span class="sd">        Y : ndarray (2 x (N+2))</span>
<span class="sd">            sequence of points corresponding to the seek ray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.antprop.signature import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout()</span>
<span class="sd">            &gt;&gt;&gt; L.dumpr()</span>
<span class="sd">            &gt;&gt;&gt; seq = np.array([[1,5,1],[1,1,1]])</span>
<span class="sd">            &gt;&gt;&gt; s = Signature(seq)</span>
<span class="sd">            &gt;&gt;&gt; tx = np.array([4,-1])</span>
<span class="sd">            &gt;&gt;&gt; rx = np.array([1,1])</span>
<span class="sd">            &gt;&gt;&gt; s.ev(L)</span>
<span class="sd">            &gt;&gt;&gt; M = s.image(tx)</span>
<span class="sd">            &gt;&gt;&gt; isvalid,Y = s.backtrace(tx,rx,M)</span>
<span class="sd">            &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">            &gt;&gt;&gt; ax = fig.add_subplot(111)</span>
<span class="sd">            &gt;&gt;&gt; l1 = ax.plot(tx[0],tx[1],&#39;or&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l2 = ax.plot(rx[0],rx[1],&#39;og&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l3 = ax.plot(M[0,:],M[1,:],&#39;ob&#39;)</span>
<span class="sd">            &gt;&gt;&gt; l4 = ax.plot(Y[0,:],Y[1,:],&#39;xk&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ray = np.hstack((np.hstack((tx.reshape(2,1),Y)),rx.reshape(2,1)))</span>
<span class="sd">            &gt;&gt;&gt; l5 = ax.plot(ray[0,:],ray[1,:],color=&#39;#999999&#39;,alpha=0.6,linewidth=0.6)</span>
<span class="sd">            &gt;&gt;&gt; fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For mathematical details see :</span>

<span class="sd">        @INPROCEEDINGS{6546704,</span>
<span class="sd">        author={Laaraiedh, Mohamed and Amiot, Nicolas and Uguen, Bernard},</span>
<span class="sd">        booktitle={Antennas and Propagation (EuCAP), 2013 7th European Conference on},</span>
<span class="sd">        title={Efficient ray tracing tool for UWB propagation and</span>
<span class="sd">               localization modeling},</span>
<span class="sd">        year={2013},</span>
<span class="sd">        pages={2307-2311},}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#import ipdb</span>
        <span class="c">#pdb.set_trace()</span>
        <span class="c">#import pdb</span>
        <span class="n">pa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pa</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">I2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">pkm1</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">pkm1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>          <span class="c"># interaction counter</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>      <span class="c"># to enter into the loop</span>
        <span class="n">isvalid</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># signature is asumed being valid by default</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-2</span>
        <span class="c"># while (((beta &lt;= 1) &amp; (beta &gt;= 0)) &amp; (k &lt; N)):</span>
        <span class="k">while</span> <span class="p">(((</span><span class="n">beta</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">-</span><span class="n">epsilon</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;=</span> <span class="n">epsilon</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)):</span>
            <span class="c">#if int(typ[k]) != 1: # not a diffraction (surprisingly it works)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">typ</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># not a diffraction</span>
                <span class="c"># Formula (25) of paper Eucap 2013</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I2</span><span class="p">,</span> <span class="n">pkm1</span> <span class="o">-</span> <span class="n">M</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">z0</span><span class="p">))</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I2</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span>
                                <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                                <span class="n">pb</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="p">))</span>

                <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span>
                <span class="n">yk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pkm1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="n">deT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">deT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-15</span><span class="p">:</span>
                    <span class="k">return</span><span class="p">(</span><span class="bp">False</span><span class="p">,(</span><span class="n">k</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">))</span>
                <span class="n">xk</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">yk</span><span class="p">)</span>
                <span class="n">pkm1</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">gk</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="mi">2</span><span class="p">::]</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">gk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">gk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">pkm1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c"># dummy necessary for the test below</span>
                <span class="c"># fixing #210</span>
                <span class="c">#Y = np.hstack((Y, pa[:, k].reshape((2, 1))))</span>
                <span class="c">#pkm1 = pa[:, k].reshape((2, 1))</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
                <span class="n">pkm1</span> <span class="o">=</span> <span class="n">pa</span><span class="p">[:,</span> <span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))):</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">isvalid</span><span class="p">,</span><span class="n">Y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isvalid</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">isvalid</span><span class="p">,(</span><span class="n">k</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signature.sig2beam"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.sig2beam.html#pylayers.antprop.signature.Signature.sig2beam">[docs]</a>    <span class="k">def</span> <span class="nf">sig2beam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;incremental&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; signature to beam</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        p : point</span>
<span class="sd">        mode : string</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">L</span><span class="o">.</span><span class="n">Gr</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">L</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c"># ev transforms a sequence of segment into numpy arrays (points)</span>
        <span class="c"># necessary for image calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="c"># calculates images from pTx</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Signature.sig2ray"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.signature.Signature.sig2ray.html#pylayers.antprop.signature.Signature.sig2ray">[docs]</a>    <span class="k">def</span> <span class="nf">sig2ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">pTx</span><span class="p">,</span> <span class="n">pRx</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;incremental&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; convert a signature to a 2D ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>
<span class="sd">        pTx : ndarray</span>
<span class="sd">            2D transmitter position</span>
<span class="sd">        pRx : ndarray</span>
<span class="sd">            2D receiver position</span>
<span class="sd">        mod : if mod==&#39;incremental&#39; a set of alternative signatures is return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Y : ndarray (2x(N+2))</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Signature.image</span>
<span class="sd">        Signature.backtrace</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#try:</span>
        <span class="c">#    L.Gr</span>
        <span class="c">#except:</span>
        <span class="c">#    L.build()</span>

        <span class="c"># ev transforms a sequence of segment into numpy arrays (points)</span>
        <span class="c"># necessary for image calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="c"># calculates images from pTx</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">pTx</span><span class="p">)</span>

        <span class="c">#print self</span>
        <span class="c">#if np.array_equal(self.seq,np.array([5,7,4])):</span>
        <span class="c">#    pdb.set_trace()</span>
        <span class="n">isvalid</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backtrace</span><span class="p">(</span><span class="n">pTx</span><span class="p">,</span> <span class="n">pRx</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="c">#print isvalid,Y</span>
        <span class="c">#</span>
        <span class="c"># If incremental mode this function returns an alternative signature</span>
        <span class="c"># in case the signature do not yield a valid ray.</span>
        <span class="c">#</span>
        <span class="n">isray</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s">&#39;incremental&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isvalid</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="n">Y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isray</span><span class="o">=</span><span class="bp">False</span>
                <span class="c"># something to do here</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isvalid</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="n">Y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isray</span><span class="o">=</span><span class="bp">False</span>
                <span class="k">return</span> <span class="n">isray</span><span class="p">,</span><span class="bp">None</span>

<span class="c"># def get_sigslist(self, tx, rx):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        get signatures (in one list of arrays) between tx and rx</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#            tx : numpy.ndarray</span>
<span class="c">#            rx : numpy.ndarray</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            sigslist = numpy.ndarray</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        try:</span>
<span class="c">#            self.L.Gi</span>
<span class="c">#        except:</span>
<span class="c">#            self.L.build()</span>
<span class="c">#        # all the vnodes &gt;0  from the room</span>
<span class="c">#        #</span>
<span class="c">#        NroomTx = self.L.pt2ro(tx)</span>
<span class="c">#        NroomRx = self.L.pt2ro(rx)</span>
<span class="c">#        print NroomTx,NroomRx</span>
<span class="c">#</span>
<span class="c">#        if not self.L.Gr.has_node(NroomTx) or not self.L.Gr.has_node(NroomRx):</span>
<span class="c">#            raise AttributeError(&#39;Tx or Rx is not in Gr&#39;)</span>
<span class="c">#</span>
<span class="c">#        #list of interaction </span>
<span class="c">#        ndt = self.L.Gt.node[self.L.Gr.node[NroomTx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
<span class="c">#        ndr = self.L.Gt.node[self.L.Gr.node[NroomRx][&#39;cycle&#39;]][&#39;inter&#39;]</span>
<span class="c">#</span>
<span class="c">#        ndt1 = filter(lambda l: len(eval(l))&gt;2,ndt)</span>
<span class="c">#        ndt2 = filter(lambda l: len(eval(l))&lt;3,ndt)</span>
<span class="c">#        ndr1 = filter(lambda l: len(eval(l))&gt;2,ndr)</span>
<span class="c">#        ndr2 = filter(lambda l: len(eval(l))&lt;3,ndr)</span>
<span class="c">#</span>
<span class="c">#        print ndt1</span>
<span class="c">#        print ndr1</span>
<span class="c">#        ndt1 = filter(lambda l: eval(l)[2]&lt;&gt;NroomTx,ndt1)</span>
<span class="c">#        ndr1 = filter(lambda l: eval(l)[1]&lt;&gt;NroomRx,ndr1)</span>
<span class="c">#</span>
<span class="c">#        ndt = ndt1 + ndt2</span>
<span class="c">#        ndr = ndr1 + ndr2</span>
<span class="c">#</span>
<span class="c">#        ntr = np.intersect1d(ndt, ndr)</span>
<span class="c">#        sigslist = []</span>
<span class="c">#</span>
<span class="c">#        for nt in ndt:</span>
<span class="c">#            print nt</span>
<span class="c">#            for nr in ndr:</span>
<span class="c">#                addpath = False</span>
<span class="c">#                print nr</span>
<span class="c">#                if (nt != nr):</span>
<span class="c">#                    try:</span>
<span class="c">#                        path = nx.dijkstra_path(self.L.Gi, nt, nr)</span>
<span class="c">#                        #paths = nx.all_simple_paths(self.L.Gi,source=nt,target=nr)</span>
<span class="c">#                        addpath = True</span>
<span class="c">#                        showsig(self.L,path,tx,rx)</span>
<span class="c">#                    except:</span>
<span class="c">#                        pass</span>
<span class="c">#                if addpath:</span>
<span class="c">#                    sigarr = np.array([]).reshape(2, 0)</span>
<span class="c">#                    for interaction in path:</span>
<span class="c">#                        it = eval(interaction)</span>
<span class="c">#                        if type(it) == tuple:</span>
<span class="c">#                            if len(it)==2: #reflexion</span>
<span class="c">#                                sigarr = np.hstack((sigarr,</span>
<span class="c">#                                                np.array([[it[0]],[1]])))</span>
<span class="c">#                            if len(it)==3: #transmission</span>
<span class="c">#                                sigarr = np.hstack((sigarr,</span>
<span class="c">#                                                np.array([[it[0]], [2]])))</span>
<span class="c">#                        elif it &lt; 0: #diffraction</span>
<span class="c">#                            sigarr = np.hstack((sigarr,</span>
<span class="c">#                                                np.array([[it], [3]])))</span>
<span class="c">#                    sigslist.append(sigarr)</span>
<span class="c">#</span>
<span class="c">#        return sigslist</span>
<span class="c">#</span>
<span class="c">#    def update_sigslist(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        get signatures taking into account reverberations</span>
<span class="c">#</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            sigslist: numpy.ndarry</span>
<span class="c">#</span>
<span class="c">#        Notes</span>
<span class="c">#        -----</span>
<span class="c">#        This is a preliminary function need more investigations</span>
<span class="c">#</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        pTx = self.pTx</span>
<span class="c">#        pRx = self.pRx</span>
<span class="c">#        NroomTx = self.L.pt2ro(pTx)</span>
<span class="c">#        NroomRx = self.L.pt2ro(pRx)</span>
<span class="c">#        if NroomTx == NroomRx:</span>
<span class="c">#            sigslist = self.get_sigslist(pTx, pRx)</span>
<span class="c">#        else:</span>
<span class="c">#            sigslist = []</span>
<span class="c">#            sigtx = self.get_sigslist(pTx, pTx)</span>
<span class="c">#            sigrx = self.get_sigslist(pRx, pRx)</span>
<span class="c">#            sigtxrx = self.get_sigslist(pTx, pRx)</span>
<span class="c">#            sigslist = sigslist + sigtxrx</span>
<span class="c">#            for sigtr in sigtxrx:</span>
<span class="c">#                for sigt in sigtx:</span>
<span class="c">#                    if (sigt[:, -1] == sigtr[:, 0]).all():</span>
<span class="c">#                        if np.shape(sigtr)[1] == 1 or np.shape(sigt)[1] == 1:</span>
<span class="c">#                            pass</span>
<span class="c">#                        else:</span>
<span class="c">#                            sigslist.append(np.hstack((sigt, sigtr[:, 1:])))</span>
<span class="c">#                for sigr in sigrx:</span>
<span class="c">#                    if (sigr[:, 0] == sigtr[:, -1]).all():</span>
<span class="c">#                        if np.shape(sigtr)[1] == 1 or np.shape(sigr)[1] == 1:</span>
<span class="c">#                            pass</span>
<span class="c">#                        else:</span>
<span class="c">#                            sigslist.append(np.hstack((sigtr, sigr[:, 1:])))</span>
<span class="c">#</span>
<span class="c">#        return sigslist</span>
<span class="c">#</span>
<span class="c">#    def image_ceilfloor(self, tx, pa, pb):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Compute the images of tx with respect to ceil or floor</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#            tx : numpy.ndarray</span>
<span class="c">#            pa : numpy.ndarray</span>
<span class="c">#            pb : numpy.ndarray</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            M : numpy.ndarray</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c">#        pab = pb - pa</span>
<span class="c">#        alpha = np.sum(pab * pab, axis=0)</span>
<span class="c">#        zalpha = np.where(alpha == 0.)</span>
<span class="c">#        alpha[zalpha] = 1.</span>
<span class="c">#</span>
<span class="c">#        a = 1 - (2. / alpha) * (pa[1, :] - pb[1, :]) ** 2</span>
<span class="c">#        b = (2. / alpha) * (pb[0, :] - pa[0, :]) * (pa[1, :] - pb[1, :])</span>
<span class="c">#        c = (2. / alpha) * (pa[0, :] * (pa[1, :] - pb[1, :]) ** 2 +</span>
<span class="c">#                            pa[1, :] * (pa[1, :] - pb[1, :]) *</span>
<span class="c">#                            (pb[0, :] - pa[0, :]))</span>
<span class="c">#        d = (2. / alpha) * (pa[1, :] * (pb[0, :] - pa[0, :]) ** 2 +</span>
<span class="c">#                            pa[0, :] * (pa[1, :] - pb[1, :]) *</span>
<span class="c">#                            (pb[0, :] - pa[0, :]))</span>
<span class="c">#</span>
<span class="c">#        S = np.zeros((1, 2, 2))</span>
<span class="c">#        S[:, 0, 0] = -a</span>
<span class="c">#        S[:, 0, 1] = b</span>
<span class="c">#        S[:, 1, 0] = b</span>
<span class="c">#        S[:, 1, 1] = a</span>
<span class="c">#        A = np.eye(2)</span>
<span class="c">#</span>
<span class="c">#        vc0 = np.array([c[0], d[0]])</span>
<span class="c">#        y = np.dot(-S[0, :, :], tx) + vc0</span>
<span class="c">#</span>
<span class="c">#        x = la.solve(A, y)</span>
<span class="c">#        M = np.vstack((x[0::2], x[1::2]))</span>
<span class="c">#        return M</span>
<span class="c">#</span>
<span class="c">#    def backtrace_ceilfloor(self, tx, rx, pa, pb, M):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        backtracing step: given the image, tx, and rx, this function</span>
<span class="c">#        traces the 2D ray.</span>
<span class="c">#</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#            tx :  numpy.ndarray</span>
<span class="c">#                  transmitter</span>
<span class="c">#            rx :  numpy.ndarray</span>
<span class="c">#                  receiver</span>
<span class="c">#            M  :  numpy.ndarray</span>
<span class="c">#                  images obtained using image()</span>
<span class="c">#</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#            Y : numpy.ndarray</span>
<span class="c">#                2D ray</span>
<span class="c">#</span>
<span class="c">#</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        N = np.shape(pa)[1]</span>
<span class="c">#        I2 = np.eye(2)</span>
<span class="c">#        z0 = np.zeros((2, 1))</span>
<span class="c">#</span>
<span class="c">#        pkm1 = rx.reshape(2, 1)</span>
<span class="c">#        Y = pkm1</span>
<span class="c">#        k = 0</span>
<span class="c">#        beta = .5</span>
<span class="c">#        cpt = 0</span>
<span class="c">#        while (((beta &lt;= 1) &amp; (beta &gt;= 0)) &amp; (k &lt; N)):</span>
<span class="c">#            l0 = np.hstack((I2, pkm1 - M[:, N - (k + 1)].reshape(2, 1), z0</span>
<span class="c">#                            ))</span>
<span class="c">#            l1 = np.hstack((I2, z0,</span>
<span class="c">#                            pa[:, N - (k + 1)].reshape(2, 1) -</span>
<span class="c">#                            pb[:, N - (k + 1)].reshape(2, 1)</span>
<span class="c">#                            ))</span>
<span class="c">#</span>
<span class="c">#            T = np.vstack((l0, l1))</span>
<span class="c">#            yk = np.hstack((pkm1[:, 0].T, pa[:, N - (k + 1)].T))</span>
<span class="c">#            deT = np.linalg.det(T)</span>
<span class="c">#            if abs(deT) &lt; 1e-15:</span>
<span class="c">#                return(None)</span>
<span class="c">#            xk = la.solve(T, yk)</span>
<span class="c">#            pkm1 = xk[0:2].reshape(2, 1)</span>
<span class="c">#            gk = xk[2::]</span>
<span class="c">#            alpha = gk[0]</span>
<span class="c">#            beta = gk[1]</span>
<span class="c">#            Y = np.hstack((Y, pkm1))</span>
<span class="c">#            k += 1</span>
<span class="c">#        if ((k == N) &amp; ((beta &gt; 0) &amp; (beta &lt; 1))):  # &amp; ((alpha &gt; 0) &amp; (alpha &lt; 1))):</span>
<span class="c">#            Y = np.hstack((Y, tx.reshape(2, 1)))</span>
<span class="c">#            return(Y)</span>
<span class="c">#        else:</span>
<span class="c">#            return(None)</span>
<span class="c">#   def sigs2rays(self, sigslist):</span>
<span class="c">#        &quot;&quot;&quot; from signatures list to 2D rays</span>
<span class="c">#</span>
<span class="c">#        Parameters</span>
<span class="c">#        ----------</span>
<span class="c">#</span>
<span class="c">#            sigslist : list</span>
<span class="c">#</span>
<span class="c">#        Returns</span>
<span class="c">#        -------</span>
<span class="c">#</span>
<span class="c">#            rays : dict</span>
<span class="c">#</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        rays = {}</span>
<span class="c">#        for sig in sigslist:</span>
<span class="c">#            s = Signature(sig)</span>
<span class="c">#            Yi = s.sig2ray(self.L, self.pTx[:2], self.pRx[:2])</span>
<span class="c">#            if Yi is not None:</span>
<span class="c">#                #pdb.set_trace()</span>
<span class="c">#                Yi = np.fliplr(Yi)</span>
<span class="c">#                nint = len(sig[0, :])</span>
<span class="c">#                if str(nint) in rays.keys():</span>
<span class="c">#                    Yi3d = np.vstack((Yi[:, 1:-1], np.zeros((1, nint))))</span>
<span class="c">#                    Yi3d = Yi3d.reshape(3, nint, 1)</span>
<span class="c">#                    rays[str(nint)][&#39;pt&#39;] = np.dstack((</span>
<span class="c">#                                                      rays[str(nint)][&#39;pt&#39;], Yi3d))</span>
<span class="c">#                    rays[str(nint)][&#39;sig&#39;] = np.dstack((</span>
<span class="c">#                                                       rays[str(nint)][&#39;sig&#39;],</span>
<span class="c">#                                                       sig.reshape(2, nint, 1)))</span>
<span class="c">#                else:</span>
<span class="c">#                    rays[str(nint)] = {&#39;pt&#39;: np.zeros((3, nint, 1)),</span>
<span class="c">#                                       &#39;sig&#39;: np.zeros((2, nint, 1))}</span>
<span class="c">#                    rays[str(nint)][&#39;pt&#39;][0:2, :, 0] = Yi[:, 1:-1]</span>
<span class="c">#                    rays[str(nint)][&#39;sig&#39;][:, :, 0] = sig</span>
<span class="c">#        return rays</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;testing pylayers/antprop/signature.py&quot;</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;-------------------------------------&quot;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">PyLayers Home </a> |&nbsp;</li>
        <li><a href="../../../notebook/index.html">Documentation </a> |&nbsp;</li>
        <li><a href="../../../download.html">Download </a> |&nbsp; </li>
        <li><a href="https://github.com/pylayers/">Developer (Github)</a> </li>

          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2014, PyLayers developer team.
      Last updated on oct. 20, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34943220-1']);
  _gaq.push(['_setDomainName', 'pylayers.github.io']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })(); 
</script> 
 
  </body>
</html>