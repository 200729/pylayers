
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pylayers.antprop.rays &mdash; Python 1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="Python 1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34943220-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body role="document">

    <div class="header-wrapper">
      <div class="header">
          <p class="logo"><a href="../../../index.html">
            <img src="../../../_static/pylayers.png" alt="Logo"/>
          </a>
          </p><div class="navbar">
          <ul>
            <li><a href="../../../download.html">Download</a></li>
            <li><a href="../../../notebook/TOC.html">User Guide</a></li>
            <li><a href="../../../modules/pylayers.html">Reference</a></li>
       </ul>

<div class="search_form">

<div id="cse" style="width: 100%;"></div>
<script>
  (function() {
       var cx = '004820205189002234612:sa15qzuf2ca';
           var gcse = document.createElement('script');
               gcse.type = 'text/javascript';
                   gcse.async = true;
                       gcse.src = (document.location.protocol == 'https:' ?
                           'https:' : 'http:') +
                               '//cse.google.com/cse.js?cx=' + cx;
                                   var s =
                                   document.getElementsByTagName('script')[0];
                                       s.parentNode.insertBefore(gcse, s);
                                         })();
</script>
<gcse:search></gcse:search>
</div>
</div> <!-- end navbar --></div>
    </div>

    <div class="content-wrapper">

      <div class="sphinxsidebar">
	<div class="sphinxsidebarwrapper">
	  <div class="rel">
	   
	<!-- rellinks[1:] is an ugly hack to avoid link to module
	    index  -->
	<div class="rellink">
	<a href="../../../py-modindex.html" title="Python Module Index"
	    >Modules
	    <br>
	    <span class="smallrellink">
	    Python Module...
	    </span>
	    <span class="hiddenrellink">
	    Python Module Index
	    </span>
	    
	    </a>
	</div>
	<!-- Ad a link to the 'up' page -->
	<div class="spacer">
	&nbsp;
	</div>
	<div class="rellink">
	<a href="../../index.html" title="Module code" >
	Up
	<br>
	<span class="smallrellink">
	Module code
	</span>
	<span class="hiddenrellink">
	Module code
	</span>
	
	</a>
	</div>
    </div>
    <p style="text-align: center; background-color: #BFFFFF">This documentation is

    for Python <strong>version 1</strong>
    &mdash; <a href="https://github.com/pylayers/pylayers/archive/master.zip">Other versions</a></p>
    
    <h3>Citing</h3>
    <p>If you use the software, please consider
    <a href="../../../about.html#citing-pylayers">citing pylayers</a>.</p>
    <h3>This page</h3>
	
    
    </div>
	  </div>


      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pylayers.antprop.rays</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: latin1 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Class Rays</span>
<span class="sd">==========</span>

<span class="sd">This modules contains Rays class</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    :toctree: generated</span>

<span class="sd">    Rays.__init__</span>
<span class="sd">    Rays.__len__</span>
<span class="sd">    Rays.__repr__</span>
<span class="sd">    Rays.sort</span>
<span class="sd">    Rays.extract</span>
<span class="sd">    Rays.mirror</span>
<span class="sd">    Rays.to3D</span>
<span class="sd">    Rays.locbas</span>
<span class="sd">    Rays.fillinter</span>
<span class="sd">    Rays.length</span>
<span class="sd">    Rays.eval</span>
<span class="sd">    Rays.ray</span>
<span class="sd">    Rays.typ</span>
<span class="sd">    Rays.info</span>
<span class="sd">    Rays.signature</span>
<span class="sd">    Rays.show</span>
<span class="sd">    Rays.show3d</span>
<span class="sd">    Rays._show3</span>
<span class="sd">    Rays.reciprocal</span>
<span class="sd">    Rays.check_reciprocity</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
    <span class="kn">from</span> <span class="nn">mayavi.sources.vtk_data_source</span> <span class="kn">import</span> <span class="n">VTKDataSource</span>
    <span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;Layout:Mayavi is not installed&#39;</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">ConfigParser</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">struct</span> <span class="kn">as</span> <span class="nn">stru</span>
<span class="kn">import</span> <span class="nn">pylayers.util.geomutil</span> <span class="kn">as</span> <span class="nn">geu</span>
<span class="kn">import</span> <span class="nn">pylayers.util.pyutil</span> <span class="kn">as</span> <span class="nn">pyu</span>
<span class="kn">from</span> <span class="nn">pylayers.util.project</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pylayers.antprop.interactions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pylayers.antprop.slab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pylayers.antprop.channel</span> <span class="kn">import</span> <span class="n">Ctilde</span>
<span class="kn">from</span> <span class="nn">pylayers.gis.layout</span> <span class="kn">import</span> <span class="n">Layout</span>
<span class="kn">import</span> <span class="nn">pylayers.signal.bsignal</span> <span class="kn">as</span> <span class="nn">bs</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="kn">as</span> <span class="nn">shg</span>
<span class="kn">import</span> <span class="nn">h5py</span>

<span class="k">class</span> <span class="nc">Rays</span><span class="p">(</span><span class="n">PyLayers</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A set of rays</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    rays   :</span>
<span class="sd">    nbrays :</span>
<span class="sd">    rayidx :</span>
<span class="sd">    sig    :</span>
<span class="sd">    pt     :</span>
<span class="sd">    alpha  :</span>


<span class="sd">    Methods</span>
<span class="sd">    -------</span>

<span class="sd">    to3D(H=3,N=1)</span>
<span class="sd">        for k in self:   # for all interaction group k</span>
<span class="sd">        for k in self:   # for all interaction group k</span>
<span class="sd">    locbas(L)</span>
<span class="sd">    fillinter(L)</span>
<span class="sd">    eval</span>
<span class="sd">    show(L)</span>
<span class="sd">    mirror(H=3,N=1)</span>
<span class="sd">    ray</span>
<span class="sd">    typ</span>
<span class="sd">    info</span>
<span class="sd">    to3D</span>
<span class="sd">    signature(L)</span>
<span class="sd">    show3d(ray,bdis,bbas,bstruc,col,id,linewidth)</span>
<span class="sd">    show3()</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The Rays object is obtained from a signature.</span>
<span class="sd">    It is a container for a set of rays between a source</span>
<span class="sd">    and a target point defining a radio link.</span>

<span class="sd">    Once a Rays object has been obtained in 2D, it is transformed</span>
<span class="sd">    in 3D via the **to3D** method. This method has two parameters :</span>
<span class="sd">    the height from floor to ceil, and the number N of</span>
<span class="sd">    multiple reflections to account for.</span>

<span class="sd">    Once the 3d rays have been calculated,</span>
<span class="sd">    the local basis are evaluated along those rays. This is</span>
<span class="sd">    done through the **locbas** method</span>

<span class="sd">    Once the local basis have been calculated the different</span>
<span class="sd">    interactions along rays can be informed via the **fillinter**</span>
<span class="sd">    method.</span>

<span class="sd">    Once the interaction are informed the field along rays can</span>
<span class="sd">    be evaluated via the **eval** method</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Rays.__init__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.__init__.html#pylayers.antprop.rays.Rays.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pTx</span><span class="p">,</span> <span class="n">pRx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        pTx : np.array</span>
<span class="sd">        pRx : np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pTx</span> <span class="o">=</span> <span class="n">pTx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span> <span class="o">=</span> <span class="n">pRx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nray</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raypt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is3D</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isbased</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluated</span> <span class="o">=</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="Rays.__len__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.__len__.html#pylayers.antprop.rays.Rays.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Nray</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">])</span>
            <span class="n">Nray</span> <span class="o">=</span> <span class="n">Nray</span><span class="o">+</span><span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Nray</span></div>


<div class="viewcode-block" id="Rays.__repr__"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.__repr__.html#pylayers.antprop.rays.Rays.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is3D</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;3D</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;----------&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span>
                    <span class="n">nr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; / &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span><span class="o">+</span> <span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">ni</span> <span class="o">=</span> <span class="n">ni</span> <span class="o">+</span> <span class="n">nr</span><span class="o">*</span><span class="n">k</span>
                    <span class="n">nl</span> <span class="o">=</span> <span class="n">nl</span> <span class="o">+</span> <span class="n">nr</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;-----&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;N2Drays : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nray</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;from &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_origin_sig</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; signatures</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;#Rays/#Sig: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_origin_sig</span><span class="p">)</span> <span class="p">)</span>

                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">pTx : &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">pRx : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="c1">#sk = np.shape(self[k][&#39;sig&#39;])[2]</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,:])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="c1">#s = s + str(sk) + &#39;rays with&#39; + str(k) + &#39; interactions&#39;</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s2">&quot;problem&quot;</span>
            <span class="k">return</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save rays in hdf5 format</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        idx : int</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        loadh5</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">filenameh5</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRR3D&#39;</span><span class="p">])</span>



        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="c1"># keys not saved as attribute of h5py file</span>
            <span class="n">notattr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;B0&#39;</span><span class="p">,</span><span class="s1">&#39;delays&#39;</span><span class="p">,</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notattr</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">kk</span> <span class="o">==</span> <span class="s1">&#39;sig2d&#39;</span><span class="p">:</span>
                        <span class="c1"># Need to find an efficient way to save the signatures</span>
                        <span class="c1"># 2d which have created the rays</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">kk</span> <span class="o">==</span> <span class="s1">&#39;nbrays&#39;</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">]]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Rays: issue when writting h5py file&#39;</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="p">[],</span><span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load rays hdf5 format</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">filenameh5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">filenameh5</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRR3D&#39;</span><span class="p">])</span>


        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):{}})</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="p">[</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kk</span><span class="p">:</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">kk</span><span class="p">)][:]})</span>

            <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">va</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">va</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Rays: issue when reading h5py file&#39;</span><span class="p">)</span>

        <span class="c1"># fill if save was filled</span>

        <span class="c1"># temporary solution in order to avoir</span>
        <span class="c1"># creating save for Interactions classes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">Lname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.ini&#39;</span>
            <span class="n">L</span><span class="o">=</span><span class="n">Layout</span><span class="p">(</span><span class="n">Lname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fillinter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluated</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fGHz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_saveh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save rays h5py format compliant with Links Class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filenameh5 : string</span>
<span class="sd">            filename of the h5py file (from Links Class)</span>
<span class="sd">        grpname : string</span>
<span class="sd">            groupname of the h5py file (from Links Class)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.links</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filenameh5</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">grpname</span> <span class="ow">in</span> <span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;ray&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;ray&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">grpname</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39;ray/&#39;</span><span class="o">+</span><span class="n">grpname</span> <span class="o">+</span><span class="s1">&#39;already exists in &#39;</span><span class="o">+</span><span class="n">filenameh5</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;ray/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>
            <span class="c1"># keys not saved as attribute of h5py file</span>
            <span class="n">notattr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;B0&#39;</span><span class="p">,</span><span class="s1">&#39;delays&#39;</span><span class="p">,</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notattr</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">kk</span> <span class="o">==</span> <span class="s1">&#39;sig2d&#39;</span><span class="p">:</span>
                        <span class="c1"># Need to find an efficient way to save the signatures</span>
                        <span class="c1"># 2d which have created the rays</span>
                        <span class="k">pass</span>
                    <span class="k">elif</span> <span class="n">kk</span> <span class="o">==</span> <span class="s1">&#39;nbrays&#39;</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">]]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span><span class="n">shape</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">]),</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">])</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Rays: issue when writting h5py file&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_loadh5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">grpname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load rays  h5py format compliant with Links Class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filenameh5 : string</span>
<span class="sd">            filename of the h5py file (from Links Class)</span>
<span class="sd">        grpname : string</span>
<span class="sd">            groupname of the h5py file (from Links Class)</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.simul.links</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">filename</span><span class="o">=</span><span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filenameh5</span><span class="p">,</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLNK&#39;</span><span class="p">])</span>
        <span class="c1"># try/except to avoid loosing the h5 file if</span>
        <span class="c1"># read/write error</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fh5</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">fh5</span><span class="p">[</span><span class="s1">&#39;ray/&#39;</span><span class="o">+</span><span class="n">grpname</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">):{}})</span>
                <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="p">[</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kk</span><span class="p">:</span><span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">kk</span><span class="p">)][:]})</span>

            <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">va</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">va</span><span class="p">)</span>
            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="n">fh5</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Rays: issue when reading h5py file&#39;</span><span class="p">)</span>

        <span class="c1"># fill if save was filled</span>
        <span class="c1"># temporary solution in order to avoid</span>
        <span class="c1"># creating save for Interactions classes</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">L</span><span class="o">=</span><span class="n">Layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Lfilename</span><span class="p">,</span><span class="n">build</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fillinter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluated</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fGHz</span><span class="p">)</span>


<div class="viewcode-block" id="Rays.reciprocal"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.reciprocal.html#pylayers.antprop.rays.Rays.reciprocal">[docs]</a>    <span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; switch tx and rx</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">r</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">is3D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is3D</span>
        <span class="n">r</span><span class="o">.</span><span class="n">nray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nray</span>
        <span class="n">r</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_sig_name</span>
        <span class="n">r</span><span class="o">.</span><span class="n">nb_origin_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_origin_sig</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rays.check_reciprocity"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.check_reciprocity.html#pylayers.antprop.rays.Rays.check_reciprocity">[docs]</a>    <span class="k">def</span> <span class="nf">check_reciprocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check ray reciprocity in comparing two reciprocal rays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        r : rays reciprocal to self</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># permutation of all termination points</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">pRx</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="o">==</span><span class="n">r</span><span class="o">.</span><span class="n">pTx</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="c1"># for all group of interctions</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># same distances</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]))</span>
            <span class="c1"># same points when reading from right to left</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]))</span>
            <span class="c1"># same signature reading from right to left</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]))</span>
            <span class="c1"># if local basis have been evaluated</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isbased</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">isbased</span><span class="p">):</span>
                <span class="c1">#assert (np.allclose(self[k][&#39;nstrwall&#39;],r[k][&#39;nstrwall&#39;][:,::-1,:]))</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1">#assert ((np.mod(self[k][&#39;aoa&#39;]-r[k][&#39;aod&#39;],2*np.pi)==0).all())</span>
                <span class="c1">#assert ((np.mod(self[k][&#39;aod&#39;]-r[k][&#39;aoa&#39;],2*np.pi)==0).all())</span>
                <span class="c1"># 1st output basis is equal to last input basis of the reciprocal ray</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo0&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;BiN&#39;</span><span class="p">])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1"># last input basis is equal to 1st output basis of the reciprocal ray</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;BiN&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo0&#39;</span><span class="p">])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1"># vsi vectors are inversed</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;vsi&#39;</span><span class="p">],</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;vsi&#39;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;scpr&#39;</span><span class="p">]),</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;scpr&#39;</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]))),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;theta&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;theta&#39;</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bi&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo&#39;</span><span class="p">][:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bi&#39;</span><span class="p">][:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;B&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;B&#39;</span><span class="p">][:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))),</span> <span class="s1">&#39;interaction block:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluated</span> <span class="p">:</span>

            <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nray</span><span class="p">):</span>

                <span class="n">iint1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
                <span class="n">iint2</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>

                <span class="c1"># check Interactions</span>
                <span class="n">A1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">I</span><span class="p">[:,</span> <span class="n">iint1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">A2</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">I</span><span class="p">[:,</span> <span class="n">iint2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span><span class="n">A2</span><span class="p">),</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

                <span class="c1"># check bases</span>
                <span class="c1">#  ray 1 : B0   | B[0]   | B[1] | B[2] | B[3] | B[4]</span>
                <span class="c1">#  ray 2 : B[4] | B[3]  | B[2]  | B[1] | B[0] | B0</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B0</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ir</span><span class="p">,:,:],</span><span class="n">r</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iint2</span><span class="p">,:,:][</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">B0</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ir</span><span class="p">,:,:],</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iint1</span><span class="p">,:,:][</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iint1</span><span class="p">,:,:][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">r</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iint2</span><span class="p">,:,:][:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span></div>



<div class="viewcode-block" id="Rays.sort"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.sort.html#pylayers.antprop.rays.Rays.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; sort rays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dis</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rays.extract"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.extract.html#pylayers.antprop.rays.Rays.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract a single ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ni : group of interactions</span>
<span class="sd">        nr : ray index in group of interactions</span>
<span class="sd">        L  : Layout</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">r</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">is3D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is3D</span>
        
        
        <span class="n">ni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span>
        <span class="n">ur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">nr</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;D&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">(</span><span class="n">nr</span><span class="p">):</span>
            <span class="n">diff</span><span class="o">=</span><span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff</span><span class="o">=</span><span class="bp">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;diffvect&#39;</span><span class="p">):</span>
            <span class="c1"># check if the ray has diffraction interaction</span>
            <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray2iidx</span><span class="p">(</span><span class="n">nr</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">i</span> <span class="ow">in</span> <span class="n">inter</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;diffidx&#39;</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uD</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="n">diffkey</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;diffvect&#39;</span><span class="p">,</span><span class="s1">&#39;diffidx&#39;</span><span class="p">,</span><span class="s1">&#39;diffslabs&#39;</span><span class="p">]</span>

        <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nbrays&#39;</span><span class="p">,</span><span class="s1">&#39;rayidx&#39;</span><span class="p">,</span><span class="s1">&#39;dis&#39;</span><span class="p">,</span><span class="s1">&#39;nstrwall&#39;</span><span class="p">,</span><span class="s1">&#39;nstrswall&#39;</span><span class="p">]:</span>
                <span class="n">tab</span>  <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">diffkey</span><span class="p">:</span>
                        <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">ur</span><span class="p">][</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="p">:</span> 
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">diffkey</span> <span class="p">:</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;diffslabs&#39;</span><span class="p">:</span>
                            <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">tab</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">uD</span><span class="p">][</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uD</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">:</span>
                                <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">tab</span><span class="p">[</span><span class="n">uD</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                    

        <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;nrays&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span> <span class="c1"># keep only one ray</span>
        <span class="n">r</span><span class="o">.</span><span class="n">nray</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1">#r[ni][&#39;rayidx&#39;]=np.array([self[ni][&#39;rayidx&#39;][nr]]) # ray index in the whole structure</span>
        <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">r</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">][</span><span class="n">ur</span><span class="p">]])</span>
        <span class="n">r</span><span class="o">.</span><span class="n">locbas</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">fillinter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>

   

<div class="viewcode-block" id="Rays.show"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.show.html#pylayers.antprop.rays.Rays.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot 2D rays within the simulated environment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        rlist : list  (default []= all rays)</span>
<span class="sd">            list of indices of ray in interaction group</span>
<span class="sd">        graph : string t</span>
<span class="sd">            type of graph to be displayed</span>
<span class="sd">            &#39;s&#39;,&#39;r&#39;,&#39;t&#39;,..</span>
<span class="sd">        fig : figure</span>
<span class="sd">        ax  : axis</span>
<span class="sd">        L   : Layout</span>
<span class="sd">        alpharay : float</span>
<span class="sd">            1</span>
<span class="sd">        widthray : float</span>
<span class="sd">            0.1</span>
<span class="sd">        colray : string</span>
<span class="sd">            &#39;black&#39;</span>
<span class="sd">        ms : int</span>
<span class="sd">            marker size :  5</span>
<span class="sd">        layout : boolean</span>
<span class="sd">            True</span>
<span class="sd">        points : boolean</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rlist&#39;</span><span class="p">:[],</span>
                   <span class="s1">&#39;fig&#39;</span><span class="p">:[],</span>
                   <span class="s1">&#39;ax&#39;</span><span class="p">:[],</span>
                    <span class="s1">&#39;L&#39;</span><span class="p">:[],</span>
                   <span class="s1">&#39;graph&#39;</span><span class="p">:</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;alpharay&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;widthray&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span>
                    <span class="s1">&#39;colray&#39;</span><span class="p">:</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;ms&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                    <span class="s1">&#39;layout&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;points&#39;</span><span class="p">:</span><span class="bp">True</span>
                   <span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1">#if kwargs[&#39;fig&#39;] ==[]:</span>
        <span class="c1">#    fig = plt.figure()</span>
        <span class="c1">#if kwargs[&#39;ax&#39;] ==[]:</span>
        <span class="c1">#    ax = fig.add_subplot(111)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;layout&#39;</span><span class="p">]</span> <span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span> 
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Please give a Layout file as argument&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span>
        <span class="c1">#</span>
        <span class="c1"># display Tx and Rx</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span> <span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ms&#39;</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;og&#39;</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ms&#39;</span><span class="p">])</span>
        <span class="c1"># i=-1 all rays</span>
        <span class="c1"># else block of interactions i</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rlist&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>

            <span class="n">lgrint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lgrint</span><span class="p">:</span>
                <span class="n">lray</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;rays index :&#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">lray</span><span class="p">:</span>
                    <span class="n">ray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
                                     <span class="p">))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpharay&#39;</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;colray&#39;</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;widthray&#39;</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;rays index :&#39;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">][</span><span class="n">lray</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rlist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rlist&#39;</span><span class="p">]</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">rlist</span><span class="p">]</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">nbi</span><span class="p">,</span><span class="n">rlist</span><span class="p">))</span>
            <span class="n">unb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
            <span class="n">unr</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">):</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">==</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unb</span><span class="p">}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unb</span><span class="p">:</span>
                <span class="n">raynb</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">unr</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">nbr</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">raynb</span><span class="p">)</span>
                <span class="n">ptidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">raynb</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ptidx</span><span class="p">:</span>

                    <span class="n">ray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
                                     <span class="p">))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpharay&#39;</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;colray&#39;</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;widthray&#39;</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>




                <span class="c1"># raynb = (nr[1,unr[i]]).astype(int)</span>
                <span class="c1"># nbr=len(raynb)</span>
                <span class="c1"># ptidx = [np.where(self[i][&#39;rayidx&#39;]==x)[0][0] for x in raynb]</span>
                <span class="c1"># # current number of interactions</span>
                <span class="c1"># cnbi = i + 2</span>
            
                <span class="c1"># pt = self[i][&#39;pt&#39;][:,:,ptidx].reshape(3,cnbi*nbr,order=&#39;F&#39;)</span>


        <span class="k">return</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">ax</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rays.mirror"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.mirror.html#pylayers.antprop.rays.Rays.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">za</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">zb</span><span class="o">=</span> <span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; mirror a ray termination</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        H : float</span>
<span class="sd">            ceil height (default 3m)</span>
<span class="sd">            if H=0 only floor reflection is calculated (outdoor case)</span>
<span class="sd">            if H=-1 floor and ceil reflection are inhibited (2D test case)</span>
<span class="sd">        N : int</span>
<span class="sd">            handle the number of mirror reflexions</span>

<span class="sd">        za : float</span>
<span class="sd">            height of the point where the parametrization starts ( e.g. pTx[2])</span>

<span class="sd">        zb : float</span>
<span class="sd">            height of the point where the parametrization ends ( e.g. pRx[2])</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        d : dict</span>
<span class="sd">            k : zm  v: alpham</span>
<span class="sd">            k : zp  v: alphap</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; ptx = np.array([1,1,1.5])</span>
<span class="sd">        &gt;&gt;&gt; prx = np.array([2,2,1.2])</span>
<span class="sd">        &gt;&gt;&gt; r = Rays(ptx,prx)</span>
<span class="sd">        &gt;&gt;&gt; d = r.mirror()</span>
<span class="sd">        &gt;&gt;&gt; d[-1.5]</span>
<span class="sd">        array([ 0.55555556])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        d is a dictionnary whose keys are heights along the vertical from where</span>
<span class="sd">        are emanating the reflected rays. Values of d are the parameterization</span>
<span class="sd">        (0&lt; () &lt;1) along the ray where are situated the different reflection</span>
<span class="sd">        points.</span>


<span class="sd">        &quot;&quot;&quot;</span>



        <span class="n">km</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># heights of transmitter and receiver</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">za</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">za</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">zb</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">zb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">za</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">zb</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">hr</span><span class="o">&lt;</span><span class="n">H</span> <span class="ow">or</span> <span class="n">H</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">H</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;mirror : receiver higher than ceil height&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">ht</span><span class="o">&lt;</span><span class="n">H</span> <span class="ow">or</span> <span class="n">H</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">H</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;mirror : transmitter higher than ceil height&quot;</span>

        <span class="n">zkp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">kp</span><span class="o">*</span><span class="n">H</span> <span class="o">+</span> <span class="n">ht</span>
        <span class="n">zkm</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">km</span><span class="o">*</span><span class="n">H</span> <span class="o">-</span> <span class="n">ht</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">zm</span> <span class="ow">in</span> <span class="n">zkm</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">zm</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bup</span> <span class="o">=</span> <span class="n">H</span>
                    <span class="n">pas</span> <span class="o">=</span> <span class="n">H</span>
                    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">zm</span><span class="o">/</span><span class="n">H</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bup</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">pas</span> <span class="o">=</span> <span class="o">-</span><span class="n">H</span>
                    <span class="n">km</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">zm</span><span class="o">/</span><span class="n">H</span><span class="p">))</span>
                <span class="n">thrm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">km</span><span class="o">*</span><span class="n">H</span><span class="p">,</span> <span class="n">bup</span><span class="p">,</span> <span class="n">pas</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">zm</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">thrm</span><span class="o">-</span><span class="n">zm</span><span class="p">)</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">hr</span><span class="o">-</span><span class="n">zm</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">zp</span> <span class="ow">in</span> <span class="n">zkp</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">zp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bup</span> <span class="o">=</span> <span class="n">H</span>
                    <span class="n">pas</span> <span class="o">=</span> <span class="n">H</span>
                    <span class="n">kp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">zp</span><span class="o">/</span><span class="n">H</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bup</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">pas</span> <span class="o">=</span> <span class="o">-</span><span class="n">H</span>
                    <span class="n">kp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">zp</span><span class="o">/</span><span class="n">H</span><span class="p">))</span>
                <span class="n">thrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">kp</span><span class="o">*</span><span class="n">H</span><span class="p">,</span> <span class="n">bup</span><span class="p">,</span> <span class="n">pas</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">zp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">thrp</span><span class="o">-</span><span class="n">zp</span><span class="p">)</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">hr</span><span class="o">-</span><span class="n">zp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">H</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="n">ht</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ht</span><span class="o">/</span><span class="p">(</span><span class="n">ht</span><span class="o">+</span><span class="n">hr</span><span class="p">)])</span>
            <span class="n">d</span><span class="p">[</span><span class="n">ht</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="n">H</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">ht</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="c1"># print &quot;zp&quot;,zp</span>
            <span class="c1"># print &quot;kp&quot;,kp</span>
            <span class="c1"># print &quot;thrp&quot;,thrp</span>
            <span class="c1"># print &quot;alphap&quot;,d[zp]</span>

        <span class="k">return</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rays.to3D"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.to3D.html#pylayers.antprop.rays.Rays.to3D">[docs]</a>    <span class="k">def</span> <span class="nf">to3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">H</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">rmoutceilR</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; transform 2D ray to 3D ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout object</span>

<span class="sd">        H : float</span>
<span class="sd">            ceil height (default 3m)</span>
<span class="sd">            if H=0 only floor reflection is calculated (outdoor case)</span>
<span class="sd">            if H=-1 floor and ceil reflection are inhibited (2D test case)</span>
<span class="sd">        N : int</span>
<span class="sd">            number of mirror reflexions</span>
<span class="sd">        rmoutceilR ; bool</span>
<span class="sd">            Remove Ceil reflexions in cycles (Gt nodes) </span>
<span class="sd">            with indoor=False attribute </span>

<span class="sd">        returns</span>
<span class="sd">        -------</span>

<span class="sd">        r3d : Rays</span>

<span class="sd">    </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pTx</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span>

        <span class="c1">#</span>
        <span class="c1"># Phase 1 : calculate Tx images height and parameterization in the</span>
        <span class="c1"># vertical plane</span>
        <span class="c1">#</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">za</span><span class="o">=</span><span class="n">tx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">zb</span><span class="o">=</span><span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        

        <span class="c1">#</span>
        <span class="c1"># Elimination of invalid diffraction point </span>
        <span class="c1"># If the diffaction point is a separation between 2 air wall </span>
        <span class="c1"># it should be removed.</span>


        <span class="c1">#</span>
        <span class="c1"># Phase 2 : calculate 2D parameterization in the horizontal plane</span>
        <span class="c1">#</span>

        <span class="c1"># for all group of interactions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>

            <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span>
            <span class="c1"># broadcasting of t and r</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])))</span>
            <span class="c1"># append t and r to interaction points in 2D</span>
            <span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pts</span><span class="p">,</span> <span class="n">r</span><span class="p">))))</span>
            <span class="n">si1</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pts1</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># array of all ray segments distances</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">si1</span> <span class="o">*</span> <span class="n">si1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="c1"># array of cumulative distance of 2D ray</span>
            <span class="n">al1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># initialize parameterization parameter alpha</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">si</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;alpha&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">])):</span>
                <span class="c1"># get alpha</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;alpha&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> \
                        <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># get z coordinate</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;alpha&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> \
                    <span class="o">*</span> <span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">tx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1">#</span>
        <span class="c1">#  Phase 3 : Initialize 3D rays dictionnary</span>
        <span class="c1">#</span>
        <span class="n">r3d</span> <span class="o">=</span> <span class="n">Rays</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span>
        <span class="n">r3d</span><span class="o">.</span><span class="n">los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span>
        <span class="n">r3d</span><span class="o">.</span><span class="n">is3D</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1">#</span>
        <span class="c1"># Phase 4 : Fill 3D rays information</span>
        <span class="c1">#</span>
        <span class="c1"># Two nested loops</span>
        <span class="c1">#</span>
        <span class="c1">#      for all interaction group</span>
        <span class="c1">#          for all type of 3D rays</span>
        <span class="c1">#             1) extension</span>
        <span class="c1">#             2) sort</span>
        <span class="c1">#             3) coordinates as a function of parameter</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>   <span class="c1"># for all interaction group k</span>
            <span class="c1"># k = int(k)</span>
            <span class="c1"># Number of rays in interaction group k</span>
            <span class="n">Nrayk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;alpha&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># get  2D horizontal parameterization</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>

            <span class="c1">#if (k==1):</span>
            <span class="c1">#    pdb.set_trace()</span>
            <span class="c1"># get  2D signature</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span>
            <span class="c1">#print &quot;signatures 2D &quot;,sig</span>
            <span class="c1">#print &quot;----&quot;</span>
            <span class="n">sigsave</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
            <span class="c1"># add parameterization of tx and rx (0,1)</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">)),</span> <span class="n">a1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">))))</span>
            <span class="c1"># reshape signature in adding tx and rx</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                             <span class="n">sig</span><span class="p">,</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)))</span>  <span class="c1"># add signature of Tx and Rx (0,0))</span>
            <span class="c1"># broadcast tx and rx</span>
            <span class="n">Tx</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">))</span>
            <span class="n">Rx</span> <span class="o">=</span> <span class="n">rx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">))</span>

            <span class="c1"># pte is the sequence of point in 3D ndim =3   ( ndim x k x Nrayk)</span>
            <span class="n">pte</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span>

            <span class="c1"># ndim x k+2 x Nrayk</span>
            <span class="n">pte</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Tx</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span> <span class="n">Rx</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>                     <span class="c1"># for each vertical pattern (C,F,CF,FC,....)</span>
                <span class="c1">#print k,l,d[l]</span>
                <span class="n">Nint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>            <span class="c1"># number of additional interaction</span>
                <span class="c1">#if ((k==1) &amp; (l==5.0)):print</span>
                <span class="k">if</span> <span class="n">Nint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>                <span class="c1"># if new interaction ==&gt; need extension</span>
                    <span class="c1"># a1e : extended horizontal+vertical parameterization</span>
                    <span class="n">a1e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">))))</span>
                    <span class="c1"># get sorted indices</span>
                    <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a1e</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1"># a1es : extended sorted horizontal + vertical parameterization</span>
                    <span class="n">a1es</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a1e</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># #### Check if it exists the same parameter value in the horizontal plane</span>
                    <span class="c1"># #### and the vertical plane. Move parameter if so.</span>

                    <span class="n">da1es</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">a1es</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">pda1es</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da1es</span><span class="o">&lt;</span><span class="mf">1e-10</span><span class="p">)</span>
                    <span class="n">a1es</span><span class="p">[</span><span class="n">pda1es</span><span class="p">]</span><span class="o">=</span><span class="n">a1es</span><span class="p">[</span><span class="n">pda1es</span><span class="p">]</span><span class="o">-</span><span class="mf">1e-3</span>


                    <span class="c1"># prepare an extended sequence of points ( ndim x  (Nint+k+2) x Nrayk )</span>
                    <span class="n">ptee</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pte</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">Nint</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">))))</span>

                    <span class="c1">#</span>
                    <span class="c1"># Boolean ceil/floor detector</span>
                    <span class="c1">#</span>
                    <span class="c1"># u is 4 (floor interaction )</span>
                    <span class="c1">#      5 (ceil interaction )</span>
                    <span class="c1">#  depending on the vertical pattern l.</span>
                    <span class="c1">#</span>
                    <span class="c1">#  l &lt;0 corresponds to last reflexion on floor</span>
                    <span class="c1">#  l &gt;0 corresponds to last reflexion on ceil</span>
                    <span class="c1">#</span>
                    <span class="c1"># u =0 (floor) or 1 (ceil)</span>
                    <span class="c1"># if l &lt; 0:</span>
                    <span class="c1">#     u = np.mod(range(Nint), 2)</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     u = 1 - np.mod(range(Nint), 2)</span>


                    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Nint</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># l&lt;0 Nint odd</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nint</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Nint</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># l&gt;0 Nint odd</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nint</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>


                    <span class="k">elif</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Nint</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># l&lt;0 Nint even</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nint</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Nint</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># l&gt;0 Nint even</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nint</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                    
                    <span class="c1">#</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="mi">4</span>
                    <span class="c1">#</span>
                    <span class="c1"># At that point we introduce the signature of the new</span>
                    <span class="c1"># introduced points on the ceil and/or floor.</span>
                    <span class="c1">#</span>
                    <span class="c1"># A signature is composed of two lines</span>
                    <span class="c1"># esigs sup line : interaction number</span>
                    <span class="c1"># esigi inf line : interaction type</span>
                    <span class="c1">#</span>
                    <span class="n">esigs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nint</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">esigi</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nint</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nrayk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="c1"># esig : extension of the signature</span>
                    <span class="n">esig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">esigs</span><span class="p">,</span> <span class="n">esigi</span><span class="p">))</span>
                    <span class="c1"># sige : signature extended  ( 2 x (Nint+k+2) x Nrayk )</span>
                    <span class="n">sige</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sig</span><span class="p">,</span> <span class="n">esig</span><span class="p">))</span>

                    <span class="c1">#</span>
                    <span class="c1"># 2 x (Nint+k+2) x Nrayk</span>
                    <span class="c1">#</span>
                    <span class="c1"># sort extended sequence of points</span>
                    <span class="c1"># and extended sequence of signatures with the sorting</span>
                    <span class="c1"># index ks obtained from argsort of merge parametization</span>
                    <span class="c1">#</span>
                    <span class="c1"># sequence of extended sorted points</span>
                    <span class="c1">#</span>
                    <span class="n">ptees</span> <span class="o">=</span> <span class="n">ptee</span><span class="p">[:,</span> <span class="n">ks</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nrayk</span><span class="p">)]</span>
                    <span class="n">siges</span> <span class="o">=</span> <span class="n">sige</span><span class="p">[:,</span> <span class="n">ks</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nrayk</span><span class="p">)]</span>

                    <span class="c1"># extended and sorted signature</span>
                    <span class="n">iint_f</span><span class="p">,</span> <span class="n">iray_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">siges</span><span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># floor interaction</span>
                    <span class="n">iint_c</span><span class="p">,</span> <span class="n">iray_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">siges</span><span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># ceil interaction</span>
                    <span class="c1">#print siges</span>
                    <span class="c1">#</span>
                    <span class="c1"># find the list of the previous and next point around the</span>
                    <span class="c1"># new ceil or floor point. The case of successive ceil or</span>
                    <span class="c1"># floor reflexion make</span>
                    <span class="c1">#</span>
                    <span class="c1"># Tous les points prcdents qui ne sont pas des Ceils ou</span>
                    <span class="c1"># des floors et tous les points suivants qui ne sont pas</span>
                    <span class="c1"># des points de rflexion ceil ou floor</span>
                    <span class="c1">#</span>
                    <span class="c1"># Afin de tenir compte du rayon et du groupe d&#39;interaction</span>
                    <span class="c1"># concerne, il faut passer un tuple qui concatene la valeur</span>
                    <span class="c1"># de l&#39;indice d&#39;interaction floor ou ceil et l&#39;indice de</span>
                    <span class="c1"># rayons du groupe associe (d&#39;ou le zip)</span>
                    <span class="c1">#</span>
                    <span class="c1"># Cette sequence d&#39;instruction fixe le bug #133</span>
                    <span class="c1">#</span>
                    <span class="c1"># Antrieurement il y avait une hypothese de succession</span>
                    <span class="c1"># immediate d&#39;un point 2D renseigne.</span>
                    <span class="c1">#</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">iintm_f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iint_f</span><span class="p">,</span><span class="n">iray_f</span><span class="p">))</span>
                        <span class="n">iintp_f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iint_f</span><span class="p">,</span><span class="n">iray_f</span><span class="p">))</span>
                        <span class="n">iintm_c</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iint_c</span><span class="p">,</span><span class="n">iray_c</span><span class="p">))</span>
                        <span class="n">iintp_c</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iint_c</span><span class="p">,</span><span class="n">iray_c</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

                    <span class="c1"># Update coordinate in the horizontal plane</span>
                    <span class="c1">#</span>
                    <span class="c1">#</span>
                    <span class="c1"># The new interaction ceil or floor has no coordinates in</span>
                    <span class="c1"># the horizontal plane.</span>
                    <span class="c1"># Those coordinates are evaluated first by finding a sub</span>
                    <span class="c1"># parameterization of the point with respect to the two</span>
                    <span class="c1"># known adjascent interaction point j-1 and j+1 (Thales)</span>
                    <span class="c1">#</span>

                    <span class="c1">#iintm_f = iint_f - 1</span>
                    <span class="c1">#iintp_f = iint_f + 1</span>

                    <span class="c1">#iintm_c = iint_c - 1</span>
                    <span class="c1">#iintp_c = iint_c + 1</span>


                    <span class="c1">#</span>
                    <span class="c1"># If there are floor points</span>
                    <span class="c1">#</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iint_f</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">a1esm_f</span> <span class="o">=</span> <span class="n">a1es</span><span class="p">[</span><span class="n">iintm_f</span><span class="p">,</span> <span class="n">iray_f</span><span class="p">]</span>
                        <span class="n">a1esc_f</span> <span class="o">=</span> <span class="n">a1es</span><span class="p">[</span><span class="n">iint_f</span><span class="p">,</span> <span class="n">iray_f</span><span class="p">]</span>
                        <span class="n">a1esp_f</span> <span class="o">=</span> <span class="n">a1es</span><span class="p">[</span><span class="n">iintp_f</span><span class="p">,</span> <span class="n">iray_f</span><span class="p">]</span>


                        <span class="n">pteesm_f</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">iintm_f</span><span class="p">,</span> <span class="n">iray_f</span><span class="p">]</span>
                        <span class="n">pteesp_f</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">iintp_f</span><span class="p">,</span> <span class="n">iray_f</span><span class="p">]</span>

                        <span class="n">coeff_f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1esc_f</span><span class="o">-</span><span class="n">a1esm_f</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">a1esp_f</span><span class="o">-</span><span class="n">a1esm_f</span><span class="p">)</span>
                        <span class="n">ptees</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">iint_f</span><span class="p">,</span> <span class="n">iray_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">pteesm_f</span> <span class="o">+</span> <span class="n">coeff_f</span><span class="o">*</span><span class="p">(</span><span class="n">pteesp_f</span><span class="o">-</span><span class="n">pteesm_f</span><span class="p">)</span>

                    <span class="c1">#</span>
                    <span class="c1"># If there are ceil points</span>
                    <span class="c1">#</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iint_c</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">a1esm_c</span> <span class="o">=</span> <span class="n">a1es</span><span class="p">[</span><span class="n">iintm_c</span><span class="p">,</span> <span class="n">iray_c</span><span class="p">]</span>
                        <span class="n">a1esc_c</span> <span class="o">=</span> <span class="n">a1es</span><span class="p">[</span><span class="n">iint_c</span><span class="p">,</span> <span class="n">iray_c</span><span class="p">]</span>
                        <span class="n">a1esp_c</span> <span class="o">=</span> <span class="n">a1es</span><span class="p">[</span><span class="n">iintp_c</span><span class="p">,</span> <span class="n">iray_c</span><span class="p">]</span>

                        <span class="n">pteesm_c</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">iintm_c</span><span class="p">,</span> <span class="n">iray_c</span><span class="p">]</span>
                        <span class="n">pteesp_c</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">iintp_c</span><span class="p">,</span> <span class="n">iray_c</span><span class="p">]</span>

                        <span class="n">coeff_c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1esc_c</span><span class="o">-</span><span class="n">a1esm_c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">a1esp_c</span><span class="o">-</span><span class="n">a1esm_c</span><span class="p">)</span>
                        <span class="n">ptees</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">iint_c</span><span class="p">,</span> <span class="n">iray_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pteesm_c</span> <span class="o">+</span> <span class="n">coeff_c</span><span class="o">*</span><span class="p">(</span><span class="n">pteesp_c</span><span class="o">-</span><span class="n">pteesm_c</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">H</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">z</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">a1es</span><span class="o">*</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">l</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="p">)</span>
                        <span class="n">pz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">H</span><span class="p">)</span>
                        <span class="n">z</span><span class="p">[</span><span class="n">pz</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">H</span><span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">pz</span><span class="p">]</span>
                        <span class="n">ptees</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">z</span>
                    <span class="c1"># case where ceil reflection are inhibited</span>
                    <span class="k">elif</span> <span class="n">H</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span> 
                        <span class="n">z</span>  <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">a1es</span><span class="o">*</span><span class="p">(</span><span class="n">rx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">l</span><span class="p">))</span>
                        <span class="c1"># pz = np.where(z &gt; H)</span>
                        <span class="c1"># z[pz] = 2*H-z[pz]</span>
                        <span class="n">ptees</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">z</span>

                <span class="c1"># recopy old 2D parameterization (no extension)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a1es</span> <span class="o">=</span> <span class="n">a1</span>
                    <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a1es</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ptees</span> <span class="o">=</span> <span class="n">pte</span>
                    <span class="c1"># fixing bug</span>
                    <span class="n">siges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                    <span class="c1">#print siges</span>

                <span class="c1">#---------------------------------</span>
                <span class="c1"># handling subsegments (if any)</span>
                <span class="c1">#---------------------------------</span>
                <span class="c1">#</span>
                <span class="c1">#   ptes (3 x i+2 x r )</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">lsss</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#</span>
                    <span class="c1"># lsss : list of sub segments ( iso segments siges)</span>
                    <span class="c1"># lnss : list of diffaction point involving air walls</span>

                    <span class="n">lsss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">lsss</span><span class="p">)</span>
                    <span class="n">lnss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">lnss</span><span class="p">)</span>

                    <span class="c1"># number of structure element </span>
                    <span class="n">nstr</span> <span class="o">=</span> <span class="n">siges</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
                    <span class="c1"># type of interaction</span>
                    <span class="n">typi</span> <span class="o">=</span> <span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span>

                    <span class="c1"># lss : list of subsegments in the current signature </span>
                    <span class="c1">#</span>
                    <span class="c1"># scalability : avoid a loop over all the subsegments in lsss</span>
                    <span class="c1">#</span>
                    <span class="n">lss</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lsss</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nstr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                    
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lss</span><span class="p">:</span> 
                        <span class="n">u</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nstr</span><span class="o">==</span><span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">zs</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="n">zinterval</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">zs</span><span class="o">&lt;=</span><span class="n">zinterval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">zs</span><span class="o">&gt;=</span><span class="n">zinterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                <span class="c1"># print s , zs , zinterval</span>
                                <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span> <span class="c1"># signature is not valid</span>
                                <span class="c1"># nstr : structure number</span>
                                <span class="n">nstr</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">nstr</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                <span class="c1"># typi : type of interaction </span>
                                <span class="n">typi</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">typi</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                <span class="c1"># 3d sequence of points</span>
                                <span class="n">ptees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ptees</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                <span class="c1"># extended (floor/ceil) signature</span>
                                <span class="n">siges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">siges</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                            
                    <span class="c1"># lns : list of diffraction pointx in the current signature </span>
                    <span class="c1">#</span>
                    <span class="c1"># scalability : avoid a loop over all the points in lnss</span>
                    <span class="c1">#</span>
                    <span class="n">lns</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lnss</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nstr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                    <span class="c1">#pdb.set_trace()</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lns</span><span class="p">:</span> 
                        <span class="n">u</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nstr</span><span class="o">==</span><span class="n">p</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">zp</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="c1">#zinterval = L.Gs.node[s][&#39;z&#39;]</span>
                            <span class="c1"># if (zs&lt;=zinterval[1]) &amp; (zs&gt;=zinterval[0]):</span>
                            <span class="k">if</span> <span class="n">zp</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">:</span>
                                <span class="c1"># print s , zs , zinterval</span>
                                <span class="k">pass</span>
                            <span class="k">else</span><span class="p">:</span> <span class="c1"># signature is not valid</span>
                                <span class="c1"># nstr : structure number</span>
                                <span class="n">nstr</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">nstr</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                <span class="c1"># typi : type of interaction </span>
                                <span class="n">typi</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">typi</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                <span class="c1"># 3d sequence of points</span>
                                <span class="n">ptees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ptees</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                <span class="c1"># extended (floor/ceil) signature</span>
                                <span class="n">siges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">siges</span><span class="p">,</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                
                    
                <span class="k">if</span> <span class="n">rmoutceilR</span><span class="p">:</span>
                    <span class="c1"># 1 determine Ceil reflexion index</span>
                    <span class="c1"># uc (inter x ray)</span>
                    <span class="n">uc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">siges</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:]</span><span class="o">==</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">ptc</span> <span class="o">=</span> <span class="n">ptees</span><span class="p">[:,</span><span class="n">uc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">uc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">P</span> <span class="o">=</span> <span class="n">shg</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">(</span><span class="n">ptc</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="c1"># 2 determine the cycle where ceil reflexions append</span>
                        <span class="c1"># uinter(nb pt x nb cycles)</span>
                        <span class="n">mapnode</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
                        <span class="n">uinter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mapnode</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">])</span>
                        <span class="c1"># import ipdb</span>
                        <span class="c1"># ipdb.set_trace()</span>
                        <span class="c1">#[plt.scatter(p.xy[0],p.xy[1],c=&#39;r&#39;) for up,p in enumerate(P) if uinter[0,up]]</span>
                        <span class="c1">#[ plt.scatter(p.xy[0],p.xy[1],c=&#39;r&#39;) for up,p in enumerate(P) if uinter[0,up]]</span>
                        <span class="c1"># find points are indoor/outdoor cycles</span>
                        <span class="n">upt</span><span class="p">,</span><span class="n">ucy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">uinter</span><span class="p">)</span>
                        <span class="n">uout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="ow">not</span> <span class="n">L</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">mapnode</span><span class="p">[</span><span class="n">u</span><span class="o">+</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ucy</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#ucy+1 is to manage cycle 0</span>
                        <span class="c1"># 3 remove ceil reflexion of outdoor cycles</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uout</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        
                            <span class="n">ptees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ptees</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">uout</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                            <span class="n">siges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">siges</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">uout</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                            <span class="n">sigsave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">sigsave</span><span class="p">,</span><span class="n">uc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">uout</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                
                <span class="k">if</span> <span class="n">r3d</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">):</span>
            
                    <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">],</span> <span class="n">ptees</span><span class="p">))</span>
                    <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">],</span> <span class="n">siges</span><span class="p">))</span>
                    <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;sig2d&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigsave</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ptees</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptees</span>
                        <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">siges</span>
                        <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">Nint</span><span class="p">][</span><span class="s1">&#39;sig2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigsave</span><span class="p">]</span>
                <span class="c1"># ax=plt.gca()</span>
                <span class="c1"># uu = np.where(ptees[2,...]==3.0)</span>
                <span class="c1"># ax.plot(ptees[0,uu[0],uu[1]],ptees[1,uu[0],uu[1]],&#39;ok&#39;)</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
        <span class="c1">#</span>
        <span class="c1"># Add Line Of Sight ray information</span>
        <span class="c1">#   pt =  [tx,rx]</span>
        <span class="c1">#   sig = [0,0]</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">tx</span><span class="o">-</span><span class="n">rx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">r3d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">r3d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">r3d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;sig2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">r3d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">r3d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">r3d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">rx</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># r3d.nray = reduce(lambda x,y : y + np.shape(r3d[x][&#39;sig&#39;])[2],lnint)</span>
        <span class="c1"># count total number of ray</span>
        <span class="c1"># evaluate length of ray segment</span>
        <span class="c1">#</span>
        <span class="c1"># vsi</span>
        <span class="c1"># si</span>
        <span class="c1"># dis</span>
        <span class="c1">#</span>
        <span class="n">val</span> <span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">r3d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">nrayk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nbrays&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrayk</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrayk</span><span class="p">)</span><span class="o">+</span><span class="n">val</span>
            <span class="n">r3d</span><span class="o">.</span><span class="n">nray</span> <span class="o">=</span> <span class="n">r3d</span><span class="o">.</span><span class="n">nray</span> <span class="o">+</span> <span class="n">nrayk</span>
            <span class="n">val</span><span class="o">=</span><span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>

            <span class="c1"># 3 : x,y,z</span>
            <span class="c1"># i : interaction index</span>
            <span class="c1"># r : ray index</span>
            <span class="c1">#</span>
            <span class="c1"># k : group of interactions index</span>
            <span class="c1">#</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span><span class="o">-</span><span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">lsi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">rlength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lsi</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lsi</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lsi</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="c1">#assert(lsi.all()&gt;0)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lsi</span><span class="o">==</span><span class="mf">0.</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

            <span class="c1">#</span>
            <span class="c1"># sort rays w.r.t their length</span>
            <span class="c1">#</span>

            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">rlength</span><span class="p">)</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,:,</span><span class="n">u</span><span class="p">]</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][:,:,</span><span class="n">u</span><span class="p">]</span>
            <span class="c1">#r3d[k][&#39;sig2d&#39;] = r3d[k][&#39;sig2d&#39;][:,:,u]</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">lsi</span>             <span class="c1"># ndim , nint - 1 , nray</span>

            <span class="c1"># vsi : 3 x (i+1) x r</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;vsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">si</span><span class="p">[:,:,</span><span class="n">u</span><span class="p">]</span>

            <span class="c1"># si : (i+1) x r</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;si&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">lsi</span><span class="p">[:,</span><span class="n">u</span><span class="p">]</span>
            <span class="n">r3d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlength</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>

        <span class="n">r3d</span><span class="o">.</span><span class="n">origin_sig_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin_sig_name</span>
        <span class="n">r3d</span><span class="o">.</span><span class="n">Lfilename</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_filename</span>
        <span class="n">r3d</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r3d</span><span class="o">.</span><span class="n">nray</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">r3d</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rays.length"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.length.html#pylayers.antprop.rays.Rays.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate length of rays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        typ : int</span>
<span class="sd">            1 : length of all segments</span>
<span class="sd">            2 : accumulated length</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>   <span class="c1"># for all interaction group k</span>
            <span class="c1"># 3 x Ni-1 x Nr</span>
            <span class="n">vk</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vk</span><span class="o">*</span><span class="n">vk</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">typ</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">dk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span>
            <span class="k">if</span> <span class="n">typ</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">dk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dk</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rays.locbas"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.locbas.html#pylayers.antprop.rays.Rays.locbas">[docs]</a>    <span class="k">def</span> <span class="nf">locbas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate ray local basis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">       </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># extract normal in np.array</span>
        <span class="c1">#</span>

        <span class="c1"># nsegment x 3</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="s1">&#39;norm&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># nsegment x k</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="s1">&#39;norm&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># maximum number for refering to segment</span>
        <span class="c1"># not to be confused with a segment number</span>

        <span class="n">nsmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Structure number : nstr</span>
        <span class="c1">#   the structure number is &lt; 0 for points</span>
        <span class="c1">#                           &gt; 0 for segments</span>
        <span class="c1"># A segment can have several subsegments (until 100)</span>
        <span class="c1">#  nstrs is the nstr of the segment if subsegment :</span>
        <span class="c1">#  nstr  is the glabal which allows to recover the slab values</span>
        <span class="c1">#</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">:</span>
            <span class="n">idxts</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">nbrayt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idxts</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nbrayt</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># list of used wedges</span>
        <span class="n">luw</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># k is the number of interactions in the block</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># structure number (segment or point)</span>
                <span class="c1"># nstr : i x r</span>
                <span class="n">nstr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># ityp : i x r</span>
                <span class="n">ityp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># nstr of underlying segment</span>
                <span class="c1"># position of interaction corresponding to a sub segment</span>
                <span class="c1"># print nstr</span>
                <span class="c1">#</span>
                <span class="c1"># uss : index of subsegment</span>
                <span class="c1"># subsegments are not nodes of Gs but have positive nst index</span>
                <span class="c1">#</span>

                <span class="n">uss</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nstr</span><span class="o">&gt;</span><span class="n">nsmax</span><span class="p">)</span>

                <span class="c1"># print uss</span>

                <span class="n">nstrs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">nstr</span><span class="p">)</span>
                <span class="c1">#</span>
                <span class="c1"># if subsegments have been found</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uss</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind</span>   <span class="o">=</span> <span class="n">nstr</span><span class="p">[</span><span class="n">uss</span><span class="p">]</span><span class="o">-</span><span class="n">nsmax</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">nstrs</span><span class="p">[</span><span class="n">uss</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">lsss</span><span class="p">)[</span><span class="n">ind</span><span class="p">]</span>
                <span class="c1">#    print nstr</span>
                <span class="c1">#print nstrs</span>
                <span class="c1">#pdb.set_trace()</span>
                <span class="n">nray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">nstr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">uwall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ityp</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ityp</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">udiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ityp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">ufloor</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ityp</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">uceil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ityp</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))</span>

                <span class="n">nstrwall</span>  <span class="o">=</span> <span class="n">nstr</span><span class="p">[</span><span class="n">uwall</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uwall</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>   <span class="c1"># nstr of walls</span>
                <span class="n">nstrswall</span> <span class="o">=</span> <span class="n">nstrs</span><span class="p">[</span><span class="n">uwall</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uwall</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>   <span class="c1"># nstrs of walls</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nstrwall&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">nstrwall</span>    <span class="c1"># store nstr without subsegment</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nstrswall&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nstrswall</span>   <span class="c1"># store nstr with subsegment</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">nray</span><span class="p">))</span>   <span class="c1"># 3 x int x nray</span>



                <span class="c1"># norm : 3 x i x r</span>
                <span class="c1">#</span>
                <span class="c1"># norm name is improper norm is in fact the vector associated to the</span>
                <span class="c1"># interaction</span>
                <span class="c1"># For the diffraction case the normal is replaced by the unit</span>
                <span class="c1"># vector along the wedge directed upward.</span>
                <span class="c1">#</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">][:,</span> <span class="n">uwall</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uwall</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">norm</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">nstrswall</span><span class="p">],:]</span><span class="o">.</span><span class="n">T</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span> <span class="n">ufloor</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ufloor</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ufloor</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span> <span class="n">uceil</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">uceil</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uceil</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span> <span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="n">normcheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">normcheck</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">&gt;</span><span class="mf">0.99</span><span class="p">,</span><span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>



                <span class="c1"># 3 : x,y,z</span>
                <span class="c1"># i : interaction index</span>
                <span class="c1"># r : ray index</span>
                <span class="c1">#</span>
                <span class="c1"># k : group of interactions index</span>
                <span class="c1">#</span>
                <span class="c1">#v = self[k][&#39;pt&#39;][:, 1:, :]-self[k][&#39;pt&#39;][:, 0:-1, :]</span>
                <span class="c1">#lsi = np.sqrt(np.sum(v*v, axis=0))</span>
                <span class="c1">#if (lsi.any()==0):</span>
                <span class="c1">#    pdb.set_trace()</span>
                <span class="c1">#assert(lsi.all()&gt;0)</span>
                <span class="c1">#if (len(np.where(lsi==0.))==0) :</span>
                <span class="c1">#    pdb.set_trace()</span>

                <span class="c1">#si = v/lsi             # ndim , nint - 1 , nray</span>

                <span class="c1"># si : 3 x (i+1) x r</span>
                <span class="n">si</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;vsi&#39;</span><span class="p">]</span>

                <span class="c1"># si : (i+1) x r</span>
                <span class="c1">#self[k][&#39;si&#39;] = lsi</span>
                <span class="c1">#self[k][&#39;dis&#39;] = np.sum(lsi,axis=0)</span>

                <span class="c1"># normal : 3 x i x r</span>
                <span class="n">vn</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                <span class="c1"># s_in : 3 x i x r</span>
                <span class="n">s_in</span> <span class="o">=</span> <span class="n">si</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># s_out : 3 x i x r</span>
                <span class="n">s_out</span> <span class="o">=</span> <span class="n">si</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>

                <span class="c1">#</span>
                <span class="c1"># AOD (rad)</span>
                <span class="c1">#</span>

                <span class="c1"># th : ,r</span>
                <span class="n">thd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># ph : ,r</span>
                <span class="n">phd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># aod : 2 x r  (radians)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;aod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">thd</span><span class="p">,</span> <span class="n">phd</span><span class="p">))</span>

                <span class="c1"># eth : 3 x r</span>
                <span class="n">eth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thd</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phd</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thd</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phd</span><span class="p">),</span>
                                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thd</span><span class="p">)])</span>
                <span class="c1"># eph : 3 x r</span>
                <span class="n">eph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phd</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phd</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phd</span><span class="p">))])</span>

                <span class="c1"># Bo0 : 3 x 2 x r</span>
                <span class="n">Bo0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">eth</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                      <span class="n">eph</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">si</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                                 <span class="n">eth</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                                 <span class="n">eph</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># scalar product si . norm</span>
                <span class="c1">#</span>
                <span class="c1"># vn   : 3 x i x r</span>
                <span class="c1"># s_in : 3 x i x r</span>

                <span class="c1">#</span>
                <span class="c1"># scpr : i x r</span>
                <span class="c1">#</span>
                
                <span class="n">scpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vn</span><span class="o">*</span><span class="n">si</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;scpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scpr</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">scpr</span><span class="p">))</span>  <span class="c1"># *180/np.pi</span>
                

                <span class="k">def</span> <span class="nf">fix_colinear</span><span class="p">():</span>
                    <span class="n">nw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nw</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> \
                            <span class="ow">or</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>

                            <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
                            <span class="c1">#determine which interaction and rays</span>
                            <span class="c1">#present the colinearity issue</span>
                            <span class="n">uvv</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vn</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">uu</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uu</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]])</span><span class="o">&gt;</span><span class="mf">0.99</span>
                            <span class="c1"># uv : nbi x nbr colinear index</span>
                            <span class="n">uv</span> <span class="o">=</span> <span class="n">uu</span><span class="p">[</span><span class="n">uvv</span><span class="p">]</span>
                            <span class="c1"># uh : nbi x nbr anti-colinear index</span>
                            <span class="n">uh</span> <span class="o">=</span> <span class="n">uu</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">uvv</span><span class="p">)]</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1">#fiw w for colinear index</span>
                                <span class="n">w</span><span class="p">[:,</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                                <span class="c1"># update normal</span>
                                <span class="n">nw</span><span class="p">[</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> \
                                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">[:,</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="n">w</span><span class="p">[:,</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c1"># fix w for anti-colinear index</span>
                                <span class="n">w</span><span class="p">[:,</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                                <span class="c1"># update normal</span>
                                <span class="n">nw</span><span class="p">[</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> \
                                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">[:,</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="n">w</span><span class="p">[:,</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">uh</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="k">pass</span>
                    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">nw</span>
                <span class="c1">#</span>
                <span class="c1"># Warning need to handle singular case when s_in // vn</span>
                <span class="c1">#</span>
                <span class="c1"># w : 3 x i x r</span>
                <span class="c1">#</span>
                <span class="c1"># Handling channel reciprocity s_in --&gt; -s_in</span>
                <span class="c1">#</span>
                <span class="c1">#w = np.cross(s_in, vn, axisa=0, axisb=0, axisc=0)</span>

                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="o">-</span><span class="n">s_in</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># nw : i x r</span>
                <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="o">=</span> <span class="n">fix_colinear</span><span class="p">()</span>

                <span class="n">wn</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">nw</span>
                <span class="c1"># Handling channel reciprocity s_in --&gt; -s_in</span>
                <span class="c1">#v = np.cross(wn, s_in, axisa=0, axisb=0, axisc=0)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="o">-</span><span class="n">s_in</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">es_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="o">-</span><span class="n">s_in</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1">#  Bi 3 x 2 x i x r</span>
                <span class="n">Bi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ew</span><span class="p">,</span> <span class="n">ev</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">#  self[k][&#39;Bi&#39;] 3 x 3 x i x r</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">es_in</span><span class="p">,</span><span class="n">ew</span><span class="p">,</span><span class="n">ev</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">################################</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">s_out</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="o">=</span> <span class="n">fix_colinear</span><span class="p">()</span>
                <span class="c1">#wn = w/np.sqrt(np.sum(w*w, axis=0))</span>
                <span class="n">wn</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">nw</span>

                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="n">s_out</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">es_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">s_out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1">#  Bi 3 x 2 x i x r</span>
                <span class="n">Bo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ew</span><span class="p">,</span> <span class="n">ev</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                 <span class="c1"># self[k][&#39;Bo&#39;] 3 x 3 x i x r </span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">es_out</span><span class="p">,</span><span class="n">ew</span><span class="p">,</span><span class="n">ev</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1">#</span>
                <span class="c1"># AOA (rad)</span>
                <span class="c1">#</span>

                <span class="c1"># th : ,r</span>
                <span class="c1"># fix doa/dod reciprocity</span>
                <span class="c1">#th = np.arccos(si[2, -1, :])</span>
                <span class="n">tha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="o">-</span><span class="n">si</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># th : ,r</span>
                <span class="c1">#ph = np.arctan2(si[1, -1, :], si[0, -1, :])</span>
                <span class="n">pha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">si</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">-</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># aoa : 2 x r  (radians)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;aoa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">tha</span><span class="p">,</span> <span class="n">pha</span><span class="p">))</span>
                <span class="n">eth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">tha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pha</span><span class="p">),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">tha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pha</span><span class="p">),</span>
                                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tha</span><span class="p">)])</span>
                <span class="n">eph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pha</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pha</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pha</span><span class="p">))])</span>
                <span class="c1"># Bo0 : 3 x 2 x r</span>
                <span class="n">BiN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">eth</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                      <span class="n">eph</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;BiN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="o">-</span><span class="n">si</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:],</span><span class="n">eth</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:],</span>
                                                   <span class="n">eph</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Creation of B from Bi and Bo</span>
                <span class="c1"># is done after the potential diffraction </span>
                <span class="c1"># computation</span>

                <span class="c1">## index creation</span>
                <span class="c1">##################</span>
                <span class="c1"># create index for retrieving interactions</span>

                <span class="c1"># integer offset : total size idx</span>

                <span class="n">idxts</span> <span class="o">=</span> <span class="n">idxts</span> <span class="o">+</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">idxts</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ityp</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ityp</span><span class="p">),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

                <span class="n">nbray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rays&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nbrays&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbray</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbrayt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbray</span><span class="p">)</span>

                <span class="c1"># create a numpy array to relate the ray index to its corresponding</span>
                <span class="c1"># number of interactions</span>

                <span class="n">_ray2nbi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nbray</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>


                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">,</span><span class="n">_ray2nbi</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="o">=</span><span class="n">_ray2nbi</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]]</span>  <span class="o">=</span> <span class="n">k</span>
                <span class="n">nbrayt</span> <span class="o">=</span> <span class="n">nbrayt</span> <span class="o">+</span> <span class="n">nbray</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raypt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raypt</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nbrays&#39;</span><span class="p">]</span>

                <span class="c1">#################################</span>
                <span class="c1"># Start of diffraction specific process</span>
                <span class="c1">##############################</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="n">Z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ityp</span><span class="o">.</span><span class="n">T</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">udiff</span><span class="o">=</span><span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># diffseg,udiffseg  = np.unique(nstr[udiff],return_inverse=True)</span>
                    <span class="n">diffupt</span><span class="o">=</span><span class="n">nstr</span><span class="p">[</span><span class="n">udiff</span><span class="p">]</span>
                    <span class="c1"># position of diff seg (- because iupnt accept &gt; 0 reference to points)</span>
                    <span class="c1">#</span>
                    <span class="c1"># TO BE FIXED </span>
                    <span class="c1">#</span>
                    <span class="c1">#ptdiff = L.pt[:,L.iupnt[-diffupt]]</span>
                    <span class="n">ptdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">diffupt</span> <span class="p">])</span><span class="o">.</span><span class="n">T</span>

                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="c1"># get tail head position of seg associated to diff point</span>
                    <span class="n">lair</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">L</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span>
                    <span class="n">aseg</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span> <span class="p">:</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lair</span><span class="p">,</span>
                                         <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">x</span><span class="p">)),</span>
                                         <span class="n">diffupt</span><span class="p">)</span>
                    <span class="c1">#manage flat angle : diffraction by flat segment e.g. door limitation)</span>
                    <span class="p">[</span><span class="n">aseg</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aseg</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># get points positions</span>
                    <span class="c1">#pdb.set_trace()</span>
                    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">L</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span><span class="n">aseg</span><span class="p">))</span>
                    
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffslabs&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;name&#39;</span><span class="p">]][</span><span class="s1">&#39;index&#39;</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;_&#39;</span>
                                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;name&#39;</span><span class="p">]][</span><span class="s1">&#39;index&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">aseg</span><span class="p">]</span>

                    <span class="n">uwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffslabs&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">luw</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">uwl</span><span class="p">)</span>


                    <span class="n">pt1</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#tail seg1</span>
                    <span class="n">ph1</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#head seg1</span>
                    <span class="n">pt2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#tail seg2</span>
                    <span class="n">ph2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#head seg2</span>


                    <span class="c1">#pts is (nb_diffraction_points x 4 x 2)</span>
                    <span class="c1">#- The dimension 4 represent the 2x2 points: t1,h1 and t2,h2</span>
                    <span class="c1"># tail and head of segment 1 and 2 respectively</span>
                    <span class="c1"># a segment </span>
                    <span class="c1">#- The dimension 2 is x,y</span>
                    <span class="c1">#</span>
                    <span class="c1"># The following aims to determine which tails and heads of </span>
                    <span class="c1"># segments associated to a given diffraction point </span>
                    <span class="c1"># are connected</span>
                    <span class="c1">#</span>
                    <span class="c1"># </span>

                    <span class="c1"># point diff is pt1</span>
                    <span class="n">updpt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span><span class="o">==</span><span class="n">pt1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># point diff is ph1</span>
                    <span class="n">updph1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span><span class="o">==</span><span class="n">ph1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># point diff is pt2</span>
                    <span class="n">updpt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span><span class="o">==</span><span class="n">pt2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># point diff is ph2</span>
                    <span class="n">updph2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span><span class="o">==</span><span class="n">ph2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">diffupt</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">diffupt</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>

                    <span class="c1">####seg 1 :</span>
                    <span class="c1">#if pt1 diff point =&gt;  ph1 is the other point</span>
                    <span class="n">pa</span><span class="p">[</span><span class="n">updpt1</span><span class="p">]</span><span class="o">=</span> <span class="n">ph1</span><span class="p">[</span><span class="n">updpt1</span><span class="p">]</span>
                    <span class="c1">#if ph1 diff point =&gt;  pt1 is the other point</span>
                    <span class="n">pa</span><span class="p">[</span><span class="n">updph1</span><span class="p">]</span><span class="o">=</span> <span class="n">pt1</span><span class="p">[</span><span class="n">updph1</span><span class="p">]</span>
                    <span class="c1">####seg 2 :</span>
                    <span class="c1">#if pt2 diff point =&gt;  ph2 is the other point</span>
                    <span class="n">pb</span><span class="p">[</span><span class="n">updpt2</span><span class="p">]</span><span class="o">=</span> <span class="n">ph2</span><span class="p">[</span><span class="n">updpt2</span><span class="p">]</span>
                    <span class="c1">#if ph2 diff point =&gt;  pt2 is the other point</span>
                    <span class="n">pb</span><span class="p">[</span><span class="n">updph2</span><span class="p">]</span><span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="n">updph2</span><span class="p">]</span>

                    <span class="n">pt</span> <span class="o">=</span> <span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span>

                    <span class="c1"># NN : (nb_diffraction_points)</span>
                    <span class="c1"># alpha wegde (a.k.a. wedge parameters, a.k.a wedge aperture)</span>

                    <span class="n">NN</span> <span class="o">=</span> <span class="p">(</span><span class="mf">360.</span><span class="o">-</span><span class="n">geu</span><span class="o">.</span><span class="n">sector</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">pt</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">/</span><span class="mf">180.</span>
                    <span class="c1"># NN = (2.-NN)*np.pi</span>

                    <span class="c1">#angle between face 0, diffraction point and s_in</span>
                    <span class="c1">#s_in[:2,udiff[0],udiff[1]]  : </span>
                    <span class="c1"># s_in of insteractions udiff (2D) restricted to diffraction points</span>
                    <span class="n">vptpa</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-</span><span class="n">pa</span>
                    <span class="n">vptpan</span> <span class="o">=</span> <span class="n">vptpa</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">vptpa</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">vptpa</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="c1"># vpapt= pa-pt # papt : direction vector of face 0 </span>
                    <span class="c1"># vpaptn = vpapt.T / np.sqrt(np.sum((vpapt)*(vpapt),axis=1))</span>
                    <span class="n">sid</span> <span class="o">=</span> <span class="n">s_in</span><span class="p">[:,</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#s_in restricted to diff</span>
                    <span class="n">sod</span> <span class="o">=</span> <span class="n">s_out</span><span class="p">[:,</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1">#s_out restricted to diff</span>
                    <span class="n">vnormz</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">][:,</span> <span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>


                    <span class="c1">#phi0 = arccos(dot(sid*vpavptn))</span>
                    <span class="c1"># phi0 = geu.vecang(sid[:2],vpaptn)</span>
                    <span class="n">uleft</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">isleft</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">pt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">pb</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">phi0</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">vecang</span><span class="p">(</span><span class="n">vptpan</span><span class="p">,</span><span class="n">sid</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">phi0</span><span class="p">[</span><span class="o">~</span><span class="n">uleft</span><span class="p">]</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">vecang</span><span class="p">(</span><span class="n">sid</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">~</span><span class="n">uleft</span><span class="p">],</span><span class="n">vptpan</span><span class="p">[:,</span><span class="o">~</span><span class="n">uleft</span><span class="p">])</span>
                    <span class="c1"># phi0 = np.arccos(np.sum(sid[:2]*vpaptn,axis=0))</span>

                    <span class="c1">#phi = arccos(dot(sod*vpavptn))</span>
                    <span class="c1"># phi = np.arccos(np.sum(-sod[:2]*vpaptn,axis=0))</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">vecang</span><span class="p">(</span><span class="n">vptpan</span><span class="p">,</span><span class="o">-</span><span class="n">sod</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">phi</span><span class="p">[</span><span class="o">~</span><span class="n">uleft</span><span class="p">]</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">vecang</span><span class="p">(</span><span class="o">-</span><span class="n">sod</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">~</span><span class="n">uleft</span><span class="p">],</span><span class="n">vptpan</span><span class="p">[:,</span><span class="o">~</span><span class="n">uleft</span><span class="p">])</span>
                    <span class="c1"># beta</span>
                    <span class="c1">#it is important to check if the sid comes from left or right</span>
                    <span class="c1">#to this end assume that sid vector is composed</span>
                    <span class="c1">#of 2 point : (0,0) and sid</span>
                    <span class="c1"># compared to the position of the diffraction point in x</span>
                    <span class="c1"># with an elevation=0</span>
                    <span class="n">sidxz</span> <span class="o">=</span> <span class="n">sid</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">vnormxz</span> <span class="o">=</span> <span class="n">vnormz</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">zdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ptdiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">zero</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">isleft</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span><span class="n">sidxz</span><span class="p">,</span><span class="n">zdiff</span><span class="p">)</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vnormz</span><span class="o">*</span><span class="n">sid</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

                    <span class="c1"># self[k][&#39;diffvect&#39;] is (4 x Nb_rays )</span>
                    <span class="c1"># for axis 0 lenght 4 represent :</span>
                    <span class="c1"># 0 =&gt; phi0</span>
                    <span class="c1"># 1 =&gt; phi</span>
                    <span class="c1"># 2 =&gt; beta</span>
                    <span class="c1"># 3 =&gt; N (wedge parameter)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffvect&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">phi0</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">NN</span><span class="p">))</span>

                    <span class="c1">######</span>
                    <span class="c1">#Bi diffract</span>
                    <span class="c1">#####</span>
                    <span class="c1">#w is the \perp \soft in diff</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="o">-</span><span class="n">sid</span><span class="p">,</span><span class="n">vnormz</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># nw : i x r</span>
                    <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="o">=</span> <span class="n">fix_colinear</span><span class="p">()</span>

                    <span class="n">wn</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">nw</span>
                    <span class="c1"># Handling channel reciprocity s_in --&gt; -s_in</span>
                    <span class="c1">#v = np.cross(wn, s_in, axisa=0, axisb=0, axisc=0)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="o">-</span><span class="n">sid</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">e_sid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="o">-</span><span class="n">sid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">ew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1">#  Bid 3 x 2 x (i,r)diff</span>
                    <span class="n">Bid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ev</span><span class="p">,</span> <span class="n">ew</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1">#update Bi for diffracted rays</span>
                    <span class="n">Bi</span><span class="p">[:,:,</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Bid</span>
                    <span class="c1">######</span>
                    <span class="c1">#Bo diffract</span>
                    <span class="c1">#####</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">sod</span><span class="p">,</span><span class="n">vnormz</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">w</span><span class="p">,</span> <span class="n">nw</span> <span class="o">=</span> <span class="n">fix_colinear</span><span class="p">()</span>
                    <span class="n">wn</span> <span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">nw</span>

                    <span class="c1">#wn = w/np.sqrt(np.sum(w*w, axis=0))</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="n">sod</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">e_sod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sod</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">ew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">wn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1">#  Bod 3 x 2 x (i,r)diff</span>
                    <span class="n">Bod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ev</span><span class="p">,</span> <span class="n">ew</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1">#update Bo for diffracted rays</span>
                    <span class="n">Bo</span><span class="p">[:,:,</span><span class="n">udiff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">udiff</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Bod</span>
                <span class="c1">#################################</span>
                <span class="c1"># End of diffraction specifc process</span>
                <span class="c1">##############################</span>


<span class="c1">#</span>
                <span class="c1"># pasting (Bo0,B,BiN)</span>
                <span class="c1">#</span>

                <span class="c1"># B : 3 x 2 x i x r</span>

                <span class="n">Bo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Bo0</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Bo</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Bi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Bi</span><span class="p">,</span> <span class="n">BiN</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># B : 2 x 2 x i x r</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;xv...,xw...-&gt;vw...&#39;</span><span class="p">,</span> <span class="n">Bi</span><span class="p">,</span> <span class="n">Bo</span><span class="p">)</span>

                <span class="c1">#BiN = np.array([si[:,-1,:], eth, eph])    # ndim x 3 x Nray</span>
                <span class="c1">#self[k][&#39;BiN&#39;]=BiN</span>
                <span class="c1"># self[k][&#39;B&#39;]=np.sum(self[k][&#39;Bi&#39;][:2,:2,np.newaxis]*self[k][&#39;Bo&#39;][np.newaxis,:2,:2],axis=1)</span>


            <span class="c1"># if los exists</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nstrwall&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
                <span class="n">si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;si&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">si</span><span class="p">,</span><span class="mf">0.</span><span class="p">))</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;vsi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">si</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">si</span><span class="p">))</span>

                <span class="n">vsi</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;vsi&#39;</span><span class="p">]</span>
                <span class="n">thd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">vsi</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">phd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vsi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vsi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;aod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">thd</span><span class="p">,</span> <span class="n">phd</span><span class="p">))</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;Bo0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;scpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

                <span class="c1">#</span>
                <span class="c1"># The following derivation of the doa is the actual chosen angle convention</span>
                <span class="c1"># Those angles are relative to natural spherical coordinates system in the gcs of the scene.</span>
                <span class="c1">#</span>
                <span class="c1"># for a LOS path :</span>
                <span class="c1">#  tha = pi - thd</span>
                <span class="c1">#  pha = phd - pi</span>
                <span class="c1">#</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;aoa&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">thd</span><span class="p">,</span> <span class="n">phd</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">E</span><span class="p">,</span><span class="n">E</span><span class="p">))</span>
                <span class="n">ze</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rays&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nbrays&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ze</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raypt</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span> <span class="o">=</span> <span class="n">ze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_luw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">luw</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isbased</span><span class="o">=</span><span class="bp">True</span></div>

<div class="viewcode-block" id="Rays.fillinter"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.fillinter.html#pylayers.antprop.rays.Rays.fillinter">[docs]</a>    <span class="k">def</span> <span class="nf">fillinter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  fill ray interactions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L      : Layout</span>
<span class="sd">        append : Boolean</span>
<span class="sd">            If True append new rays to existing structure</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Update self.I , self.B , self.I0</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># reinitialized ray pointer if not in append mode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raypt</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># stacked interactions</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">Interactions</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">)</span>

        <span class="c1"># rotation basis</span>
        <span class="n">B</span>  <span class="o">=</span> <span class="n">IntB</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">B0</span> <span class="o">=</span> <span class="n">IntB</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">)</span>

        <span class="c1"># # LOS Interaction</span>
        <span class="c1"># Los = IntL()</span>

        <span class="c1"># Reflexion</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">IntR</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">)</span>

        <span class="c1"># Transmission</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">IntT</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">)</span>

        <span class="c1"># Diffraction</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">IntD</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">:</span>
            <span class="n">idxts</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">nbrayt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idxts</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nbrayt</span> <span class="o">=</span> <span class="mi">0</span>


        <span class="c1"># Transform dictionnary of slab name to array</span>
        <span class="c1"># slv = nx.get_node_attributes(L.Gs, &quot;name&quot;).values()</span>
        <span class="c1"># slk = nx.get_node_attributes(L.Gs, &quot;name&quot;).keys()</span>
        <span class="c1"># find all material used in simulation</span>
        <span class="c1">#uslv = np.unique(L.sla[1:])</span>
        <span class="n">uslv</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="c1"># add CEIL and FLOOR</span>
        <span class="c1">#</span>
        <span class="c1">#uslv = np.hstack((uslv, np.array((&#39;CEIL&#39;, &#39;FLOOR&#39;))))</span>

        <span class="c1"># create reverse dictionnary with all material as a key</span>
        <span class="c1"># and associated point/segment as a value</span>

        <span class="c1">#dsla = {}</span>
        <span class="c1">#for s in uslv:</span>
        <span class="c1">#    dsla[s] = np.where(s == np.array(slv))[0]</span>

        <span class="n">nsmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1">#sla = np.zeros((nsmax+1), dtype=&#39;S20&#39;)</span>

        <span class="c1"># array type str with more than 1 character</span>
        <span class="c1"># warning use zeros instead of empty because slab zero</span>
        <span class="c1"># is virtually used before assigning correct slab to ceil and floor</span>

        <span class="c1">#</span>
        <span class="c1"># sla is an array of string.</span>
        <span class="c1"># each value of Gs node is the index of the corresponding slab</span>
        <span class="c1">#</span>

        <span class="c1">#sla[slk] = np.array(slv)</span>

        <span class="n">R</span><span class="o">.</span><span class="n">dusl</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">uslv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">T</span><span class="o">.</span><span class="n">dusl</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">uslv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        
        <span class="c1">#to be specified and limited to used wedges</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;_luw&#39;</span><span class="p">):</span>
            <span class="n">D</span><span class="o">.</span><span class="n">dusl</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_luw</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="c1"># transmission/reflection slab array</span>
        <span class="n">tsl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
        <span class="n">rsl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
        <span class="c1"># diffraction wedge list</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>

        <span class="c1"># loop on group of interactions</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>

                <span class="n">uR</span> <span class="o">=</span> <span class="n">uT</span> <span class="o">=</span> <span class="n">uD</span> <span class="o">=</span> <span class="n">uRf</span> <span class="o">=</span> <span class="n">uRc</span> <span class="o">=</span> <span class="mf">0.</span>

                <span class="c1"># structure number (segment or point)</span>
                <span class="c1"># nstr : i x r</span>
                <span class="n">nstr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># ityp : i x r</span>
                <span class="n">ityp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># theta : i x r   ( related to interactions )</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>

                <span class="c1"># (i+1) x r</span>
                <span class="n">si</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;si&#39;</span><span class="p">]</span>
                <span class="c1"># distance in</span>
                <span class="n">s_in</span> <span class="o">=</span> <span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="c1"># distance in</span>
                <span class="n">s_out</span> <span class="o">=</span> <span class="n">si</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;diffvect&#39;</span><span class="p">):</span>

                    <span class="n">dvec</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffvect&#39;</span><span class="p">]</span>
                    <span class="n">ldsl</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffslabs&#39;</span><span class="p">]</span>
                    <span class="n">dix</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffidx&#39;</span><span class="p">]</span>


                <span class="c1">## flatten information</span>
                <span class="c1">######################</span>

                <span class="c1"># flatten nstr (1 dimension)</span>
                <span class="c1"># size1 = i x r</span>
                <span class="n">size1</span> <span class="o">=</span> <span class="n">nstr</span><span class="o">.</span><span class="n">size</span>

                <span class="c1"># flatten ityp (method faster than np.ravel() )</span>
                <span class="n">nstrf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nstr</span><span class="p">,</span><span class="n">size1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="n">itypf</span> <span class="o">=</span> <span class="n">ityp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="n">thetaf</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">size1</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1">#sif = si[0, :, :].reshape(si[0, :, :].size)</span>

                <span class="c1"># ## index creation / already done in rays.locbas</span>
                <span class="c1"># ##################</span>
                <span class="c1"># # create index for retrieving interactions</span>

                <span class="c1"># # integer offset : total size idx</span>

                <span class="c1"># idxts = idxts + idx.size</span>

                <span class="c1"># idx = idxts + np.arange(ityp.size).reshape(np.shape(ityp),order=&#39;F&#39;)</span>

                <span class="c1"># nbray = np.shape(idx)[1]</span>

                <span class="c1"># self[k][&#39;rays&#39;] = idx</span>
                <span class="c1"># self[k][&#39;nbrays&#39;] = nbray</span>
                <span class="c1"># self[k][&#39;rayidx&#39;] = nbrayt + np.arange(nbray)</span>
                <span class="c1"># # create a numpy array to relate the ray index to its corresponding</span>
                <span class="c1"># # number of interactions</span>

                <span class="c1"># # _ray2nbi = np.ones((nbray))</span>

                <span class="c1"># #try:</span>
                <span class="c1"># #    self._ray2nbi=np.hstack((self._ray2nbi,_ray2nbi))</span>
                <span class="c1"># #except:</span>
                <span class="c1"># #    self._ray2nbi=_ray2nbi</span>

                <span class="c1"># #self._ray2nbi[self[k][&#39;rayidx&#39;]]  = k</span>
                <span class="c1"># nbrayt = nbrayt + nbray</span>
                <span class="c1"># #self.raypt = self.raypt + self[k][&#39;nbrays&#39;]</span>

                <span class="n">idxf</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rays&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rays&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1">#  (i+1)xr</span>
                <span class="c1"># </span>

                <span class="n">size2</span> <span class="o">=</span> <span class="n">si</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">size</span>
                <span class="n">nbray</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;nbrays&#39;</span><span class="p">]</span>

                <span class="c1">#  ,(i+1)xr</span>
                <span class="c1"># sif = si[:, :].reshape(size2,order=&#39;F&#39;) # TO BE REMOVE</span>
                <span class="n">s_inf</span> <span class="o">=</span> <span class="n">s_in</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ityp</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="n">s_outf</span> <span class="o">=</span> <span class="n">s_out</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ityp</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

                <span class="c1"># 2x2,(i+1)xr</span>

                <span class="c1">#</span>
                <span class="c1"># self[k][&#39;B&#39;] 2 x 2 x i x r</span>
                <span class="c1">#</span>
                <span class="c1"># first unitary matrix (2x2xr)</span>
                <span class="n">b0</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;B&#39;</span><span class="p">][:,:,</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="c1"># first unitary matrix 1:</span>
                <span class="c1"># dimension i and r are merged</span>
                <span class="n">b</span>  <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;B&#39;</span><span class="p">][:,:,</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size2</span><span class="o">-</span><span class="n">nbray</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>


                <span class="c1">## find used slab</span>
                <span class="c1">##################</span>
                <span class="c1"># find slab type for the rnstr</span>
                <span class="c1"># nstrf is a number of slab</span>
                <span class="c1"># this is a problem for handling subsegment</span>
                <span class="c1">#</span>
                
                <span class="c1"># seek for interactions position</span>
                <span class="c1">################################</span>

                <span class="n">uD</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">itypf</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uR</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">itypf</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uT</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">itypf</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uRf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">itypf</span> <span class="o">==</span> <span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uRc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">itypf</span> <span class="o">==</span> <span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># assign floor and ceil slab</span>
                <span class="c1">############################</span>

                <span class="n">slT</span><span class="o">=</span><span class="p">[</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nstrf</span><span class="p">[</span><span class="n">uT</span><span class="p">]</span> <span class="p">]</span>
                <span class="n">slR</span><span class="o">=</span><span class="p">[</span> <span class="n">L</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nstrf</span><span class="p">[</span><span class="n">uR</span><span class="p">]</span> <span class="p">]</span>

                <span class="c1"># WARNING</span>
                <span class="c1"># in future versions floor and ceil could be different for each cycle.</span>
                <span class="c1"># this information would be directly obtained from L.Gs</span>
                <span class="c1"># then the two following lines would have to be modified</span>

                <span class="n">slRf</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;FLOOR&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">uRf</span><span class="p">))</span>
                <span class="n">slRc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;CEIL&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">uRc</span><span class="p">))</span>


                <span class="c1"># Fill the used slab</span>
                <span class="c1">#####################</span>

                <span class="n">tsl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tsl</span><span class="p">,</span> <span class="n">slT</span><span class="p">))</span>
                <span class="n">rsl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">rsl</span><span class="p">,</span> <span class="n">slR</span><span class="p">,</span> <span class="n">slRf</span><span class="p">,</span> <span class="n">slRc</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;diffvect&#39;</span><span class="p">):</span> 
                    <span class="n">dw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">dw</span><span class="p">,</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffslabs&#39;</span><span class="p">]))</span> 
    <span class="c1">##            for s in uslv:</span>
    <span class="c1">##</span>
    <span class="c1">##                T.dusl[s]=np.hstack((T.dusl[s],len(T.idx) + np.where(sl[uT]==s)[0]))</span>
    <span class="c1">##                R.dusl[s]=np.hstack((R.dusl[s],len(R.idx) + np.where(sl[uR]==s)[0]))</span>
    <span class="c1">##            R.dusl[&#39;FLOOR&#39;]=np.hstack((R.dusl[&#39;FLOOR&#39;],len(R.idx)+len(uR) + np.where(sl[uRf]==&#39;FLOOR&#39;)[0]))</span>
    <span class="c1"># R.dusl[&#39;CEIL&#39;]=np.hstack((R.dusl[&#39;CEIL&#39;],len(R.idx)+len(uR)+len(uRf) +</span>
    <span class="c1"># np.where(sl[uRc]==&#39;CEIL&#39;)[0]))</span>

                <span class="c1"># Basis</span>
                <span class="c1"># Hugr issue with B index</span>
                <span class="c1"># Friedman version Bs was entering in the index</span>
                <span class="c1"># maybe B can have the same index that interactions</span>
                <span class="c1"># but this must be managed when evaluation of CIR is made</span>

                <span class="c1"># BU 10/4/2013</span>
                <span class="c1"># .. todo:  This is no longer idxf the good index</span>
                <span class="c1"># why the transposition b is first 2x2x(i+1)xr</span>
                <span class="c1">#                             idxf is (ixr)</span>
                <span class="c1">#</span>
                <span class="c1"># need to check how B is used in eval()</span>
                <span class="c1">#</span>
                <span class="c1"># Warning</span>
                <span class="c1"># -------</span>
                <span class="c1"># B.idx refers to an interaction index</span>
                <span class="c1"># whereas B0.idx refers to a ray number</span>

                <span class="n">B</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxf</span><span class="p">)</span>
                <span class="n">B0</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">b0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">])</span>

                <span class="c1">### Reflexion</span>
                <span class="c1">############</span>
                <span class="c1">### wall reflexion</span>
                <span class="c1">#(theta, s_in,s_out)</span>

                <span class="n">R</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">thetaf</span><span class="p">[</span><span class="n">uR</span><span class="p">],</span> <span class="n">s_inf</span><span class="p">[</span><span class="n">uR</span><span class="p">],</span> <span class="n">s_outf</span><span class="p">[</span><span class="n">uR</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">idx</span><span class="o">=</span><span class="n">idxf</span><span class="p">[</span><span class="n">uR</span><span class="p">])</span>
                <span class="c1"># floor reflexion</span>
                <span class="n">R</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">thetaf</span><span class="p">[</span><span class="n">uRf</span><span class="p">],</span> <span class="n">s_inf</span><span class="p">[</span><span class="n">uRf</span><span class="p">],</span> <span class="n">s_outf</span><span class="p">[</span><span class="n">uRf</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">idx</span><span class="o">=</span><span class="n">idxf</span><span class="p">[</span><span class="n">uRf</span><span class="p">])</span>
                <span class="c1"># ceil reflexion</span>
                <span class="n">R</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">thetaf</span><span class="p">[</span><span class="n">uRc</span><span class="p">],</span> <span class="n">s_inf</span><span class="p">[</span><span class="n">uRc</span><span class="p">],</span> <span class="n">s_outf</span><span class="p">[</span><span class="n">uRc</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">idx</span><span class="o">=</span><span class="n">idxf</span><span class="p">[</span><span class="n">uRc</span><span class="p">])</span>

                <span class="c1"># R.stack(data=np.array((thetaf[uR], sif[uR], sif[uR+1])).T,</span>
                <span class="c1">#         idx=idxf[uR])</span>
                <span class="c1"># # floor reflexion</span>
                <span class="c1"># R.stack(data=np.array((thetaf[uRf], sif[uRf], sif[uRf+1])).T,</span>
                <span class="c1">#         idx=idxf[uRf])</span>
                <span class="c1"># # ceil reflexion</span>
                <span class="c1"># R.stack(data=np.array((thetaf[uRc], sif[uRc], sif[uRc+1])).T,</span>
                <span class="c1">#         idx=idxf[uRc])</span>

                <span class="c1">### sl[idxf[uT]]</span>
                <span class="c1"># Transmision</span>
                <span class="c1">############</span>
                <span class="c1"># (theta, s_in,s_out)</span>
                <span class="c1"># T.stack(data=np.array((thetaf[uT], sif[uT], sif[uT+1])).T, idx=idxf[uT])</span>
                <span class="n">T</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">thetaf</span><span class="p">[</span><span class="n">uT</span><span class="p">],</span> <span class="n">s_inf</span><span class="p">[</span><span class="n">uT</span><span class="p">],</span> <span class="n">s_outf</span><span class="p">[</span><span class="n">uT</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxf</span><span class="p">[</span><span class="n">uT</span><span class="p">])</span>

                <span class="c1">###</span>
                <span class="c1">#Diffraction</span>
                <span class="c1">#phi0,phi,si,sd,N,mat0,matN,beta</span>
                <span class="c1"># </span>

                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;diffvect&#39;</span><span class="p">):</span> 
                    <span class="c1"># self[k][&#39;diffvect&#39;] = ((phi0,phi,beta,N) x (nb_rayxnb_interactions)   )</span>
                    <span class="c1">#si and so are stacked at the end of self[k][&#39;diffvect&#39;] </span>
                    <span class="c1">#as well:</span>
                    <span class="c1">#data =  (6 x (nb_rayxnb_interactions) )</span>
                    <span class="c1"># ((phi0,phi,beta,N,sin,sout) x (nb_rayxnb_interactions) )</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffvect&#39;</span><span class="p">],</span><span class="n">s_inf</span><span class="p">[</span><span class="n">uD</span><span class="p">],</span><span class="n">s_outf</span><span class="p">[</span><span class="n">uD</span><span class="p">]))</span>
                    <span class="n">D</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;diffidx&#39;</span><span class="p">])</span><span class="c1">#idxf[uD])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">:</span>
                <span class="n">ze</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1">#self[k][&#39;rays&#39;] = np.array(([[0]]))</span>
                <span class="c1">#self[k][&#39;nbrays&#39;] = 1</span>
                <span class="c1">#self[k][&#39;rayidx&#39;] = ze</span>
                <span class="c1">#self.raypt = 1</span>
                <span class="c1">#self._ray2nbi=ze</span>
                <span class="n">B</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span> <span class="n">idx</span><span class="o">=</span><span class="n">ze</span><span class="p">)</span>
                <span class="n">B0</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="n">idx</span><span class="o">=</span><span class="n">ze</span><span class="p">)</span>

        <span class="n">T</span><span class="o">.</span><span class="n">create_dusl</span><span class="p">(</span><span class="n">tsl</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">create_dusl</span><span class="p">(</span><span class="n">rsl</span><span class="p">)</span>
        <span class="n">D</span><span class="o">.</span><span class="n">create_dusl</span><span class="p">(</span><span class="n">dw</span><span class="p">)</span>
        <span class="c1"># create interactions structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span> <span class="o">=</span> <span class="n">I</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">D</span><span class="p">])</span>
        <span class="c1"># create rotation base B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span>
        <span class="c1"># create rotation base B0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B0</span> <span class="o">=</span> <span class="n">B0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="Rays.eval"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.eval.html#pylayers.antprop.rays.Rays.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fGHz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.4</span><span class="p">]),</span><span class="n">ib</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;  field evaluation of rays  </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        fGHz : array</span>
<span class="sd">            frequency in GHz array</span>
<span class="sd">        ib : list of interactions block</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#print &#39;Rays evaluation&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fGHz</span><span class="o">=</span><span class="n">fGHz</span>
        <span class="c1"># evaluation of interaction</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">fGHz</span><span class="p">)</span>
        <span class="c1"># if np.isnan(self.I.I).any():</span>
        <span class="c1">#     pdb.set_trace()</span>
        <span class="c1"># evaluation of base B  (2x2)</span>
        <span class="c1"># B and B0 do no depend on frequency</span>
        <span class="c1"># just an axis extension (np.newaxis)</span>
        <span class="c1">#pdb.set_trace()</span>

        <span class="c1"># 1 x i x 2 x 2</span>
        <span class="n">B</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="c1"># 1 x r x 2 x 2</span>
        <span class="n">B0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B0</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>

        <span class="c1"># Ct : f x r x 2 x 2</span>
        <span class="n">Ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nray</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="c1"># delays : ,r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nray</span><span class="p">))</span>

        <span class="c1"># dis : ,r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nray</span><span class="p">))</span>

        <span class="c1">#nf : number of frequency point</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">nf</span>

        <span class="n">aod</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nray</span><span class="p">))</span>
        <span class="n">aoa</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nray</span><span class="p">))</span>
        <span class="c1"># loop on interaction blocks</span>
        <span class="k">if</span> <span class="n">ib</span><span class="o">==</span><span class="p">[]:</span>
            <span class="n">ib</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ib</span><span class="p">:</span>
            <span class="c1"># ir : ray index</span>

            <span class="n">ir</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span>
            <span class="n">aoa</span><span class="p">[:,</span><span class="n">ir</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;aoa&#39;</span><span class="p">]</span>
            <span class="n">aod</span><span class="p">[:,</span><span class="n">ir</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;aod&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># l stands for the number of interactions</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;nbrays&#39;</span><span class="p">]</span>
                <span class="c1"># reshape in order to have a 1D list of index</span>
                <span class="c1"># reshape ray index</span>
                <span class="n">rrl</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;rays&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">l</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="c1"># get the corresponding evaluated interactions</span>
                <span class="c1">#</span>
                <span class="c1"># reshape error can be tricky to debug.</span>
                <span class="c1">#</span>
                <span class="c1"># f , r , l , 2 , 2</span>
                <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">I</span><span class="p">[:,</span> <span class="n">rrl</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="c1"># get the corresponding unitary matrix B</span>
                <span class="c1"># 1 , r , l , 2 , 2</span>
                <span class="c1">#Bl = B[:, rrl, :, :].reshape(self.I.nf, r, l, 2, 2,order=&#39;F&#39;)</span>
                <span class="n">Bl</span> <span class="o">=</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">rrl</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="c1"># get the first uitary matrix B0l</span>
                <span class="n">B0l</span> <span class="o">=</span> <span class="n">B0</span><span class="p">[:,</span><span class="n">ir</span><span class="p">,:,</span> <span class="p">:]</span>
                <span class="c1"># get alpha</span>
                <span class="c1"># alpha = self.I.alpha[rrl].reshape(r, l,order=&#39;F&#39;)</span>
                <span class="c1"># # get gamma</span>
                <span class="c1"># gamma = self.I.gamma[rrl].reshape(r, l,order=&#39;F&#39;)</span>
                <span class="c1"># # get si0</span>
                <span class="c1"># si0 = self.I.si0[rrl].reshape(r, l,order=&#39;F&#39;)</span>
                <span class="c1"># # get sout</span>
                <span class="c1"># sout = self.I.sout[rrl].reshape(r, l,order=&#39;F&#39;)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">Z</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>


                <span class="c1">#print &quot;\nrays&quot;,ir</span>
                <span class="c1">#print &quot;-----------------------&quot;</span>
                <span class="c1">## loop on all the interactions of ray with l interactions</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>


    <span class="c1">############################################</span>
    <span class="c1">##                # Divergence factor D</span>
    <span class="c1">###                 not yet implementented</span>
    <span class="c1">############################################</span>
    <span class="c1">#                if i == 0:</span>
    <span class="c1">#                    D0=1./si0[:,1]</span>
    <span class="c1">#                    rho1=si0[:,1]*alpha[:,i]</span>
    <span class="c1">#                    rho2=si0[:,1]*alpha[:,i]*gamma[:,i]</span>
    <span class="c1">#                    D=np.sqrt(</span>
    <span class="c1">#                     ( (rho1 ) / (rho1 + sout[:,i]) )</span>
    <span class="c1">#                     *( (rho2) / (rho2 + sout[:,i])))</span>
    <span class="c1">#                    D=D*D0</span>
    <span class="c1">#                    rho1=rho1+(sout[:,i]*alpha[:,i])</span>
    <span class="c1">#                    rho2=rho2+(sout[:,i]*alpha[:,i]*gamma[:,i])</span>

    <span class="c1">##                     gerer le loss</span>
    <span class="c1">#                    if np.isnan(D).any():</span>
    <span class="c1">#                        p=np.nonzero(np.isnan(D))[0]</span>
    <span class="c1">#                        D[p]=1./sout[p,1]</span>
    <span class="c1">#                else :</span>
    <span class="c1">#                    D=np.sqrt(</span>
    <span class="c1">#                     ( (rho1 ) / (rho1 + sout[:,i]) )</span>
    <span class="c1">#                     *( (rho2) / (rho2 + sout[:,i])))</span>

    <span class="c1">#                    rho1=rho1+(sout[:,i]*alpha[:,i])</span>
    <span class="c1">#                    rho2=rho2+(sout[:,i]*alpha[:,i]*gamma[:,i])</span>
    <span class="c1">############################################</span>

                    <span class="c1">#  A0  (X dot Y)</span>
                    <span class="c1">#  |    |     |</span>
                    <span class="c1">#  v    v     v</span>
                    <span class="c1">##########################</span>
                    <span class="c1">## B  # I  # B  # I  # B #</span>
                    <span class="c1">##########################</span>
                    <span class="c1">#      \_____/   \______/</span>
                    <span class="c1">#         |         |</span>
                    <span class="c1">#       Atmp(i)   Atmp(i+1)</span>
                    <span class="c1">#</span>
                    <span class="c1"># Z=Atmp(i) dot Atmp(i+1)</span>

                    <span class="c1">#X = A [:, :, i, :, :]</span>
                    <span class="c1">#Y = Bl[:, :, i, :, :]</span>
                    <span class="c1"># pdb.set_trace()</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">## First Basis added</span>
                        <span class="n">Atmp</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">B00</span> <span class="o">=</span> <span class="n">B0l</span><span class="p">[:,</span> <span class="p">:,</span>  <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Atmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                                  <span class="o">*</span><span class="n">B00</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Atmp</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">BB</span> <span class="o">=</span> <span class="n">Bl</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">Ztmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Atmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                                  <span class="o">*</span><span class="n">BB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>


                        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Ztmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                                  <span class="o">*</span><span class="n">Z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">BB</span> <span class="o">=</span> <span class="n">Bl</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">BB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                                  <span class="o">*</span><span class="n">Z</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>


                <span class="c1"># fill the C tilde MDA</span>

                <span class="n">Ct</span><span class="p">[:,</span><span class="n">ir</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>

                <span class="c1"># delay computation:</span>
                <span class="c1"># sum the distance from antenna to first interaction si0</span>
                <span class="c1"># and the sum of all outgoing segments</span>
                <span class="c1">#self[l][&#39;dis&#39;] = self.I.si0[self[l][&#39;rays&#39;][0,:]] \</span>
                <span class="c1">#        + np.sum(self.I.sout[self[l][&#39;rays&#39;]], axis=0)</span>

                <span class="c1"># attenuation due to distance</span>
                <span class="c1"># will be removed once the divergence factor will be implemented</span>
                <span class="n">Ct</span><span class="p">[:,</span><span class="n">ir</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Ct</span><span class="p">[:,</span> <span class="n">ir</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">*</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delays</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">0.3</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dis</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span>
        <span class="c1">#</span>
        <span class="c1"># true LOS when no interaction</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">:</span>
            <span class="n">Ct</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:]</span>
            <span class="c1">#self[0][&#39;dis&#39;] = self[0][&#39;si&#39;][0]</span>
            <span class="c1"># Fris</span>
            <span class="n">Ct</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Ct</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">*</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span><span class="o">/</span><span class="mf">0.3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;dis&#39;</span><span class="p">]</span>


        <span class="c1"># To be corrected in a future version</span>
        <span class="n">Ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">Ct</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">c11</span> <span class="o">=</span> <span class="n">Ct</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c12</span> <span class="o">=</span> <span class="n">Ct</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c21</span> <span class="o">=</span> <span class="n">Ct</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c22</span> <span class="o">=</span> <span class="n">Ct</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>


        <span class="c1">#</span>
        <span class="c1"># Construction of the Ctilde channel</span>
        <span class="c1">#</span>
        <span class="n">Cn</span> <span class="o">=</span> <span class="n">Ctilde</span><span class="p">()</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">Cpp</span> <span class="o">=</span> <span class="n">bs</span><span class="o">.</span><span class="n">FUsignal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">fGHz</span><span class="p">,</span> <span class="n">c11</span><span class="p">)</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">Cpt</span> <span class="o">=</span> <span class="n">bs</span><span class="o">.</span><span class="n">FUsignal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">fGHz</span><span class="p">,</span> <span class="n">c12</span><span class="p">)</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">Ctp</span> <span class="o">=</span> <span class="n">bs</span><span class="o">.</span><span class="n">FUsignal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">fGHz</span><span class="p">,</span> <span class="n">c21</span><span class="p">)</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">Ctt</span> <span class="o">=</span> <span class="n">bs</span><span class="o">.</span><span class="n">FUsignal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">fGHz</span><span class="p">,</span> <span class="n">c22</span><span class="p">)</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">nfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">nray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nray</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">tauk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delays</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">fGHz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">fGHz</span>
        <span class="c1"># r x 2</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">tang</span> <span class="o">=</span> <span class="n">aod</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">tangl</span> <span class="o">=</span> <span class="n">aod</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># r x 2</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">rang</span> <span class="o">=</span> <span class="n">aoa</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Cn</span><span class="o">.</span><span class="n">rangl</span> <span class="o">=</span> <span class="n">aoa</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># add aoa and aod</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">evaluated</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span><span class="p">(</span><span class="n">Cn</span><span class="p">)</span></div>





<div class="viewcode-block" id="Rays.ray"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.ray.html#pylayers.antprop.rays.Rays.ray">[docs]</a>    <span class="k">def</span> <span class="nf">ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the index of interactions of r</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        r : integer</span>
<span class="sd">            ray index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ir : index of interactions of r</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raypos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">r</span><span class="p">]][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">r</span><span class="p">]][</span><span class="s1">&#39;rays&#39;</span><span class="p">][:,</span><span class="n">raypos</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">ray2nbi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get interaction block/number of interactions of a given ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        r : integer</span>
<span class="sd">            ray index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        nbi : int</span>
<span class="sd">            interaction block number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">ray2iidx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get interactions index of a given ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ir : integer</span>
<span class="sd">            ray index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        iidx : array</span>
<span class="sd">            interaction index </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray2nbi</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
        <span class="n">ur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">unbi</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ir</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">unbi</span><span class="p">][</span><span class="s1">&#39;rays&#39;</span><span class="p">][:,</span><span class="n">ur</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">slab_nb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the slab numbers of r</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ir : integer</span>
<span class="sd">            ray index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        isl : slabs number</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raypos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">ir</span><span class="p">]][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ir</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">ir</span><span class="p">]][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">raypos</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>


<div class="viewcode-block" id="Rays.typ"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.typ.html#pylayers.antprop.rays.Rays.typ">[docs]</a>    <span class="k">def</span> <span class="nf">typ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span><span class="n">fromR</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns interactions list type of a given ray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ir : integer</span>
<span class="sd">            ray index</span>
<span class="sd">        fromR : bool</span>
<span class="sd">            True : get information from signature in R</span>
<span class="sd">            False: get information in R.I</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># In this function we can see that teh ceil and floor </span>
        <span class="c1"># are hard coded as reflection. This is going to evolve </span>
        <span class="c1"># for implementation of multi floor </span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">fromR</span><span class="p">:</span>
            <span class="n">di</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s1">&#39;D&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="s1">&#39;T&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">:</span><span class="s1">&#39;R&#39;</span><span class="p">}</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span>
            <span class="n">raypos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">nbi</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ir</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">nbi</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">raypos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inter</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">typ</span><span class="p">[</span><span class="n">a</span><span class="p">])</span></div>

<div class="viewcode-block" id="Rays.info"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.info.html#pylayers.antprop.rays.Rays.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ir</span><span class="p">,</span><span class="n">ifGHz</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">matrix</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; provides information for a given ray r</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ir : int</span>
<span class="sd">            ray index</span>
<span class="sd">        ifGHz : int</span>
<span class="sd">            frequency index</span>
<span class="sd">        B: boolean</span>
<span class="sd">            display Basis</span>
<span class="sd">        matrix :</span>
<span class="sd">            display matrix </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluated</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;-------------------------&#39;</span>
            <span class="k">print</span> <span class="s1">&#39;Informations of ray #&#39;</span><span class="p">,</span> <span class="n">ir</span>
            <span class="k">print</span> <span class="s1">&#39;-------------------------</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="n">ray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
            <span class="n">slabnb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slab_nb</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
            <span class="c1"># if there is a diffraction, phi0, phi, beta are shown</span>
            <span class="k">if</span> <span class="s1">&#39;D&#39;</span> <span class="ow">in</span> <span class="n">typ</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span><span class="bp">True</span>
                <span class="k">print</span> <span class="s1">&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7}, {5:10}, {6:10}, {7:4}, {8:4}, {9:4}&#39;</span>\
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Index&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;type&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;slab&#39;</span><span class="p">,</span> 
                                <span class="s1">&#39;slab_id&#39;</span> <span class="p">,</span>
                                <span class="s1">&#39;th(rad)&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;alpha&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;gamma2&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;phi0&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;phi&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;beta&#39;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span><span class="bp">False</span>
                <span class="k">print</span> <span class="s1">&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7}, {5:10}, {6:10}&#39;</span>\
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Index&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;type&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;slab&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;slab_id&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;th(rad)&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;alpha&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;gamma2&#39;</span><span class="p">)</span>
            <span class="k">print</span> <span class="s1">&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10.2}, {6:10.2}&#39;</span>\
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ir</span><span class="p">,</span> <span class="s1">&#39;B0&#39;</span><span class="p">,</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">iidx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">typ</span><span class="p">):</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span><span class="s1">&#39;D&#39;</span><span class="p">:</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">slab</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">dusl</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="c1">#                    print slab</span>
                        <span class="n">midx</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">dusl</span><span class="p">[</span><span class="n">slab</span><span class="p">]</span>
    <span class="c1">#                    print midx</span>
                        <span class="n">Iidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">I</span><span class="o">.</span><span class="n">idx</span><span class="p">))[</span><span class="n">midx</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span>
                            <span class="n">th</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">I</span><span class="o">.</span><span class="n">dusl</span><span class="p">[</span><span class="n">slab</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">gamma</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">midx</span><span class="p">]</span>
                            <span class="n">alpha</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">alpha</span><span class="p">[</span><span class="n">midx</span><span class="p">]</span>
                        <span class="k">else</span> <span class="p">:</span> 
                            <span class="c1"># from IPython.core.debugger import Tracer</span>
                            <span class="c1"># Tracer()()</span>
                            <span class="n">th</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">Iidx</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NC&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">Iidx</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NC&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">Iidx</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">udiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">idx</span><span class="o">==</span><span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">phi0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">phi0</span><span class="p">[</span><span class="n">udiff</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">phi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">udiff</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">beta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">udiff</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Iidx</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">Ii</span> <span class="o">==</span> <span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> 
                                    <span class="k">print</span> <span class="s1">&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10}, {6:10}, {7:3.4}, {8:3.4}, {9:3.4}&#39;</span>\
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Ii</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">slab</span><span class="p">,</span> <span class="n">slabnb</span><span class="p">[</span><span class="n">iidx</span><span class="p">],</span> <span class="n">th</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span><span class="n">phi0</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">print</span> <span class="s1">&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10.2}, {6:10.2}&#39;</span>\
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Ii</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">slab</span><span class="p">,</span> <span class="n">slabnb</span><span class="p">[</span><span class="n">iidx</span><span class="p">],</span> <span class="n">th</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">B</span><span class="p">:</span>
                            <span class="k">print</span> <span class="s1">&#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:7.2}, {5:10.2}, {6:10.2}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="c1">#              print &#39;{0:5} , {1:4}, {2:10}, {3:7}, {4:10}, {5:10}&#39;.format(ray[iidx], i, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;)</span>

            <span class="k">if</span> <span class="n">matrix</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">----------------------------------------&#39;</span>
                <span class="k">print</span> <span class="s1">&#39; Matrix of ray #&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="s1">&#39;at f=&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">fGHz</span><span class="p">[</span><span class="n">ifGHz</span><span class="p">]</span>
                <span class="k">print</span> <span class="s1">&#39;----------------------------------------&#39;</span>
                <span class="k">if</span> <span class="n">B</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s1">&#39;rotation matrix#&#39;</span><span class="p">,</span> <span class="s1">&#39;type: B0&#39;</span>
                    <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">B0</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ir</span><span class="p">,:,:]</span>
                <span class="k">for</span> <span class="n">iidx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">typ</span><span class="p">):</span>
                    <span class="k">print</span> <span class="s1">&#39;interaction #&#39;</span><span class="p">,</span> <span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">],</span> <span class="s1">&#39;type:&#39;</span><span class="p">,</span> <span class="n">i</span>
                    <span class="c1"># f x l x 2 x 2</span>
                    <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">I</span><span class="p">[</span><span class="n">ifGHz</span><span class="p">,</span> <span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="k">if</span> <span class="n">B</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s1">&#39;rotation matrix#&#39;</span><span class="p">,[</span><span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">]],</span> <span class="s1">&#39;type: B&#39;</span>
                        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ray</span><span class="p">[</span><span class="n">iidx</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">to display matrix, use matrix=True on call&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;Rays have not been evaluated yet&#39;</span></div>

<div class="viewcode-block" id="Rays.signature"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.signature.html#pylayers.antprop.rays.Rays.signature">[docs]</a>    <span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ni</span> <span class="p">,</span><span class="n">nr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; extract ray signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ni : int</span>
<span class="sd">        nr : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sig : ndarray</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Signature of a ray is store as a member</span>

<span class="sd">        r[nint][&#39;sig&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="s1">&#39;sig&#39;</span><span class="p">][:,:,</span><span class="n">nr</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rays.show3d"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays.show3d.html#pylayers.antprop.rays.Rays.show3d">[docs]</a>    <span class="k">def</span> <span class="nf">show3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">ray</span><span class="p">,</span>
               <span class="n">bdis</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">bbas</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">bstruc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">col</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
               <span class="nb">id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; plot a set of 3D rays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ray :</span>
<span class="sd">        block : int</span>
<span class="sd">            interaction block</span>
<span class="sd">        bdis : Boolean</span>
<span class="sd">            if False return .vect filename (True)</span>
<span class="sd">        bbas : Boolean</span>
<span class="sd">            display local basis (False)</span>
<span class="sd">        bstruc : Boolean</span>
<span class="sd">            display structure (True)</span>
<span class="sd">        col  : ndarray() 1x3</span>
<span class="sd">            color of the ray  ([1,0,1])</span>
<span class="sd">        id   : Integer</span>
<span class="sd">            id of the ray (default 0)</span>
<span class="sd">        linewidth : Integer</span>
<span class="sd">            default 1</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filerac</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="s2">&quot;ray&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span> <span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRGEOM&#39;</span><span class="p">])</span>
        <span class="n">_filerac</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">filerac</span><span class="p">)</span>
        <span class="n">filename_list</span> <span class="o">=</span> <span class="n">filerac</span> <span class="o">+</span> <span class="s1">&#39;.list&#39;</span>
        <span class="n">filename_vect</span> <span class="o">=</span> <span class="n">filerac</span> <span class="o">+</span> <span class="s1">&#39;.vect&#39;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">fo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_vect</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;appearance { linewidth </span><span class="si">%d</span><span class="s2"> }</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">linewidth</span><span class="p">)</span>

        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;VECT</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;1 </span><span class="si">%d</span><span class="s2"> 1</span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])):</span>
            <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ray</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">ray</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                     <span class="n">ray</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
        <span class="c1"># fo.write(&quot;%d %d %d 0\n&quot; % (col[0],col[1],col[2]))</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> 0</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># Ajout des bases locales</span>
        <span class="c1">#</span>


        <span class="n">fo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_list</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;LIST</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">filename_vect</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bstruc</span><span class="p">):</span>
            <span class="c1"># fo.write(&quot;{&lt;strucTxRx.off}\n&quot;)</span>
            <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">_filestr</span> <span class="o">+</span> <span class="s2">&quot;.off}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename_list</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">bdis</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># Geomview Visualisation</span>
        <span class="c1">#</span>
            <span class="n">chaine</span> <span class="o">=</span> <span class="s2">&quot;geomview -nopanel -b 1 1 1 &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> \
                <span class="s2">&quot; 2&gt;/dev/null &amp;&quot;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">chaine</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Rays._show3"><a class="viewcode-back" href="../../../modules/generated/pylayers.antprop.rays.Rays._show3.html#pylayers.antprop.rays.Rays._show3">[docs]</a>    <span class="k">def</span> <span class="nf">_show3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="p">[],</span><span class="n">rlist</span><span class="o">=</span><span class="p">[],</span><span class="n">newfig</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; plot 3D rays in environment using Mayavi</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout object</span>
<span class="sd">            Layout to be displayed</span>


<span class="sd">        rlist : list</span>
<span class="sd">            list of index rays</span>
<span class="sd">        newfig : boolean (default: False)</span>
<span class="sd">            if true create a new mayavi figure</span>
<span class="sd">            else : use the current</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">newfig</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">fgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>


        <span class="k">if</span> <span class="n">L</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">L</span><span class="o">.</span><span class="n">_filename</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;L argument must be a layout object&#39;</span><span class="p">)</span>

            <span class="n">L</span><span class="o">.</span><span class="n">_show3</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;ER&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ER&#39;</span><span class="p">]</span>
            <span class="n">color_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ER</span><span class="p">))</span>
            <span class="n">uER</span> <span class="o">=</span> <span class="n">ER</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">colors</span><span class="o">=</span> <span class="n">color_range</span><span class="p">[</span><span class="n">uER</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rlist</span> <span class="o">==</span><span class="p">[]:</span>
            <span class="n">nbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nbi</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">])[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span>
                <span class="c1"># number of rays</span>
                <span class="n">nbr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> 
                <span class="c1"># current number of interactions</span>
                <span class="n">cnbi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>

                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,:,</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">cnbi</span><span class="o">*</span><span class="n">nbr</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">cnbi</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="n">cnbi</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbr</span><span class="p">)])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l0</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

                

                <span class="k">if</span> <span class="s1">&#39;ER&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">ridx</span><span class="p">],</span><span class="n">cnbi</span><span class="p">)</span>
                    <span class="c1"># import ipdb</span>
                    <span class="c1"># ipdb.set_trace()</span>
                    <span class="c1"># T = np.repeat(np.linspace(-2 * np.pi, 2 * np.pi, nbr),cnbi)</span>
                    <span class="n">rc</span><span class="p">[::</span><span class="n">cnbi</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

                    <span class="n">src</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">scalar_scatter</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">,:],</span><span class="n">rc</span><span class="p">,</span><span class="n">colormap</span><span class="o">=</span><span class="s1">&#39;hot&#39;</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">src</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">scalar_scatter</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span>
                <span class="n">src</span><span class="o">.</span><span class="n">mlab_source</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">lines</span><span class="o">=</span><span class="n">connection</span>
                <span class="n">src</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">stripper</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
                <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span><span class="n">opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">colormap</span><span class="o">=</span><span class="s1">&#39;hot&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Rays with &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;interactions&#39;</span>
        <span class="k">else</span> <span class="p">:</span>

            <span class="n">nbi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ray2nbi</span><span class="p">[</span><span class="n">rlist</span><span class="p">]</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">nbi</span><span class="p">,</span><span class="n">rlist</span><span class="p">))</span>
            <span class="n">unb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
            <span class="n">unr</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">):</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">==</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unb</span><span class="p">}</span>



            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unb</span><span class="p">:</span>
                <span class="n">raynb</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">unr</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">nbr</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">raynb</span><span class="p">)</span>
                <span class="n">ptidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;rayidx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">raynb</span><span class="p">]</span>
                <span class="c1"># current number of interactions</span>
                <span class="n">cnbi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
  
                <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,:,</span><span class="n">ptidx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">cnbi</span><span class="o">*</span><span class="n">nbr</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>


                <span class="c1"># lines = np.arange(cnbi*nbr).reshape(cnbi,nbr)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cnbi</span><span class="o">*</span><span class="n">nbr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbr</span><span class="p">,</span><span class="n">cnbi</span><span class="p">)</span>

                <span class="c1"># mesh = tvtk.PolyData(points=pt.T, polys=lines)</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">pt</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="n">lines</span><span class="p">)</span>
                <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">extract_edges</span><span class="p">(</span><span class="n">mesh</span><span class="p">),</span>
                                                     <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Rays with &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;interactions&#39;</span></div>

    <span class="k">def</span> <span class="nf">show3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">L</span><span class="o">=</span><span class="p">[],</span>
              <span class="n">bdis</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
              <span class="n">bstruc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
              <span class="n">bbasi</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
              <span class="n">bbaso</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
              <span class="nb">id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">ilist</span><span class="o">=</span><span class="p">[],</span>
              <span class="n">raylist</span><span class="o">=</span><span class="p">[],</span><span class="n">centered</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; plot 3D rays within the simulated environment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bdis : boolean</span>
<span class="sd">            True</span>
<span class="sd">        bstruc : boolean</span>
<span class="sd">            True</span>
<span class="sd">        bbasi : boolean</span>
<span class="sd">            display input basis of each interaction of rays</span>
<span class="sd">        bbaso : boolean</span>
<span class="sd">            display ouput basis of each interaction of rays</span>
<span class="sd">        id : int</span>
<span class="sd">        L : Layout object</span>
<span class="sd">            Layout to be displayed</span>
<span class="sd">        ilist : list of group of interactions</span>
<span class="sd">        raylist : list of index rays</span>
<span class="sd">        centered : boolean</span>
<span class="sd">            if True center the layout before display</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">L</span><span class="o">.</span><span class="n">_filename</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;L argument must be a layout object&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">:</span>
            <span class="n">pg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">strucname</span><span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">geomfile</span><span class="p">(</span><span class="n">centered</span><span class="o">=</span><span class="n">centered</span><span class="p">)</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pg</span><span class="p">,</span><span class="mf">0.</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ilist</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ilist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">pTx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pTx</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="n">pg</span>
        <span class="n">pRx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pRx</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="n">pg</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="s2">&quot;grRay&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.list&quot;</span><span class="p">,</span> <span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRGEOM&#39;</span><span class="p">])</span>
        <span class="n">fo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;LIST</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bstruc</span><span class="p">:</span>
            <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span><span class="o">+</span><span class="n">strucname</span><span class="o">+</span><span class="s2">&quot;.off}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bbasi</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isbased</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Bases have not been computed (self.locbas(Layout)&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   
                    <span class="n">base_listi</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Geomlist</span><span class="p">(</span><span class="s1">&#39;baselisti&#39;</span><span class="p">,</span><span class="n">clear</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">base_listi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LIST</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bbaso</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isbased</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Bases have not been computed (self.locbas(Layout)&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   
                    <span class="n">base_listo</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Geomlist</span><span class="p">(</span><span class="s1">&#39;baselisto&#39;</span><span class="p">,</span><span class="n">clear</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">base_listo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;LIST</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># fo.write(&quot;{&lt;strucTxRx.off}\n&quot;)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ilist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raylist</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">rlist</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">])[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rlist</span> <span class="o">=</span> <span class="n">raylist</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rlist</span><span class="p">:</span>
                    <span class="n">ray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pTx</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pg</span><span class="p">,</span> <span class="n">pRx</span><span class="p">))))</span>
                    <span class="c1"># ray = rays[i][&#39;pt&#39;][:,:,j]</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># print ray</span>
                    <span class="n">fileray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show3d</span><span class="p">(</span><span class="n">ray</span><span class="o">=</span><span class="n">ray</span><span class="p">,</span> <span class="n">bdis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                          <span class="n">bstruc</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt; &quot;</span> <span class="o">+</span> <span class="n">fileray</span> <span class="o">+</span> <span class="s2">&quot; }</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bbasi</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                            <span class="n">filebi</span> <span class="o">=</span> <span class="s1">&#39;bi_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>
                            <span class="n">basi</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">GeomVect</span><span class="p">(</span><span class="n">filebi</span><span class="p">)</span>
                            <span class="n">basi</span><span class="o">.</span><span class="n">geomBase</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Bi&#39;</span><span class="p">][:,:,</span><span class="n">inter</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">pt</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="n">inter</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">base_listi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">filebi</span> <span class="o">+</span><span class="s1">&#39;.vect&#39;</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">filebi</span> <span class="o">=</span> <span class="s1">&#39;bi_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">basi</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">GeomVect</span><span class="p">(</span><span class="n">filebi</span><span class="p">)</span>
                        <span class="n">basi</span><span class="o">.</span><span class="n">geomBase</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;BiN&#39;</span><span class="p">][:,:,</span><span class="n">j</span><span class="p">],</span><span class="n">pt</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">base_listi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">filebi</span> <span class="o">+</span><span class="s1">&#39;.vect&#39;</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bbaso</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                            <span class="n">filebo</span> <span class="o">=</span> <span class="s1">&#39;bo_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>
                            <span class="n">baso</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">GeomVect</span><span class="p">(</span><span class="n">filebo</span><span class="p">)</span>
                            <span class="n">baso</span><span class="o">.</span><span class="n">geomBase</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Bo&#39;</span><span class="p">][:,:,</span><span class="n">inter</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">pt</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="n">inter</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">base_listo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">filebo</span> <span class="o">+</span><span class="s1">&#39;.vect&#39;</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">filebo</span> <span class="o">=</span> <span class="s1">&#39;bo_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">inter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">baso</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">GeomVect</span><span class="p">(</span><span class="n">filebo</span><span class="p">)</span>
                        <span class="n">baso</span><span class="o">.</span><span class="n">geomBase</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Bo0&#39;</span><span class="p">][:,:,</span><span class="n">j</span><span class="p">],</span><span class="n">pt</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;pt&#39;</span><span class="p">][:,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">base_listo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;{&lt;&quot;</span> <span class="o">+</span> <span class="n">filebo</span> <span class="o">+</span><span class="s1">&#39;.vect&#39;</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bbasi</span><span class="p">:</span>
                <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt; &quot;</span> <span class="o">+</span> <span class="s2">&quot;baselisti.list}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bbaso</span><span class="p">:</span>  
                <span class="n">fo</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{&lt; &quot;</span> <span class="o">+</span> <span class="s2">&quot;baselisto.list}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bdis</span><span class="p">):</span>
            <span class="n">chaine</span> <span class="o">=</span> <span class="s2">&quot;geomview &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot; 2&gt;/dev/null &amp;&quot;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">chaine</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
   <span class="c1"># def show3(self,</span>
   <span class="c1">#            bdis=True,</span>
   <span class="c1">#            bstruc=True,</span>
   <span class="c1">#            id=0,</span>
   <span class="c1">#            strucname=&#39;defstr&#39;,</span>
   <span class="c1">#            ilist=[],</span>
   <span class="c1">#            raylist=[],pg=np.array([[0],[0],[0]])):</span>
   <span class="c1">#      &quot;&quot;&quot; plot 3D rays within the simulated environment</span>

   <span class="c1">#      Parameters</span>
   <span class="c1">#      ----------</span>

   <span class="c1">#      bdis : boolean</span>
   <span class="c1">#          True</span>
   <span class="c1">#      bstruc : boolean</span>
   <span class="c1">#          True</span>
   <span class="c1">#      id : int</span>
   <span class="c1">#      strucname : string</span>
   <span class="c1">#          &#39;defstr&#39;</span>
   <span class="c1">#      ilist : list of group of interactions</span>
   <span class="c1">#      raylist : list of index rays</span>
   <span class="c1">#      pg : centroid of the structure</span>
        

   <span class="c1">#      &quot;&quot;&quot;</span>
   <span class="c1">#      if ilist == []:</span>
   <span class="c1">#          ilist = self.keys()</span>
   <span class="c1">#      pTx = self.pTx.reshape((3, 1))-pg</span>
   <span class="c1">#      pRx = self.pRx.reshape((3, 1))-pg</span>
   <span class="c1">#      filename = pyu.getlong(&quot;grRay&quot; + str(id) + &quot;.list&quot;, pstruc[&#39;DIRGEOM&#39;])</span>
   <span class="c1">#      fo = open(filename, &quot;w&quot;)</span>
   <span class="c1">#      fo.write(&quot;LIST\n&quot;)</span>
   <span class="c1">#      if bstruc:</span>
   <span class="c1">#          fo.write(&quot;{&lt;&quot;+strucname+&quot;.off}\n&quot;)</span>
   <span class="c1">#          # fo.write(&quot;{&lt;strucTxRx.off}\n&quot;)</span>
   <span class="c1">#          k = 0</span>
   <span class="c1">#          for i in ilist:</span>
   <span class="c1">#              if raylist == []:</span>
   <span class="c1">#                  rlist = range(np.shape(self[i][&#39;pt&#39;])[2])</span>
   <span class="c1">#              else:</span>
   <span class="c1">#                  rlist = raylist</span>
   <span class="c1">#              for j in rlist:</span>
   <span class="c1">#                  ray = np.hstack((pTx,np.hstack((self[i][&#39;pt&#39;][:, :, j]-pg, pRx))))</span>
   <span class="c1">#                  # ray = rays[i][&#39;pt&#39;][:,:,j]</span>
   <span class="c1">#                  col = np.array([2, 0, 1])</span>
   <span class="c1">#                  # print ray</span>
   <span class="c1">#                  fileray = self.show3d(ray=ray, bdis=False,</span>
   <span class="c1">#                                        bstruc=False, col=col, id=k)</span>
   <span class="c1">#                  k += 1</span>
   <span class="c1">#                  fo.write(&quot;{&lt; &quot; + fileray + &quot; }\n&quot;)</span>
   <span class="c1">#      fo.close()</span>
   <span class="c1">#      if (bdis):</span>
   <span class="c1">#          chaine = &quot;geomview &quot; + filename + &quot; 2&gt;/dev/null &amp;&quot;</span>
   <span class="c1">#          os.system(chaine)</span>
   <span class="c1">#      else:</span>
   <span class="c1">#          return(filename)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>
  

    <div class="footer">
        &copy; 2016, PyLayers developer team.
      Last updated on Oct 22, 2016.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5a0. Design by <a href="http://desgrana.es">Desgrana</a>.
    </div>
     <div class="rel">
    
    <div class="buttonPrevious">
      <a href="../../../py-modindex.html">
        Previous
      </a>  
    </div>
    
     </div>
     <script type="text/javascript">
       $("div.buttonNext, div.buttonPrevious").hover(
           function () {
               $(this).css('background-color', '#AFFFFF');
           },
           function () {
               $(this).css('background-color', '#AFFFFF');
           }
       );
     </script>
  </body>
</html>