

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.gis.layout &mdash; PyLayers</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  

  
        <link rel="author" title="About these documents"
              href="../../../about.html"/>
    <link rel="top" title="PyLayers" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">35&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">36&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">37&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">38&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">39&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id134">40&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Python</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>pylayers.gis.layout</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.gis.layout</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#   LAYOUT  Module</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. currentmodule:: pylayers.gis.layout</span>

<span class="sd">.. autosummary:: </span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
    <span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Layout:Mayavi is not installed&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="kn">as</span> <span class="nn">rd</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="kn">as</span> <span class="nn">sparse</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">triangle</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="kn">as</span> <span class="nn">clr</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">from</span> <span class="nn">networkx.readwrite</span> <span class="kn">import</span> <span class="n">write_gpickle</span><span class="p">,</span> <span class="n">read_gpickle</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.basemap</span> <span class="kn">import</span> <span class="n">Basemap</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="kn">as</span> <span class="nn">sh</span>
<span class="kn">import</span> <span class="nn">shapefile</span> <span class="kn">as</span> <span class="nn">shp</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">cascaded_union</span>
<span class="kn">from</span> <span class="nn">descartes.patch</span> <span class="kn">import</span> <span class="n">PolygonPatch</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="kn">import</span> <span class="nn">PIL.Image</span> <span class="kn">as</span> <span class="nn">Image</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
    <span class="kn">from</span>  <span class="nn">urllib2</span> <span class="kn">import</span> <span class="n">urlopen</span>
    <span class="kn">import</span> <span class="nn">ConfigParser</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span>  <span class="nn">urllib.request</span> <span class="kn">import</span> <span class="n">urlopen</span>
    <span class="kn">import</span> <span class="nn">configparser</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="c1">#from cStringIO import StringIO</span>

<span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="kn">import</span> <span class="n">ProcessingPool</span> <span class="k">as</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="kn">import</span> <span class="n">cpu_count</span>


<span class="c1"># from multiprocessing import Pool</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">_pickle_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
	<span class="n">func_name</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">im_func</span><span class="o">.</span><span class="n">__name__</span>
	<span class="n">obj</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">im_self</span>
	<span class="n">cls</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">im_class</span>
	<span class="k">if</span> <span class="n">func_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">func_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span> <span class="c1">#deal with mangled names</span>
		<span class="n">cls_name</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
		<span class="n">func_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">cls_name</span> <span class="o">+</span> <span class="n">func_name</span>
	<span class="k">return</span> <span class="n">_unpickle_method</span><span class="p">,</span> <span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_unpickle_method</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
	<span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">func</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
		<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
			<span class="k">pass</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">break</span>
	<span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">copy_reg</span>
    <span class="n">copy_reg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">_pickle_method</span><span class="p">,</span> <span class="n">_unpickle_method</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">copyreg</span>
    <span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">_pickle_method</span><span class="p">,</span> <span class="n">_unpickle_method</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">pylayers.antprop.slab</span> <span class="kn">as</span> <span class="nn">sb</span>
<span class="kn">from</span> <span class="nn">pylayers.util</span> <span class="kn">import</span> <span class="n">geomutil</span> <span class="k">as</span> <span class="n">geu</span>
<span class="kn">from</span> <span class="nn">pylayers.util</span> <span class="kn">import</span> <span class="n">plotutil</span> <span class="k">as</span> <span class="n">plu</span>
<span class="kn">from</span> <span class="nn">pylayers.util</span> <span class="kn">import</span> <span class="n">pyutil</span> <span class="k">as</span> <span class="n">pyu</span>
<span class="kn">from</span> <span class="nn">pylayers.util</span> <span class="kn">import</span> <span class="n">graphutil</span> <span class="k">as</span> <span class="n">gru</span>
<span class="kn">from</span> <span class="nn">pylayers.util</span> <span class="kn">import</span> <span class="n">cone</span>

<span class="c1"># Handle furnitures</span>

<span class="kn">import</span> <span class="nn">pylayers.gis.furniture</span> <span class="kn">as</span> <span class="nn">fur</span>
<span class="kn">import</span> <span class="nn">pylayers.gis.osmparser</span> <span class="kn">as</span> <span class="nn">osm</span>
<span class="kn">from</span> <span class="nn">pylayers.gis.selectl</span> <span class="kn">import</span> <span class="n">SelectL</span>
<span class="kn">import</span> <span class="nn">pylayers.util.graphutil</span> <span class="kn">as</span> <span class="nn">gph</span>
<span class="kn">import</span> <span class="nn">pylayers.util.easygui</span> <span class="kn">as</span> <span class="nn">eag</span>
<span class="kn">import</span> <span class="nn">pylayers.util.project</span> <span class="kn">as</span> <span class="nn">pro</span>

<div class="viewcode-block" id="pbar"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.pbar.html#pylayers.gis.layout.pbar">[docs]</a><span class="k">def</span> <span class="nf">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">pbar</span><span class="o">=</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pbar</span></div>


<div class="viewcode-block" id="Layout"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout">[docs]</a><span class="k">class</span> <span class="nc">Layout</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">PyLayers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Handling Layout</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    Gs     : Graph of points and segment (structure)</span>
<span class="sd">    Gt     : Graph of convex cycles      (topology)</span>
<span class="sd">    Gv     : Graph of visibility         (visibility)</span>
<span class="sd">    Gi     : Graph of interactions       (interactions)</span>
<span class="sd">    Gr     : Graph of rooms              (rooms)</span>
<span class="sd">    Nnode  : Number of nodes of Gs</span>
<span class="sd">    Nedge  : Number of edges of Gs</span>
<span class="sd">    pt     : points sequence</span>
<span class="sd">    tahe   : tail head</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    This class uses `networkx` to store Layout information</span>

<span class="sd">    Gs : structure</span>
<span class="sd">    Gt : topology </span>
<span class="sd">    Gv : visibility</span>
<span class="sd">    Gi : interaction</span>
<span class="sd">    Gr : room  </span>
<span class="sd">    Gm :  </span>
<span class="sd">    Gw : ways </span>

<span class="sd">    Np</span>
<span class="sd">    Ns </span>
<span class="sd">    Nss </span>

<span class="sd">    ax  : (xmin,ymin,xmax,ymax)</span>
<span class="sd">    axn : (0,Dx,0,Dy)</span>

<span class="sd">    filefur </span>
<span class="sd">    filegeom</span>
<span class="sd">    filematini</span>
<span class="sd">    fileslabini </span>
<span class="sd">    hasboundary</span>
<span class="sd">    segboundary </span>
<span class="sd">    min_sx</span>
<span class="sd">    min_sy</span>
<span class="sd">    max_sx </span>
<span class="sd">    max_sy </span>
<span class="sd">    labels </span>
<span class="sd">    lbltg </span>
<span class="sd">    lboundary </span>
<span class="sd">    listtransition </span>
<span class="sd">    loadosm</span>
<span class="sd">    lsss</span>
<span class="sd">    name </span>
<span class="sd">    normal</span>
<span class="sd">    p2pc</span>
<span class="sd">    pg</span>

<span class="sd">    pt : points coordinates  </span>
<span class="sd">    tahe : segment tail head </span>
<span class="sd">    tgs : graph to segment</span>
<span class="sd">    tsg : segment to graph </span>
<span class="sd">    upnt : array of point index</span>

<span class="sd">    s2pc : segment to point coordinates</span>
<span class="sd">    s2pu : segment to point index</span>
<span class="sd">    sgsg </span>

<span class="sd">    sl </span>


<span class="sd">    typ  : &#39;indoor&#39; | &#39;outdoor&#39;</span>
<span class="sd">    coordinates : &#39;cart&#39;,&#39;lonlat&#39;</span>
<span class="sd">    version</span>
<span class="sd">    _filename </span>
<span class="sd">    _hash</span>

<span class="sd">    _shseg : keys / segment index </span>
<span class="sd">             values / shapely LineString</span>
<span class="sd">    dca    : keys / Gt node </span>
<span class="sd">             values / list of air wall </span>
<span class="sd">    degree : keys / point degree</span>
<span class="sd">             values / array of index </span>
<span class="sd">    display : dictionnary for controling various visualization</span>
<span class="sd">    dsseg : </span>

<span class="sd">    indoor : if True allow indoor penetration </span>
<span class="sd">    isbuilt </span>
<span class="sd">    diffraction </span>

<span class="sd">    maxheight</span>
<span class="sd">    zceil </span>
<span class="sd">    zfloor </span>
<span class="sd">    zmin</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                 <span class="n">_filematini</span><span class="o">=</span><span class="s1">&#39;matDB.ini&#39;</span><span class="p">,</span>
                 <span class="n">_fileslabini</span><span class="o">=</span><span class="s1">&#39;slabDB.ini&#39;</span><span class="p">,</span>
                 <span class="n">_filefur</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                 <span class="n">bcheck</span>  <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>          <span class="c1"># to check Gs</span>
                 <span class="n">bbuild</span>  <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>         <span class="c1"># to build graphs</span>
                 <span class="n">bgraphs</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>         <span class="c1"># to load graph </span>
                 <span class="c1">#bindoor=False,        # to allow indoor penetration for outdoor situations</span>
                 <span class="c1">#bdiffraction=False,   # to include diffraction in Gi </span>
                 <span class="n">bverbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">bcartesian</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">dist_m</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
                 <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;indoor&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; object constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        arg : string</span>
<span class="sd">            layout file name, address or &#39;(lat,lon)&#39;</span>
<span class="sd">        _filematini :</span>
<span class="sd">            material dB file name</span>
<span class="sd">        _fileslabini :</span>
<span class="sd">            slab dB file name</span>
<span class="sd">        _filefur :</span>
<span class="sd">            furniture file name</span>
<span class="sd">        force : booleanlo</span>
<span class="sd">        check : boolean</span>
<span class="sd">        build : boolean </span>
<span class="sd">        verbose : boolean </span>
<span class="sd">        cartesian : boolean </span>
<span class="sd">        dist_m : int </span>
<span class="sd">        typ : string </span>
<span class="sd">            &#39;indoor&#39; | &#39;outdoor&#39;</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># mat = sb.MatDB()</span>
        <span class="c1"># mat.load(_filematini)</span>

        <span class="c1"># self.sl = sb.SlabDB()</span>
        <span class="c1"># self.sl.mat = mat</span>
        <span class="c1"># self.sl.load(_fileslabini)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsss</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#</span>
        <span class="c1"># Initializing graphs</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gs&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gr&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gm&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#</span>
        <span class="c1"># related files</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fileslabini</span> <span class="o">=</span> <span class="n">_fileslabini</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filematini</span> <span class="o">=</span> <span class="n">_filematini</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filefur</span> <span class="o">=</span> <span class="n">_filefur</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hasboundary</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s1">&#39;cart&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;1.3&#39;</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;indoor&#39;</span><span class="p">,</span><span class="s1">&#39;outdoor&#39;</span><span class="p">,</span><span class="s1">&#39;floorplan&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">typ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Layout : unknown Layout typ&quot;</span><span class="p">)</span>
        <span class="c1"># boolean </span>

        <span class="bp">self</span><span class="o">.</span><span class="n">isbuilt</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadosm</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1">#</span>
        <span class="c1"># setting display option</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ticksoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ndsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ndlabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ndlblsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlblsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;fontsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ednodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;subseg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;isonb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;visu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;scaled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;clear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;activelayer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;AIR&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># self.display[&#39;overlay_file&#39;]=&quot;/home/buguen/Pyproject/data/image/&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># self.display[&#39;layerset&#39;] = self.sl.keys()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;box&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxheight</span> <span class="o">=</span> <span class="mf">3.</span>

        <span class="n">newfile</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">loadlay</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">loadosm</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">loadres</span> <span class="o">=</span> <span class="bp">False</span>
       
        <span class="c1">#</span>
        <span class="c1"># Layout main argument</span>
        <span class="c1">#   If no .ini extension provided it is added</span>
        <span class="c1">#</span>
        <span class="n">arg</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.ini&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">string</span>
                <span class="n">loadlay</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.lay&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">string</span>
                <span class="n">loadlay</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.osm&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="s1">&#39;.lay&#39;</span>
                <span class="n">loadosm</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.res&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="s1">&#39;.lay&#39;</span>
                <span class="n">loadres</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;outdoor&#39;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># No argument</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="s1">&#39;newfile.lay&#39;</span>
            <span class="n">newfile</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">SlabDB</span><span class="p">(</span><span class="n">fileslab</span><span class="o">=</span><span class="n">_fileslabini</span><span class="p">,</span> <span class="n">filemat</span><span class="o">=</span><span class="n">_filematini</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxheight</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">newfile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">loadlay</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLAY&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>  <span class="c1"># which exists</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># which do not exist</span>
                    <span class="n">newfile</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;new file - creating a void Layout&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">loadosm</span><span class="p">:</span>  <span class="c1"># load .osm file</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">importosm</span><span class="p">(</span><span class="n">_fileosm</span><span class="o">=</span><span class="n">string</span><span class="p">,</span> <span class="n">cart</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loadosm</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">loadres</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">importres</span><span class="p">(</span><span class="n">_fileres</span><span class="o">=</span><span class="n">string</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">SlabDB</span><span class="p">()</span>
            <span class="k">elif</span> <span class="s1">&#39;(&#39;</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>  <span class="c1"># load from osmapi latlon in string</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">importosm</span><span class="p">(</span><span class="n">latlon</span><span class="o">=</span><span class="n">string</span><span class="p">,</span> <span class="n">dist_m</span><span class="o">=</span><span class="n">dist_m</span><span class="p">,</span> <span class="n">cart</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loadosm</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># load from address geocoding</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">importosm</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">string</span><span class="p">,</span> <span class="n">dist_m</span><span class="o">=</span><span class="n">dist_m</span><span class="p">,</span> <span class="n">cart</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loadosm</span> <span class="o">=</span> <span class="bp">True</span>
            
            <span class="c1"># add boundary if it not exist</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasboundary</span><span class="p">:</span>    
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subseg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updateshseg</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geomfile</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;problem to construct geomfile&quot;</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># check layout </span>
            <span class="c1">#</span>
            <span class="n">bconsistent</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">bcheck</span><span class="p">:</span>
                <span class="n">bconsistent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
            
            <span class="c1"># if Layout is correctly described</span>
            <span class="c1"># check if the graph gpickle files have been built</span>
            <span class="k">if</span> <span class="n">bconsistent</span><span class="p">:</span> 
                <span class="c1">#</span>
                <span class="c1"># build and save graphs </span>
                <span class="c1"># </span>
                <span class="k">if</span> <span class="n">bbuild</span><span class="p">:</span>
                    <span class="c1"># ans = raw_input(&#39;Do you want to build the layout (y/N) ? &#39;)</span>
                    <span class="c1"># if ans.lower()==&#39;y&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>
                <span class="c1">#</span>
                <span class="c1"># load graphs from file </span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">bgraphs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.ini&#39;</span><span class="p">:</span>
                        <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.ini&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.lay&#39;</span><span class="p">:</span>
                        <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.lay&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span>
                                        <span class="s1">&#39;struc&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;gpickle&#39;</span><span class="p">,</span>
                                        <span class="n">dirname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                        <span class="c1"># load graph Gt</span>
                        <span class="c1"># and compare the self._hash from ini file</span>
                        <span class="c1"># with the hash store in node 0 of Gt at time of the last build</span>
                        <span class="c1"># If they are different a rebuild is needeed</span>
                        <span class="c1"># Otherwise all the stored graphs are loaded</span>
                        <span class="c1">#</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dumpr</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                        <span class="c1"># If node 0 exists : the layout has been built</span>

                        <span class="c1"># If .ini file has changed rebuild</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;hash&#39;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dumpr</span><span class="p">(</span><span class="s1">&#39;stvirw&#39;</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">isbuilt</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="n">bbuild</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;.lay file has changed you must rebuild the grahs&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if graph are requested and it not exists a pickle of a graph</span>
                        <span class="c1"># they are built</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">st</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">home</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home</span><span class="p">,</span><span class="s1">&#39;.pylayers&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">uporj</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;project</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">project</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">uporj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Project : &quot;</span> <span class="o">+</span> <span class="n">project</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;_hash&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isbuilt</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s1">&#39;Built with : &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;hash&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s1">&#39;Type : &#39;</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">],</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;struc&#39;</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">))</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Image(&#39;&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Coordinates : &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gs&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Gs : &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;(&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Np</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsss</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;) :&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gt&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Gt : &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gv&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Gv : &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">node</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gi&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Gi : &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">node</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gr&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Gr : &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gw&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Gw : &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">node</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; : &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;----------------</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;degree&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s1">&#39;degree &#39;</span> <span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s1">&#39;number of node points of degree &#39;</span> <span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;xrange : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;yrange : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;center : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;radius : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1"># st = st + &quot;\nUseful dictionnaries&quot; + &quot;\n----------------\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;dca&#39;):</span>
        <span class="c1">#     st = st + &quot;dca {cycle : []} cycle with an airwall&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;di&#39;):</span>
        <span class="c1">#     st = st + &quot;di {interaction : [nstr,typi]}&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;sl&#39;):</span>
        <span class="c1">#     st = st + &quot;sl {slab name : slab dictionary}&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;name&#39;):</span>
        <span class="c1">#     st = st + &quot;name :  {slab :seglist} &quot; +&quot;\n&quot;</span>
        <span class="c1"># st = st + &quot;\nUseful arrays&quot;+&quot;\n----------------\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;pt&#39;):</span>
        <span class="c1">#     st = st + &quot;pt : numpy array of points &quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;normal&#39;):</span>
        <span class="c1">#     st = st + &quot;normal : numpy array of normal &quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;offset&#39;):</span>
        <span class="c1">#     st = st + &quot;offset : numpy array of offset &quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;tsg&#39;):</span>
        <span class="c1">#     st = st + &quot;tsg : get segment index in Gs from tahe&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;isss&#39;):</span>
        <span class="c1">#     st = st + &quot;isss :  sub-segment index above Nsmax&quot;+&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;tgs&#39;):</span>
        <span class="c1">#     st = st + &quot;tgs : get segment index in tahe from self.Gs&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;upnt&#39;):</span>
        <span class="c1">#     st = st + &quot;upnt : get point id index from self.pt&quot;+&quot;\n&quot;</span>
        <span class="c1"># #if hasattr(self,&#39;iupnt&#39;):</span>
        <span class="c1"># #    st = st + &quot;iupnt : get point index in self.pt from point id  &quot;+&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;lsss&#39;):</span>
        <span class="c1">#     st = st + &quot;lsss : list of segments with sub-segment&quot;+&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;sridess&#39;):</span>
        <span class="c1">#     st = st + &quot;stridess : stride to calculate the index of a subsegment&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;sla&#39;):</span>
        <span class="c1">#     st = st + &quot;sla : list of all slab names (Nsmax+Nss+1)&quot; +&quot;\n&quot;</span>
        <span class="c1"># if hasattr(self,&#39;degree&#39;):</span>
        <span class="c1">#     st = st + &quot;degree : degree of nodes &quot; +&quot;\n&quot;</span>
        <span class="c1"># st = st + &quot;\nUseful tip&quot; + &quot;\n----------------\n&quot;</span>
        <span class="c1"># st = st + &quot;Point p in Gs =&gt; p_coord:\n&quot;</span>
        <span class="c1"># #st = st + &quot;p -&gt; u = self.iupnt[-p] -&gt; p_coord = self.pt[:,u]\n\n&quot;</span>
        <span class="c1">#st = st + &quot;Segment s in Gs =&gt; s_ab coordinates \n&quot;</span>
        <span class="c1">#st = st + &quot;s2pc : segment to point coordinates (sparse) [p1,p2] = L.s2pc.toarray().reshape(2,2).T \n&quot;</span>
        <span class="c1">#st = st + \</span>
        <span class="c1">#    &quot;s -&gt; u = self.tgs[s] -&gt; v = self.tahe[:,u] -&gt; s_ab = self.pt[:,v]\n\n&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; addition</span>

<span class="sd">        One can add either a numpy array or an other layout</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
                <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offp</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">offs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="n">other</span><span class="o">.</span><span class="n">offset_index</span><span class="p">(</span><span class="n">offp</span><span class="o">=</span><span class="n">offp</span><span class="p">,</span> <span class="n">offs</span><span class="o">=</span><span class="n">offs</span><span class="p">)</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span><span class="p">)</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Np</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">Np</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Ns</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">Ns</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Nss</span> <span class="o">=</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Nss</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">Nss</span>

        <span class="k">return</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; scale the layout</span>

<span class="sd">        other : scaling factor (np.array or int or float)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Ls : Layout</span>
<span class="sd">            scaled layout</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Gs</span> <span class="o">=</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">)),</span> <span class="s2">&quot; not float&quot;</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot; not 3D&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># scaling x &amp; y</span>
        <span class="c1">#</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">xy</span><span class="p">)))</span>

        <span class="c1">#</span>
        <span class="c1"># scaling z</span>
        <span class="c1">#</span>

        <span class="n">nseg</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nseg</span><span class="p">:</span>
            <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;ss_z&#39;</span> <span class="ow">in</span> <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ls</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># updating numpy array from graph</span>
        <span class="c1">#</span>

        <span class="n">Ls</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Ls</span>


    <span class="k">def</span> <span class="nf">_help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">st</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Useful dictionnaries&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;dca&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;dca {cycle : []} cycle with an airwall&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;di&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;di {interaction : [nstr,typi]}&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sl&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;sl {slab name : slab dictionary}&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;name :  {slab :seglist} &quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Useful arrays&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;pt&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;pt : numpy array of points &quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;normal&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;normal : numpy array of normal &quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;offset&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;offset : numpy array of offset &quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;tsg&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;tsg : get segment index in Gs from tahe&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;isss&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;isss :  sub-segment index above Nsmax&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;tgs&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;tgs : get segment index in tahe from self.Gs&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;upnt&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;upnt : get point id index from self.pt&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Useful Sparse arrays&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sgsg&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;sgsg : &quot;</span><span class="o">+</span><span class="s2">&quot;get common point of 2 segment (usage self.sgsg[seg1,seg2] =&gt; return common point </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;s2pc&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;s2pc : &quot;</span><span class="o">+</span><span class="s2">&quot;from a Gs segment node to its 2 extremal points (tahe) coordinates</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;s2pu&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;s2pc : &quot;</span><span class="o">+</span><span class="s2">&quot;from a Gs segment node to its 2 extremal points (tahe) index</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;p2pu&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;p2pc : &quot;</span><span class="o">+</span><span class="s2">&quot;from a Gs point node to its coordinates</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Useful lists&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1">#if hasattr(self,&#39;iupnt&#39;):</span>
        <span class="c1">#    st = st + &quot;iupnt : get point index in self.pt from point id  &quot;+&quot;\n&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;lsss&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;lsss : list of segments with sub-segment&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sridess&#39;</span><span class="p">):</span> 
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;stridess : stride to calculate the index of a subsegment&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sla&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;sla : list of all slab names (Nsmax+Nss+1)&quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;degree&#39;</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;degree : degree of nodes &quot;</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Useful tip&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Point p in Gs =&gt; p_coord: Not implemented</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1"># st = st + &quot;p -&gt; u = self.upnt[-p] -&gt; p_coord = self.pt[:,-u]\n\n&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> <span class="s2">&quot;Segment s in Gs =&gt; s_ab coordinates </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span> <span class="o">+</span> \
            <span class="s2">&quot;s -&gt; u = self.tgs[s] -&gt; v = self.tahe[:,u] -&gt; s_ab = self.pt[:,v]</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>

<div class="viewcode-block" id="Layout.ls"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.ls">[docs]</a>    <span class="k">def</span> <span class="nf">ls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;lay&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; list the available file in dirstruc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        typ : string optional</span>
<span class="sd">            {&#39;ini&#39;|&#39;osm&#39;|&#39;wrl&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        lfile_s : list</span>
<span class="sd">            sorted list of all the .str file of strdir</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        strdir is defined in the Project module</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Display all available structures</span>


<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout()</span>
<span class="sd">        &gt;&gt;&gt; fillist = L.ls()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;lay&#39;</span><span class="p">:</span>
            <span class="n">pathname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLAY&#39;</span><span class="p">],</span> <span class="s1">&#39;*.&#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;osm&#39;</span><span class="p">:</span>
            <span class="n">pathname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIROSM&#39;</span><span class="p">],</span> <span class="s1">&#39;*.&#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;wrl&#39;</span><span class="p">:</span>
            <span class="n">pathname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRWRL&#39;</span><span class="p">],</span> <span class="s1">&#39;*.&#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="p">)</span>

        <span class="n">lfile_l</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="n">pathname</span><span class="p">))</span>
        <span class="n">lfile_s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">lfile_l</span><span class="p">:</span>
            <span class="n">fis</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getshort</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
            <span class="n">lfile_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fis</span><span class="p">)</span>
        <span class="n">lfile_s</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lfile_s</span></div>

<div class="viewcode-block" id="Layout.offset_index"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.offset_index">[docs]</a>    <span class="k">def</span> <span class="nf">offset_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">offs</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; offset points and segment index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        offp : offset points</span>
<span class="sd">        offs : offset segments</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newpoint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">offp</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newpoint</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="n">newseg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newseg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="n">newpoint</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newseg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">newpoint</span>

        <span class="n">newppoint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">offp</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">newpseg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">newppoint</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newpseg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">newppoint</span>

        <span class="c1"># adjascence list of segments</span>
        <span class="n">ladjs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># adjascence list of points</span>
        <span class="n">ladjp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">nladjs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">offp</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">ladjs</span><span class="p">)</span>
        <span class="n">nladjp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">ladjp</span><span class="p">)</span>

        <span class="n">lpt</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">offp</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lseg</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">offs</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">dpt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lpt</span><span class="p">,</span> <span class="n">nladjp</span><span class="p">))</span>
        <span class="n">dseg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">nladjs</span><span class="p">))</span>
        <span class="n">dseg</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dpt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">dseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span> <span class="o">=</span> <span class="n">dseg</span></div>

<div class="viewcode-block" id="Layout.check"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.check">[docs]</a>    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check Layout consistency</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        level : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        consistent : Boolean</span>
<span class="sd">              True if consistent</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        GeomUtil.isBetween</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For all segments</span>
<span class="sd">            get the 2 vertices</span>
<span class="sd">                for all the other vertices</span>
<span class="sd">                    check if it belongs to segment</span>

<span class="sd">        If there are points which are not valid they are displayed</span>

<span class="sd">        In red point with degree == 1 , In black points with degree == 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bconsistent</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># points</span>
            <span class="c1"># segments</span>
            <span class="c1"># degree of segments</span>
            <span class="n">useg</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
            <span class="n">upnt</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
            <span class="n">degseg</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">useg</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># 1)   all segments have degree 2</span>
            <span class="c1">#</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">degseg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>

            <span class="c1">#</span>
            <span class="c1"># degree of points</span>
            <span class="c1"># maximum degree of points</span>
            <span class="c1">#</span>

            <span class="n">degpnt</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                         <span class="n">upnt</span><span class="p">)</span>  <span class="c1"># points absolute degrees</span>
            <span class="n">degmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">degpnt</span><span class="p">)</span>
            <span class="n">degmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degpnt</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1">#  No isolated points (degree 0)</span>
            <span class="c1">#  No points of degree 1</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">degmin</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">aw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">deg0</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">upnt</span><span class="p">)</span>
                <span class="n">deg1</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">upnt</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deg0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span> <span class="s2">&quot;It exists degree 0 points :  </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">deg0</span> <span class="p">)</span>
                    <span class="n">f</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pltvnodes</span><span class="p">(</span><span class="n">deg0</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
                    <span class="n">bconsistent</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deg1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span> <span class="s2">&quot;It exists degree 0 points :  </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">deg1</span> <span class="p">)</span>
                    <span class="n">f</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pltvnodes</span><span class="p">(</span><span class="n">deg1</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
                    <span class="n">bconsistent</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># self.deg = {}</span>
            <span class="c1"># for deg in range(degmax + 1):</span>
            <span class="c1">#     num = filter(lambda x: degpnt[x] == deg, range(</span>
            <span class="c1">#         len(degpnt)))  # position of degree 1 point</span>
            <span class="c1">#     npt = map(lambda x: upnt[x], num)  # number of degree 1 points</span>
            <span class="c1">#     self.deg[deg] = npt</span>

            <span class="c1">#</span>
            <span class="c1"># check if there are duplicate points or segments</span>
            <span class="c1">#</span>
            <span class="c1"># TODO argsort x coordinate</span>
            <span class="c1">#</span>

            <span class="c1"># get all the nodes</span>
            <span class="n">ke</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sd1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sd1</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sd1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">lu</span><span class="p">:</span>
                    <span class="c1"># if ke[u]&gt;0:</span>
                    <span class="c1">#     self.del_segment(ke[u])</span>
                    <span class="k">if</span> <span class="n">ke</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">del_points</span><span class="p">(</span><span class="n">ke</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>

                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
                <span class="c1"># useg  = filter(lambda x : x&gt;0,nodes)</span>
                <span class="n">upnt</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

            <span class="c1"># iterate on useg : list of segments</span>
            <span class="c1"># s : n1 &lt;--&gt; n2</span>
            <span class="c1">#</span>
            <span class="c1"># Is there a point different from (n1-n2) in betweeen of an existing segment s ?</span>
            <span class="c1">#</span>
            <span class="c1"># Not very much scalable. Double for loop</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;indoor&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">useg</span><span class="p">:</span>
                    <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>  <span class="c1"># node s neighbors</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span>           <span class="c1"># p1 --- p2</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span>  <span class="c1"># s</span>
                    <span class="c1">#</span>
                    <span class="c1"># iterate on upnt : list of points</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">upnt</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n2</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">geu</span><span class="o">.</span><span class="n">isBetween</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
                                <span class="k">print</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
                                <span class="k">print</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
                                <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

                                <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                                    <span class="s2">&quot;segment </span><span class="si">%d</span><span class="s2"> contains point </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                                <span class="n">consistent</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;segment </span><span class="si">%d</span><span class="s2"> has no cycle&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                                <span class="s2">&quot;segment </span><span class="si">%d</span><span class="s2"> has cycle </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cycle</span><span class="p">))</span>
        <span class="c1">#</span>
        <span class="c1"># check if Gs points are unique</span>
        <span class="c1"># segments can be duplicated</span>
        <span class="c1">#</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">upnt</span><span class="p">])</span>
        <span class="n">similar</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">check_point_unicity</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">similar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;points at index(es) </span><span class="si">%s</span><span class="s2"> in self.Gs.pos are similar&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">similar</span><span class="p">))</span>
            <span class="n">bconsistent</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span><span class="p">(</span><span class="n">bconsistent</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.clip"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the list of edges which cross or belong to the clipping zone</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        xmin : float</span>
<span class="sd">        xmax : float</span>
<span class="sd">        ymin : float</span>
<span class="sd">        ymax : float</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">          1) Determine all segments outside the clipping zone</span>
<span class="sd">          2) Union of the 4 conditions</span>
<span class="sd">          3) setdiff1d between the whole array of segments and the segments outside</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span>

        <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">nxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">maxx</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nxm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">minx</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">maxy</span> <span class="o">&lt;</span> <span class="n">ymin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">miny</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">nxp</span><span class="p">,</span> <span class="n">nxm</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">nyp</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">nym</span><span class="p">)</span>

        <span class="n">iseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">iseg</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Layout.check_Gi"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.check_Gi">[docs]</a>    <span class="k">def</span> <span class="nf">check_Gi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">nit1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nit1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">cy1</span> <span class="o">=</span> <span class="n">nit1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">nint2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">[</span><span class="n">nit1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nint2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">:</span>
                        <span class="k">assert</span> <span class="n">nint2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cy1</span></div>


        <span class="c1"># for e0,e1 in self.Gi.edges():</span>


<div class="viewcode-block" id="Layout.g2npy"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.g2npy">[docs]</a>    <span class="k">def</span> <span class="nf">g2npy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; conversion from graphs to numpy arrays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        verbose : boolean </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function updates the following arrays:</span>

<span class="sd">        + self.pt   (2xNp)</span>
<span class="sd">        + self.pg   center of gravity </span>
<span class="sd">        + self.tahe (2xNs)</span>
<span class="sd">        + self.tgs  : graph to segment </span>
<span class="sd">        + self.tsg  : segment to graph</span>
<span class="sd">        + self.dca  : dictionnary of cycle with an airwall</span>
<span class="sd">        + self.s2pu : sparse_lil_matrx </span>
<span class="sd">        + self.s2pc : sparse_lil_matrx </span>
<span class="sd">        + self.lsss : list of iso segments</span>
<span class="sd">        + self.maxheight : </span>
<span class="sd">        + self.normal :</span>

<span class="sd">        assert self.pt[self.iupnt[-1]] == self.pt[:,self.iupnt[-1]]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        extrseg</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="c1"># nodes include points and segments</span>

        <span class="c1"># segment index</span>
        <span class="c1"># useg = filter(lambda x: x &gt; 0, nodes)</span>
        <span class="n">useg</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># points index</span>
        <span class="c1"># upnt = filter(lambda x: x &lt; 0, nodes)</span>
        <span class="n">upnt</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>


        <span class="c1"># matrix segment-segment </span>
        <span class="c1"># usage </span>
        <span class="c1"># self.sgsg[seg1,seg2] =&gt; return common point</span>

        <span class="n">mno</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sgsg</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">mno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">mno</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">useg</span><span class="p">:</span>

            <span class="n">lpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">lpts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">lpts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

            <span class="n">nsa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="n">nsb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">nsa</span><span class="p">,</span><span class="n">nsb</span><span class="p">))</span>

            <span class="n">npta</span> <span class="o">=</span> <span class="p">[</span><span class="n">lpts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">nsa</span><span class="p">)</span>
            <span class="n">nptb</span> <span class="o">=</span> <span class="p">[</span><span class="n">lpts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">nsb</span><span class="p">)</span>
            <span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">npta</span><span class="p">,</span><span class="n">nptb</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sgsg</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">ns</span>




        <span class="c1"># conversion in numpy array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">upnt</span><span class="p">))</span>

        <span class="c1"># association</span>
        <span class="c1"># pdb.set_trace()</span>

        <span class="c1"># utmp = np.array(zip(-self.upnt,np.arange(len(self.upnt))))</span>
        <span class="c1"># mutmp = max(utmp[:,0])</span>
        <span class="c1"># self.iupnt = -np.ones((mutmp+1),dtype=&#39;int&#39;)</span>
        <span class="c1"># self.iupnt[utmp[:,0]]=utmp[:,1]</span>

        <span class="c1"># degree of segment nodes</span>
        <span class="n">degseg</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">useg</span><span class="p">)</span>
        
        <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">degseg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># all segments must have degree 2</span>

        <span class="c1">#</span>
        <span class="c1"># self.degree : dictionnary (point degree : list of point index)</span>
        <span class="c1">#</span>

        <span class="c1"># points absolute degrees</span>
        <span class="n">degpnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">upnt</span><span class="p">))</span>

        <span class="c1"># lairwall : list of air wall segments</span>

        <span class="n">lairwall</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="s1">&#39;AIR&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">lairwall</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="s1">&#39;_AIR&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">lairwall</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># as self.name[&#39;AIR&#39;] and self.name[&#39;_AIR&#39;] are tested</span>
        <span class="c1"># we define them as void list if not defined</span>

        <span class="c1">#</span>
        <span class="c1">#  function to count airwall connected to a point</span>
        <span class="c1">#  probably this is not the faster solution</span>
        <span class="c1">#</span>

        <span class="k">def</span> <span class="nf">nairwall</span><span class="p">(</span><span class="n">nupt</span><span class="p">):</span>
            <span class="n">lseg</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">nupt</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">lseg</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">lairwall</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">n</span>

        <span class="n">nairwall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">nairwall</span><span class="p">,</span> <span class="n">upnt</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;buildging nairwall : Done&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># if a node is connected to N air wall ==&gt; deg = deg - N</span>
        <span class="c1">#</span>

        <span class="n">degpnt</span> <span class="o">=</span> <span class="n">degpnt</span> <span class="o">-</span> <span class="n">nairwall</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">degmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">degpnt</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">degmax</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Start node degree determination&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">deg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">degpnt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">deg</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">degpnt</span><span class="p">)))</span>  <span class="c1"># position of degree 1 point</span>
            <span class="c1"># number of degree 1 points</span>
            <span class="n">npt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">upnt</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">num</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="n">deg</span><span class="p">]</span> <span class="o">=</span> <span class="n">npt</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Node degree determination  : Done&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># convert geometric information in numpy array</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">upnt</span><span class="p">)]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">useg</span><span class="p">)]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">upnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">useg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">upnt</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">upnt</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;pt in np.array  : Done&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ptc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pg</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span>
        <span class="n">dptc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptc</span><span class="o">*</span><span class="n">ptc</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>  <span class="o">=</span> <span class="n">dptc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pg</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>

        <span class="c1"># ntail = map(lambda x: nx.neighbors(self.Gs, x)[0], useg)</span>
        <span class="c1"># nhead = map(lambda x: nx.neighbors(self.Gs, x)[1], useg)</span>
        <span class="n">ntahe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">useg</span><span class="p">])</span>

        <span class="n">ntail</span> <span class="o">=</span> <span class="n">ntahe</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nhead</span> <span class="o">=</span> <span class="n">ntahe</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create sparse matrix from a Gs segment node to its 2 extremal points (tahe) index</span>
        <span class="n">mlgsn</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">mlgsn</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span><span class="p">[</span><span class="n">useg</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">ntahe</span>
        <span class="c1"># convert to compressed row sparse matrix </span>
        <span class="c1"># to be more efficient on row slicing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        

        <span class="c1"># tic = time.time()</span>
        <span class="c1"># self.tahe[0, :] = np.array(</span>
        <span class="c1">#      map(lambda x: np.nonzero(np.array(upnt) == x)[0][0], ntail))</span>
        <span class="c1"># self.tahe[1, :] = np.array(</span>
        <span class="c1">#    map(lambda x: np.nonzero(np.array(upnt) == x)[0][0], nhead))</span>
        
        <span class="n">aupnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upnt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aupnt</span><span class="o">==</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ntail</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aupnt</span><span class="o">==</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nhead</span> <span class="p">])</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;tahe in numpy array : Done&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># transcoding array between graph numbering (discontinuous) and numpy numbering (continuous)</span>
        <span class="c1">#</span>
        <span class="n">Nsmax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">useg</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">Nsmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No segments in Layout yet&quot;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># handling of segment related arrays</span>
        <span class="c1">#</span>
       
        <span class="k">if</span> <span class="n">Nsmax</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tgs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nsmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">rag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">useg</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">]</span> <span class="o">=</span> <span class="n">rag</span>

            <span class="c1">#</span>
            <span class="c1"># calculate normal to segment ta-he</span>
            <span class="c1">#</span>
            <span class="c1"># This could becomes obsolete once the normal will be calculated at</span>
            <span class="c1"># creation of the segment</span>
            <span class="c1">#</span>

            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]))</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]))</span>

            <span class="n">normx</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">normy</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">normx</span> <span class="o">*</span> <span class="n">normx</span> <span class="o">+</span> <span class="n">normy</span> <span class="o">*</span> <span class="n">normy</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">scale</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">normx</span><span class="p">,</span> <span class="n">normy</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">))))</span> <span class="o">/</span> <span class="n">scale</span>

            <span class="c1"># for ks in ds:</span>
            <span class="c1">#</span>
            <span class="c1"># lsss : list of subsegment</span>
            <span class="c1">#</span>

            <span class="c1"># nsmax = max(self.Gs.node.keys())</span>

            <span class="c1"># Warning</span>
            <span class="c1"># -------</span>
            <span class="c1"># nsmax can be different from the total number of segments</span>
            <span class="c1"># This means that the numerotation of segments do not need to be</span>
            <span class="c1"># contiguous.</span>
            <span class="c1"># stridess : length is equal to nsmax+1</span>
            <span class="c1"># sla is an array of string, index 0 is not used because there is</span>
            <span class="c1"># no such segment number.</span>
            <span class="c1">#</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lsss</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">useg</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># self.isss = []</span>

            <span class="c1"># self.stridess = np.array(np.zeros(nsmax+1),dtype=int)</span>
            <span class="c1"># self.stridess = np.empty(nsmax+1,dtype=int)</span>
            <span class="c1"># +1 is for discarding index 0 (unused here)</span>
            <span class="c1"># self.offset = np.empty(nsmax+1+self.Nss,dtype=int)</span>

            <span class="c1"># Storing segment normals</span>
            <span class="c1"># Handling of subsegments</span>
            <span class="c1">#</span>
            <span class="c1"># index is for indexing subsegment after the nsmax value</span>
            <span class="c1">#</span>
            <span class="c1"># index = nsmax+1</span>
            <span class="c1"># for ks in useg:</span>
            <span class="c1">#     k = self.tgs[ks]                        # index numpy</span>
            <span class="c1">#     self.offset[k] = self.Gs.node[ks][&#39;offset&#39;]</span>
            <span class="c1">#     self.Gs.node[ks][&#39;norm&#39;] = self.normal[:,k]  # update normal</span>
            <span class="c1">#     nameslab  = self.Gs.node[ks][&#39;name&#39;]   # update sla array</span>
            <span class="c1">#     assert nameslab!=&#39;&#39;, &quot;segment &quot;+str(ks)+ &quot; is not defined&quot;</span>
            <span class="c1">#     self.sla[ks] = nameslab</span>
            <span class="c1">#     # stridess is different from 0 only for subsegments</span>
            <span class="c1">#     self.stridess[ks] = 0                   # initialize stridess[ks]</span>
            <span class="c1">#     #if index==155:</span>
            <span class="c1">#     #    pdb.set_trace()</span>
            <span class="c1">#     if self.Gs.node[ks].has_key(&#39;ss_name&#39;): # if segment has sub segment</span>
            <span class="c1">#         nss = len(self.Gs.node[ks][&#39;ss_name&#39;])  # retrieve number of sseg</span>
            <span class="c1">#         self.stridess[ks]=index-1           # update stridess[ks] dict</span>
            <span class="c1">#         for uk,slabname in enumerate(self.Gs.node[ks][&#39;ss_name&#39;]):</span>
            <span class="c1">#             self.lsss.append(ks)</span>
            <span class="c1">#             self.sla[index] = slabname</span>
            <span class="c1">#             self.isss.append(index)</span>
            <span class="c1">#             self.offset[index] = self.Gs.node[ks][&#39;ss_offset&#39;][uk]</span>
            <span class="c1">#             index = index+1</span>

        <span class="c1"># append sub segment normal to normal</span>

        <span class="c1"># create sparse matrix from a Gs segment node to its 2 extremal points (tahe) coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">mlgsn</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

        <span class="n">ptail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]]</span>
        <span class="n">phead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ptail</span><span class="p">,</span><span class="n">phead</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">,:]</span><span class="o">=</span><span class="n">A</span>


        <span class="c1"># convert to compressed row sparse matrix </span>
        <span class="c1"># to be more efficient on row slicing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="c1"># for k in self.tsg:</span>
        <span class="c1">#     assert(np.array(self.s2pc[k,:].todense())==self.seg2pts(k).T).all(),pdb.set_trace()</span>
        <span class="c1">#pdb.set_trace()</span>
        <span class="c1">#</span>
        <span class="c1"># This is wrong and asume a continuous indexation of points </span>
        <span class="c1"># TODO FIX : This problem cleanly </span>
        <span class="c1"># </span>
        <span class="c1"># self.p2pc is only used in Gspos in outputGi_func only caled in case of </span>
        <span class="c1"># multiprocessing </span>
        <span class="c1">#</span>
        <span class="c1"># The temporary fix is to comment the 5 next lines</span>
        <span class="c1">#</span>
        <span class="c1"># mino = -min(self.Gs.nodes())+1</span>
        <span class="c1"># self.p2pc = sparse.lil_matrix((mino,2))</span>
        <span class="c1"># self.p2pc[-self.upnt,:]=self.pt.T</span>
        <span class="c1"># self.p2pc = self.p2pc.tocsr()</span>
        <span class="c1"># normal_ss = self.normal[:,self.tgs[self.lsss]]</span>
        <span class="c1"># self.normal = np.hstack((self.normal,normal_ss))</span>
        <span class="c1"># if problem here check file format &#39;z&#39; should be a string</span>
        <span class="n">lheight</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> 
                    <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> 
                    <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2000</span> <span class="p">])</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lheight</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span><span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;no valid heights for segments&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxheight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lheight</span><span class="p">)</span>
        <span class="c1"># self.maxheight=3.</span>
        <span class="c1"># calculate extremum of segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrseg</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.importshp"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.importshp">[docs]</a>    <span class="k">def</span> <span class="nf">importshp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; import layout from shape file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        _fileshp :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pref&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">25481100</span><span class="p">,</span> <span class="mi">6676890</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">60.2043716</span><span class="p">,</span> <span class="mf">24.6591147</span><span class="p">])],</span>
                    <span class="s1">&#39;dist_m&#39;</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span>
                    <span class="s1">&#39;latlon&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;bd&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">61</span><span class="p">],</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="n">fileshp</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_fileshp&#39;</span><span class="p">],</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;struc&#39;</span><span class="p">,</span> <span class="s1">&#39;shp&#39;</span><span class="p">))</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="n">shp</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">fileshp</span><span class="p">)</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="o">.</span><span class="n">iterShapes</span><span class="p">():</span>
            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="mf">1e16</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="mf">1e16</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e16</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;WALL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pref&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">nv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># if at least one point is in the radius the poygon is kept</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nv</span> <span class="o">&lt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dist_m&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># pdb.set_trace()</span>
                <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># add a new node unless it is the last already existing</span>
                    <span class="c1"># point</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="p">(</span><span class="n">npoint</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">np0</span> <span class="o">=</span> <span class="n">npt</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">npt</span><span class="p">)</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span>
                        <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
                        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
                        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">npt</span> <span class="o">=</span> <span class="n">npt</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="c1"># add a new segment from the second point</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">npoint</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">ns</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;WALL&#39;</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span>
                                         <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="p">[</span><span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">npt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ns</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                    <span class="c1"># add a new segment closing the polygon</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">npoint</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">ns</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;WALL&#39;</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span>
                                         <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">transition</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="p">[</span><span class="n">np0</span><span class="p">,</span> <span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">np0</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ns</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np0</span><span class="p">]))</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># TODO change lon_0 and lat_0 hard coded</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">Basemap</span><span class="p">(</span><span class="n">llcrnrlon</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">llcrnrlat</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">urcrnrlon</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">urcrnrlat</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                         <span class="n">resolution</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;cass&#39;</span><span class="p">,</span> <span class="n">lon_0</span><span class="o">=</span><span class="mf">24.5</span><span class="p">,</span> <span class="n">lat_0</span><span class="o">=</span><span class="mf">60.5</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;latlon&#39;</span><span class="p">]:</span>
            <span class="n">lat_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pref&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lon_ref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pref&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x_ref</span><span class="p">,</span> <span class="n">y_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">lon_ref</span><span class="p">,</span> <span class="n">lat_ref</span><span class="p">)</span>
            <span class="n">Dx</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pref&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_ref</span>
            <span class="n">Dy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pref&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_ref</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">keys</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Dy</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s1">&#39;latlon&#39;</span></div>

<div class="viewcode-block" id="Layout.importres"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.importres">[docs]</a>    <span class="k">def</span> <span class="nf">importres</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">_fileres</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; import res format </span>
<span class="sd">        </span>
<span class="sd">        col1 : x1 coordinates</span>
<span class="sd">        col2 : y1 coordinates </span>
<span class="sd">        col3 : x2 coordinates</span>
<span class="sd">        col4 : y2 coordinates</span>
<span class="sd">        col5 : building height</span>
<span class="sd">        col6 : building number</span>
<span class="sd">        col7 : building class </span>
<span class="sd">        col8 : ground height  </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fileres</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_fileres</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;struc&#39;</span><span class="p">,</span> <span class="s1">&#39;res&#39;</span><span class="p">))</span>
        <span class="n">D</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fileres</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;outdoor&#39;</span>
        <span class="c1"># number of integer</span>
        <span class="n">N1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="c1"># number of lines</span>
        <span class="n">N2</span> <span class="o">=</span> <span class="n">N1</span><span class="o">/</span><span class="mi">8</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
        <span class="c1"># list of coordinates</span>
        <span class="n">lcoords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># list of ring</span>
        <span class="n">lring</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="c1"># list of (z_ground, height_building)</span>
        <span class="n">zring</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="c1"># </span>
        <span class="n">bdg_old</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N2</span><span class="p">):</span>
            <span class="c1"># p1 point coordinate</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="p">([</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
            <span class="c1"># p2 point coordinate</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">([</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
            <span class="c1"># (ground height,building height) </span>
            <span class="c1">#z  = (D[e,7]-500,D[e,4])</span>
            <span class="c1"># (ground height,building height+ground_height) </span>
            <span class="n">z</span>  <span class="o">=</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
            <span class="c1"># building number</span>
            <span class="n">bdg</span> <span class="o">=</span>  <span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> 
            <span class="c1"># building class </span>
            <span class="n">bdc</span> <span class="o">=</span>  <span class="n">D</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> 
            <span class="c1"># detect change of building </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bdg_old</span><span class="o">-</span><span class="n">bdg</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ring</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LinearRing</span><span class="p">(</span><span class="n">lcoords</span><span class="p">)</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">area</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">lring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
                    <span class="n">zring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">lcoords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bdg_old</span><span class="o">=</span><span class="n">bdg</span>
            <span class="c1"># update lcoords</span>
            <span class="k">if</span> <span class="n">p1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lcoords</span><span class="p">:</span>
                <span class="n">lcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lcoords</span><span class="p">:</span>
                <span class="n">lcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

        <span class="n">npt</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">r1</span><span class="p">,</span><span class="n">z1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lring</span><span class="p">,</span><span class="n">zring</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">xy</span> 
            
            <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">new_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k2</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">k2</span><span class="p">])</span>
                <span class="n">kpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">vpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">new_pt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vpos</span><span class="p">:</span>
                    <span class="c1">#</span>
                    <span class="c1"># add node point nde &lt;0 and position</span>
                    <span class="c1">#</span>
                    <span class="n">current_node_index</span> <span class="o">=</span> <span class="o">-</span><span class="n">npt</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">current_node_index</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="n">npt</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pt</span>
                    <span class="n">npt</span> <span class="o">=</span> <span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vpos</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="n">vpos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_pt</span><span class="p">)]</span>
                    
                    <span class="n">current_node_index</span> <span class="o">=</span> <span class="n">kpos</span><span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">k2</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># at least already one point</span>
                    <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">current_node_index</span><span class="p">,</span> <span class="n">previous_node_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;WALL&#39;</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">starting_node_index</span>  <span class="o">=</span>   <span class="n">current_node_index</span>
                <span class="n">previous_node_index</span> <span class="o">=</span> <span class="n">current_node_index</span></div>
            <span class="c1"># last segment    </span>
            <span class="c1">#ns = self.add_segment(previous_node_index, starting_node_index, name=&#39;WALL&#39;, z=z1)</span>
        <span class="c1">#pdb.set_trace()</span>

<div class="viewcode-block" id="Layout.importosm"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.importosm">[docs]</a>    <span class="k">def</span> <span class="nf">importosm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; import layout from osm file or osmapi</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        _fileosm : string</span>
<span class="sd">        address : string</span>
<span class="sd">            address to be geocoded</span>
<span class="sd">        latlon : tuple</span>
<span class="sd">            (latitude,longitude) degrees</span>
<span class="sd">        dist_m : float</span>
<span class="sd">            distance in meter from the geocoded address (def 200 m )</span>
<span class="sd">        cart : boolean</span>
<span class="sd">            conversion in cartesian coordinates</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The best and recommended manner to edit a layout is to use the</span>
<span class="sd">        josm editor in association with the piclayer plugin. </span>
<span class="sd">        This plugin allows to place a geo-adjusted image in the background </span>
<span class="sd">        which is very convenient for editing floorplan of buildings.. </span>

<span class="sd">        In josm editor, nodes are numbered with negative indexes, while in </span>
<span class="sd">        pylayers they have a positive index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.osmparser.osmparse</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_fileosm&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;address&#39;</span><span class="p">:</span> <span class="s1">&#39;Rennes&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;typ&#39;</span><span class="p">:</span> <span class="s1">&#39;indoor&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;latlon&#39;</span><span class="p">:</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dist_m&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
                    <span class="s1">&#39;cart&#39;</span><span class="p">:</span> <span class="bp">False</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;typ&#39;</span><span class="p">]</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;address&#39;</span><span class="p">]</span>
        <span class="n">latlon</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;latlon&#39;</span><span class="p">])</span>
        <span class="n">dist_m</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dist_m&#39;</span><span class="p">]</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cart&#39;</span><span class="p">]</span>
        
        <span class="c1">#</span>
        <span class="c1">#  zceil ansd zfloor are obtained from actual data</span>
        <span class="c1">#</span>
        <span class="c1">#  indoor default (0,3)</span>
        <span class="c1">#  outdoor default (0,3000)</span>

        <span class="c1">#if self.typ==&#39;indoor&#39;:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="mf">1e10</span>
        
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_fileosm&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>  <span class="c1"># by using osmapi address or latlon</span>
            <span class="n">coords</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">ways</span><span class="p">,</span> <span class="n">dpoly</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">getosm</span><span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">,</span>
                                                       <span class="n">latlon</span> <span class="o">=</span> <span class="n">latlon</span><span class="p">,</span>
                                                       <span class="n">dist_m</span> <span class="o">=</span> <span class="n">dist_m</span><span class="p">,</span>
                                                       <span class="n">cart</span> <span class="o">=</span> <span class="n">cart</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;outdoor&#39;</span>
            <span class="k">if</span> <span class="n">cart</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">=</span><span class="s1">&#39;cart&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">=</span><span class="s1">&#39;latlon&#39;</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;latlon&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;address&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.lay&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;latlon&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="s1">&#39;lat_&#39;</span> <span class="o">+</span> \
                    <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_lon_&#39;</span> <span class="o">+</span> \
                    <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.ini&#39;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># by reading an osm file</span>
            <span class="n">fileosm</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_fileosm&#39;</span><span class="p">],</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;struc&#39;</span><span class="p">,</span> <span class="s1">&#39;osm&#39;</span><span class="p">))</span>
            <span class="c1">#coords, nodes, ways, relations, m = osm.osmparse(fileosm, typ=self.typ)</span>
            <span class="c1"># typ outdoor parse ways.buildings </span>
            <span class="c1"># typ indoor parse ways.ways </span>
            <span class="n">coords</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">ways</span><span class="p">,</span> <span class="n">relations</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">osmparse</span><span class="p">(</span><span class="n">fileosm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s1">&#39;latlon&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_fileosm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;osm&#39;</span><span class="p">,</span> <span class="s1">&#39;lay&#39;</span><span class="p">)</span>
        
        <span class="c1"># 2 valid typ : &#39;indoor&#39; and &#39;building&#39;</span>

        <span class="n">_np</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># _ to avoid name conflict with numpy alias</span>
        <span class="n">_ns</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nss</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Reading points  (&lt;0 index)</span>

        <span class="c1"># Reorganize points coordinates for detecting</span>
        <span class="c1"># duplicate nodes</span>
        <span class="c1"># duplicate nodes are saved in dict dup</span>

        <span class="n">kp</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">kp</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">kp</span><span class="p">))</span>
        <span class="n">ux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
        <span class="n">y_prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
        <span class="n">dup</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionnary of duplicate nodes</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ux</span><span class="p">:</span>
            <span class="c1"># if node is not already a duplicate</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">x_prev</span><span class="p">:</span>
                <span class="c1"># 2 consecutive points with same lon =&gt; check lat</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">y_prev</span><span class="p">:</span>
                    <span class="c1"># node u is a duplicate</span>
                    <span class="c1"># udate dup dictionnary</span>
                    <span class="c1"># printu_prev ,k_prev, x_prev,y_prev</span>
                    <span class="c1"># print&quot; &quot;,u ,kp[u], x[u],y[u]</span>
                    <span class="n">dup</span><span class="p">[</span><span class="n">kp</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k_prev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="n">y_prev</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                <span class="n">u_prev</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">k_prev</span> <span class="o">=</span> <span class="n">kp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">npt</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">:</span>
            <span class="c1"># if node is not duplicated add node</span>
            <span class="k">if</span> <span class="n">npt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dup</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">npt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="n">npt</span><span class="p">])</span>
                <span class="n">_np</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Reading segments</span>
        <span class="c1">#</span>
        <span class="c1"># ways of osm</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">nseg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ways</span><span class="o">.</span><span class="n">way</span><span class="p">):</span>
            <span class="n">tahe</span> <span class="o">=</span> <span class="n">ways</span><span class="o">.</span><span class="n">way</span><span class="p">[</span><span class="n">nseg</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tahe</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">nta</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                <span class="n">nhe</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1">#</span>
                <span class="c1"># if a node is duplicate recover the original node</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="n">nta</span> <span class="ow">in</span> <span class="n">dup</span><span class="p">:</span>
                    <span class="n">nta</span> <span class="o">=</span> <span class="n">dup</span><span class="p">[</span><span class="n">nta</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nhe</span> <span class="ow">in</span> <span class="n">dup</span><span class="p">:</span>
                    <span class="n">nhe</span> <span class="o">=</span> <span class="n">dup</span><span class="p">[</span><span class="n">nhe</span><span class="p">]</span>

                <span class="n">d</span> <span class="o">=</span> <span class="n">ways</span><span class="o">.</span><span class="n">way</span><span class="p">[</span><span class="n">nseg</span><span class="p">]</span><span class="o">.</span><span class="n">tags</span>

                <span class="c1">#</span>
                <span class="c1"># Convert string to integer if possible</span>
                <span class="c1">#</span>

                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>


                <span class="c1"># getting segment information</span>
                <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                        <span class="n">slab</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># the default slab name is WALL</span>
                        <span class="n">slab</span> <span class="o">=</span> <span class="s2">&quot;WALL&quot;</span>


                <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;indoor&#39;</span><span class="p">:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;outdoor&#39;</span><span class="p">:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3000</span><span class="p">)</span>

                <span class="n">zmin</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">zmax</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">zmin</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="n">zmin</span> 
                <span class="k">if</span> <span class="n">zmax</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">zceil</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span> <span class="o">=</span> <span class="n">zmax</span>

                <span class="k">if</span> <span class="s1">&#39;offset&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1">#</span>
                <span class="c1"># get the common neighbor of nta and nhe if it exists</span>
                <span class="c1">#</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">nta</span><span class="p">))</span>
                <span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">nhe</span><span class="p">))</span>
                <span class="n">inter_u1_u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">)</span>
                <span class="c1">#</span>
                <span class="c1"># Create  a new segment (iso segments are managed in add_segment)</span>
                <span class="c1">#</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">nta</span><span class="p">,</span> <span class="n">nhe</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">slab</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="n">_np</span>
        <span class="c1">#self.Ns = _ns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nss</span> <span class="o">=</span> <span class="n">nss</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">])</span>
        <span class="c1"># bd = [lon.min(), lat.min(), lon.max(), lat.max()]</span>
        <span class="c1"># lon_0 = (bd[0] + bd[2]) / 2.</span>
        <span class="c1"># lat_0 = (bd[1] + bd[3]) / 2.</span>

        <span class="c1"># self.m = Basemap(llcrnrlon=bd[0], llcrnrlat=bd[1],</span>
        <span class="c1">#                  urcrnrlon=bd[2], urcrnrlat=bd[3],</span>
        <span class="c1">#                  resolution=&#39;i&#39;, projection=&#39;cass&#39;, lon_0=lon_0, lat_0=lat_0)</span>
        

        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cart&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">!=</span><span class="s1">&#39;cart&#39;</span><span class="p">)):</span>
             <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">)}</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="s1">&#39;cart&#39;</span>

        <span class="c1"># del coords</span>
        <span class="c1"># del nodes</span>
        <span class="c1"># del ways</span>
        <span class="c1"># del relations</span>

        <span class="c1">#</span>
        <span class="c1"># get slab and materials DataBase</span>
        <span class="c1">#</span>
        <span class="c1"># 1) create material database</span>
        <span class="c1"># 2) load materials database</span>
        <span class="c1"># 3) create slabs database</span>
        <span class="c1"># 4) add materials database to slab database</span>
        <span class="c1"># 5) load slabs database</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">MatDB</span><span class="p">()</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filematini</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">SlabDB</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileslabini</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># update self.name with existing slabs database entries</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># convert graph Gs to numpy arrays for speed up post processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># add boundary</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span>

        <span class="c1"># save ini file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span></div>

        <span class="c1">#</span>

<div class="viewcode-block" id="Layout.exportosm"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.exportosm">[docs]</a>    <span class="k">def</span> <span class="nf">exportosm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  export layout in osm file format</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        _filename : string</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        See Also </span>
<span class="sd">        --------</span>

<span class="sd">        layout.loadosm</span>
<span class="sd">        layout.loadini</span>
<span class="sd">        layout.check</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># export Layout in osm format</span>
        <span class="c1"># The osm filename basenam is the same as the _filename ini file</span>

        <span class="n">_filename</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span> <span class="o">+</span> <span class="s1">&#39;.osm&#39;</span><span class="p">,</span> <span class="s1">&#39;struc/osm&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span> 
            <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span> <span class="o">+</span> <span class="s1">&#39;_.osm&#39;</span><span class="p">,</span> <span class="s1">&#39;struc/osm&#39;</span><span class="p">)</span>
            
        <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;osm version=&#39;0.6&#39; upload=&#39;false&#39; generator=&#39;PyLayers&#39;&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># creating points</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lboundary</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">==</span> <span class="s1">&#39;latlon&#39;</span><span class="p">:</span>
                        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">==</span> <span class="s1">&#39;cart&#39;</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;node id=&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39; action=&#39;modify&#39; visible=&#39;true&#39; lat=&#39;&quot;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39; lon=&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39; /&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#</span>
                <span class="c1"># Conditions pour ajout segments</span>
                <span class="c1"># </span>
                <span class="c1"># _AIR are not added </span>
                <span class="c1"># </span>
                <span class="c1"># outdoor AIR wall above buildings are not added</span>
                <span class="c1"># cond1 is wrong</span>

                <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span>
                <span class="n">cond3</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span><span class="p">)</span>
                <span class="n">cond4</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span><span class="p">)</span>
                <span class="n">cond5</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond2</span> <span class="ow">and</span> <span class="n">cond3</span><span class="p">)</span>
                <span class="n">cond6</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond2</span> <span class="ow">and</span> <span class="n">cond4</span><span class="p">)</span>
                <span class="n">cond7</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond2</span> <span class="ow">and</span> <span class="n">cond3</span> <span class="ow">and</span> <span class="n">cond4</span><span class="p">)</span> 


                <span class="k">if</span> <span class="p">(</span><span class="n">cond1</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond5</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond6</span><span class="p">))</span> <span class="ow">or</span> <span class="n">cond7</span><span class="p">:</span> 
                    <span class="n">neigh</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="c1">#</span>
                    <span class="n">noden</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000000</span> <span class="o">-</span> <span class="n">n</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;way id=&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">noden</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot;&#39; action=&#39;modify&#39; visible=&#39;true&#39;&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;nd ref=&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neigh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;&#39; /&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;nd ref=&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neigh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;&#39; /&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;tag k=&#39;name&#39; v=&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;&#39; /&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;tag k=&#39;z&#39; v=</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> /&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;tag k=&#39;transition&#39; v=&#39;&quot;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;&#39; /&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;/way&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">fd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;/osm&gt;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.save"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; save Layout structure in a .lay file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_version</span> <span class="o">=</span> <span class="mf">1.3</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.ini&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.ini&#39;</span><span class="p">,</span><span class="s1">&#39;.lay&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># version 1.3 : suppression of index in slab and materials</span>
        <span class="c1">#</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">optionxform</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;segments&quot;</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;files&quot;</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;slabs&quot;</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;materials&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">==</span> <span class="s1">&#39;latlon&#39;</span><span class="p">:</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;latlon&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;cart&quot;</span><span class="p">)</span>

        <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">,</span> <span class="n">current_version</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;info&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;indoor&#39;</span><span class="p">:</span>
            <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;indoor&quot;</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;indoor&quot;</span><span class="p">,</span> <span class="s2">&quot;zceil&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;indoor&quot;</span><span class="p">,</span> <span class="s2">&quot;zfloor&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;outdoor&#39;</span><span class="p">:</span>
            <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;outdoor&quot;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># save bounding box in latlon for reconstruction of self.m</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">):</span>
            <span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s2">&quot;latlon&quot;</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;latlon&quot;</span><span class="p">,</span><span class="s2">&quot;llcrnrlon&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">llcrnrlon</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;latlon&quot;</span><span class="p">,</span><span class="s2">&quot;llcrnrlat&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">llcrnrlat</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;latlon&quot;</span><span class="p">,</span><span class="s2">&quot;urcrnrlon&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">urcrnrlon</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;latlon&quot;</span><span class="p">,</span><span class="s2">&quot;urcrnrlat&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">urcrnrlat</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;latlon&quot;</span><span class="p">,</span><span class="s2">&quot;projection&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">projection</span><span class="p">)</span>

        <span class="c1"># config.set(&quot;info&quot;,&#39;Nsegments&#39;,self.Ns)</span>
        <span class="c1"># config.set(&quot;info&quot;,&#39;Nsubsegments&#39;,self.Nss)</span>

        <span class="c1">#for k in self.display:</span>
        <span class="c1">#    config.set(&quot;display&quot;, k, self.display[k])</span>

        <span class="c1"># iterate on points</span>
        <span class="c1"># boundary nodes and air walls are not saved</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lboundary</span><span class="p">:</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># iterate on segments</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>
                <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span>
                <span class="n">cond3</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span><span class="p">)</span>
                <span class="n">cond4</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span><span class="p">)</span>
                <span class="n">cond5</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond2</span> <span class="ow">and</span> <span class="n">cond3</span><span class="p">)</span>
                <span class="n">cond6</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond2</span> <span class="ow">and</span> <span class="n">cond4</span><span class="p">)</span>
                <span class="n">cond7</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond2</span> <span class="ow">and</span> <span class="n">cond3</span> <span class="ow">and</span> <span class="n">cond4</span><span class="p">)</span> 
                <span class="c1">#</span>
                <span class="c1"># _AIR are not stored  (cond1) </span>
                <span class="c1"># AIR segment reaching zceil are not stored  (cond4) </span>
                <span class="c1"># AIR segment reaching zfloor are not stored (cond5) </span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cond1</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond5</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">cond6</span><span class="p">))</span> <span class="ow">or</span> <span class="n">cond7</span><span class="p">:</span> 
                    <span class="n">d</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;connect&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]:</span>
                            <span class="k">pass</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s1">&#39;DOOR&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss_name&#39;</span><span class="p">]:</span>
                                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="c1"># remove normal information from the strucure</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="c1"># remove iso information from the strucure</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;iso&#39;</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="c1"># remove ncycles information from the strucure</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ncycles&#39;</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    
                    <span class="c1"># transition are saved only if True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]:</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">)</span>
                    
                    <span class="c1"># offset are saved only if not zero </span>
                    <span class="k">if</span> <span class="s1">&#39;offset&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">)</span>


                    <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;segments&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># [ slabs ] </span>
        <span class="c1">#</span>
        <span class="c1"># get the list of used slabs</span>

        <span class="n">lslab</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">lmat</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#</span>
        <span class="c1"># In case an osm file has been read; there is no .sl</span>
        <span class="c1"># By default all the available slabs and materials are provided</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;sl&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">SlabDB</span><span class="p">(</span><span class="n">filemat</span><span class="o">=</span><span class="s1">&#39;matDB.ini&#39;</span><span class="p">,</span> <span class="n">fileslab</span><span class="o">=</span><span class="s1">&#39;slabDB.ini&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lslab</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">mat</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">cval</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="s1">&#39;epsr&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">,[</span><span class="n">s</span><span class="p">],[</span><span class="mf">0.1</span><span class="p">])</span>

            <span class="c1">#ds[&#39;index&#39;] = self.sl[s][&#39;index&#39;]</span>
            <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;lmatname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;lmatname&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;lmatname&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lmat</span><span class="p">:</span>
                    <span class="n">lmat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;lthick&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;lthick&#39;</span><span class="p">]</span>
            <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;slabs&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;_AIR&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lslab</span><span class="p">:</span>
            <span class="n">air</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                   <span class="s1">&#39;lthick&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> <span class="s1">&#39;lmatname&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]}</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;slabs&quot;</span><span class="p">,</span> <span class="s2">&quot;_AIR&quot;</span><span class="p">,</span> <span class="n">air</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;AIR&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lslab</span><span class="p">:</span>
            <span class="n">air</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                   <span class="s1">&#39;lthick&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> <span class="s1">&#39;lmatname&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]}</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;slabs&quot;</span><span class="p">,</span> <span class="s2">&quot;AIR&quot;</span><span class="p">,</span> <span class="n">air</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;CEIL&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lslab</span><span class="p">:</span>
            <span class="n">ceil</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;grey20&#39;</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;lthick&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> <span class="s1">&#39;lmatname&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;REINFORCED_CONCRETE&#39;</span><span class="p">]}</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;slabs&quot;</span><span class="p">,</span> <span class="s2">&quot;CEIL&quot;</span><span class="p">,</span> <span class="n">ceil</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;FLOOR&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lslab</span><span class="p">:</span>
            <span class="n">floor</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;grey40&#39;</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;lthick&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> <span class="s1">&#39;lmatname&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;REINFORCED_CONCRETE&#39;</span><span class="p">]}</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;slabs&quot;</span><span class="p">,</span> <span class="s2">&quot;FLOOR&quot;</span><span class="p">,</span> <span class="n">floor</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># [ materials ] </span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">lmat</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">mat</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="c1"># store UIT format only if it is used</span>
            <span class="k">if</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">dm</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dm</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">==</span><span class="bp">None</span><span class="p">:</span>
                    <span class="n">dm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
                    <span class="n">dm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
                    <span class="n">dm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
                    <span class="n">dm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;materials&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;REINFORCED_CONCRETE&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lmat</span><span class="p">:</span>
            <span class="n">reic</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mur&#39;</span><span class="p">:</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="mi">0j</span><span class="p">),</span> <span class="s1">&#39;epr&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">8.69999980927</span> <span class="o">+</span> <span class="mi">0j</span><span class="p">),</span> <span class="s1">&#39;roughness&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">}</span>
            <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;materials&quot;</span><span class="p">,</span> <span class="s2">&quot;REINFORCED_CONCRETE&quot;</span><span class="p">,</span> <span class="n">reic</span><span class="p">)</span>
        <span class="c1"># config.set(&quot;files&quot;,&#39;materials&#39;,self.filematini)</span>
        <span class="c1"># config.set(&quot;files&quot;,&#39;slab&#39;,self.fileslabini)</span>
        <span class="c1">#</span>
        <span class="c1"># [ furniture ] </span>
        <span class="c1">#</span>
        <span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;files&quot;</span><span class="p">,</span> <span class="s1">&#39;furniture&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filefur</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># handling olf format ( to be removed later) </span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.ini&#39;</span><span class="p">:</span>
            <span class="n">fileout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.ini&#39;</span><span class="p">,</span><span class="s1">&#39;.lay&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fileout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>

        <span class="n">filelay</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">fileout</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLAY&#39;</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">filelay</span><span class="p">)</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filelay</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">fd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># convert graph Gs to numpy arrays for speed up post processing</span>
        <span class="c1"># ideally an edited Layout should be locked while not saved.</span>
        <span class="c1"># self.g2npy()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filelay</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.load"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load a layout  from a .lay file</span>

<span class="sd">        The filename is in self._filename</span>

<span class="sd">        Format version 1.3</span>
<span class="sd">        ------------------</span>

<span class="sd">        [info]</span>
<span class="sd">        format = {cart | latlon} </span>
<span class="sd">        version = </span>
<span class="sd">        type = {indoor | outdoor}</span>

<span class="sd">        [points]</span>
<span class="sd">        -1 = (x,y)</span>

<span class="sd">        [segments]</span>
<span class="sd">        1 = {&#39;slab&#39;:&#39;&#39;,transition:boolean,&#39;connect:[-1,-2],&#39;z&#39;:(0,3)}</span>

<span class="sd">        [slabs]</span>
<span class="sd">        WALL = {&#39;lthick&#39;:[,],&#39;lmat&#39;:[,],&#39;color:&#39;&#39;,&#39;linewidth&#39;:float}</span>
<span class="sd">        </span>
<span class="sd">        [materials]</span>
<span class="sd">        BRICK = {&#39;mur&#39;:complex,&#39;epsr&#39;:complex,&#39;sigma&#39;:float,&#39;roughness&#39;:}</span>

<span class="sd">        [indoor]</span>
<span class="sd">        zceil =</span>
<span class="sd">        zfloor =</span>
<span class="sd">        </span>
<span class="sd">        [outdoor]</span>
<span class="sd">        zceil =</span>
<span class="sd">        zfloor =</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># di : dictionnary which reflects the content of ini file</span>
        <span class="n">di</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">optionxform</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="n">filelay</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLAY&#39;</span><span class="p">])</span>
        <span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filelay</span><span class="p">)</span>


        <span class="n">sections</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
            <span class="n">di</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">di</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">option</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;segments&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gs&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#</span>
        <span class="c1"># [info] </span>
        <span class="c1">#    format     {cart,latlon}   </span>
        <span class="c1">#    version    int </span>
        <span class="c1">#    type       {&#39;indoor&#39;,&#39;outdoor&#39;}</span>
        <span class="k">if</span> <span class="s1">&#39;version&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;version&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;type&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">!=</span><span class="s1">&#39;indoor&#39;</span><span class="p">)</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">!=</span><span class="s1">&#39;outdoor&#39;</span><span class="p">)</span> <span class="o">&amp;</span> 
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">!=</span><span class="s1">&#39;floorplan&#39;</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;invalid file type in &quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># [indoor]</span>
        <span class="c1">#   zceil </span>
        <span class="c1">#   zfloor</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;indoor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;indoor&#39;</span><span class="p">][</span><span class="s1">&#39;zceil&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;indoor&#39;</span><span class="p">][</span><span class="s1">&#39;zfloor&#39;</span><span class="p">])</span>

        <span class="c1"># old format </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;floorplan&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;floorplan&#39;</span><span class="p">][</span><span class="s1">&#39;zceil&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;floorplan&#39;</span><span class="p">][</span><span class="s1">&#39;zfloor&#39;</span><span class="p">])</span>
        
        <span class="c1"># from format 1.3 floorplan is call indoor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;floorplan&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;indoor&#39;</span>
        <span class="c1">#</span>
        <span class="c1"># [outdoor]</span>
        <span class="c1">#   TODO add a DEM file </span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;outdoor&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;outdoor&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">:</span> 
                <span class="k">if</span> <span class="s1">&#39;zceil&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;outdoor&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;outdoor&#39;</span><span class="p">][</span><span class="s1">&#39;zceil&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span>  <span class="o">=</span>  <span class="mi">3000</span>    <span class="c1"># upper limit for AIR walls</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zceil</span>  <span class="o">=</span>  <span class="mi">3000</span>    <span class="c1"># upper limit for AIR walls</span>

            <span class="k">if</span> <span class="s1">&#39;outdoor&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">:</span> 
                <span class="k">if</span> <span class="s1">&#39;zfloor&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;outdoor&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;outdoor&#39;</span><span class="p">][</span><span class="s1">&#39;zfloor&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="mi">0</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># manage ini file with latlon coordinates</span>
        <span class="c1">#</span>
        <span class="c1"># if the format is latlon, coordinates are converted into</span>
        <span class="c1"># cartesian coordinates with the coords.cartesian method</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;format&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;latlon&#39;</span><span class="p">:</span>
                <span class="n">or_coord_format</span> <span class="o">=</span> <span class="s1">&#39;latlon&#39;</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">osm</span><span class="o">.</span><span class="n">Coords</span><span class="p">()</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">latlon</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]}</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">latlon</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">latlon</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">cartesian</span><span class="p">(</span><span class="n">cart</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">or_coord_format</span> <span class="o">=</span> <span class="s1">&#39;cart&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">or_coord_format</span> <span class="o">=</span> <span class="s1">&#39;cart&#39;</span>

        <span class="c1">#</span>
        <span class="c1"># update display section</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;display&#39;</span> <span class="ow">in</span> <span class="n">di</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;display&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># self.ax = self.display[&#39;box&#39;]</span>
        <span class="c1">#</span>
        <span class="c1"># [points] </span>
        <span class="c1">#</span>
        <span class="c1"># update points section</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]:</span>
            <span class="n">nodeindex</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">or_coord_format</span> <span class="o">==</span> <span class="s1">&#39;latlon&#39;</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">][</span><span class="n">nn</span><span class="p">])</span>

            <span class="c1">#</span>
            <span class="c1"># limitation of point precision is important for avoiding</span>
            <span class="c1"># topological problems in shapely.</span>
            <span class="c1"># Layout precision is hard limited to millimeter precision.</span>
            <span class="c1">#</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">nodeindex</span><span class="p">)</span>  <span class="c1"># add point node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nodeindex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">round</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">nodeindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn</span>

        <span class="c1">#</span>
        <span class="c1"># [segments]</span>
        <span class="c1">#</span>
        <span class="c1"># update segments section</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#</span>
        <span class="c1"># get the maximum index</span>
        <span class="c1">#</span>
        <span class="n">maxnum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">eval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;segments&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;segments&#39;</span><span class="p">]:</span>

            <span class="n">d</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;segments&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
            <span class="n">nta</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;connect&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nhe</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;connect&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#print(key,nta,nhe)</span>

            
            <span class="n">name</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">):</span>
                <span class="n">transition</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transition</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span>
            
            <span class="c1"># add new segment</span>
            <span class="c1">#</span>
            <span class="c1"># The segment number is the same as in the .lay file</span>
            <span class="c1"># </span>
            <span class="c1"># Very useful feature </span>
            <span class="c1">#</span>
            <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">nta</span><span class="p">,</span> <span class="n">nhe</span><span class="p">,</span>
                                   <span class="n">num</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                                   <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">,</span>
                                   <span class="n">transition</span> <span class="o">=</span> <span class="n">transition</span><span class="p">,</span> 
                                   <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                   <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">)</span>

        <span class="c1"># exploit iso for segment completion (AIR type) </span>
        <span class="c1">#</span>
        <span class="c1">#  Complement single segment which do not reach zceil or zfloor with</span>
        <span class="c1">#  an iso segment with AIR property</span>
        <span class="c1"># </span>
        <span class="n">segdone</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;segments&#39;</span><span class="p">]:</span>
            <span class="n">iseg</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="s1">&#39;segments&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
            <span class="n">nta</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;connect&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nhe</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;connect&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># if not already done</span>
            <span class="k">if</span> <span class="n">iseg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">segdone</span><span class="p">:</span>
                <span class="c1"># get all the iso from the segment key</span>
                <span class="n">iso</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">iseg</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span> 
                <span class="c1"># append key to iso  </span>
                <span class="n">iso</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span>
                <span class="c1"># stack all the intervals in increasing order </span>
                <span class="n">ziso</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">iso</span><span class="p">:</span>
                    <span class="n">ziso</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
                <span class="c1"># get the complementary intervals</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;outdoor&#39;</span><span class="p">:</span>
                    <span class="n">zmin</span> <span class="o">=</span> <span class="mf">1e6</span>
                    <span class="n">zmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e6</span>
                    <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="n">ziso</span><span class="p">:</span>
                        <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">iz</span><span class="p">))</span>
                        <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">zmax</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">iz</span><span class="p">))</span>
                    <span class="n">ziso</span> <span class="o">=</span> <span class="p">[(</span><span class="n">zmin</span><span class="p">,</span><span class="n">zmax</span><span class="p">)]</span>
                <span class="n">zair</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">compint</span><span class="p">(</span><span class="n">ziso</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zfloor</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">zceil</span><span class="p">)</span>
                <span class="c1"># add AIR wall in the intervals</span>
                <span class="k">for</span> <span class="n">za</span> <span class="ow">in</span> <span class="n">zair</span><span class="p">:</span> 
                    <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">nta</span><span class="p">,</span> <span class="n">nhe</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AIR&#39;</span><span class="p">,</span>
                            <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="n">za</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">za</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">segdone</span> <span class="o">=</span> <span class="n">segdone</span> <span class="o">+</span> <span class="n">iso</span>

        <span class="c1">#</span>
        <span class="c1"># add _AIR wall around the layout</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span>
        
        <span class="c1"># compliant with config file without  material/slab information</span>
        <span class="c1">#</span>
        <span class="c1"># {latlon] </span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">has_section</span><span class="p">(</span><span class="s1">&#39;latlon&#39;</span><span class="p">):</span>
            <span class="n">llcrnrlon</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;latlon&#39;</span><span class="p">,</span> <span class="s1">&#39;llcrnrlon&#39;</span><span class="p">))</span>
            <span class="n">llcrnrlat</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;latlon&#39;</span><span class="p">,</span> <span class="s1">&#39;llcrnrlat&#39;</span><span class="p">))</span>
            <span class="n">urcrnrlon</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;latlon&#39;</span><span class="p">,</span> <span class="s1">&#39;urcrnrlon&#39;</span><span class="p">))</span>
            <span class="n">urcrnrlat</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;latlon&#39;</span><span class="p">,</span> <span class="s1">&#39;urcrnrlat&#39;</span><span class="p">))</span>
            <span class="n">projection</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;latlon&#39;</span><span class="p">,</span><span class="s1">&#39;projection&#39;</span><span class="p">)</span>
            <span class="n">lon_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">llcrnrlon</span><span class="o">+</span><span class="n">urcrnrlon</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
            <span class="n">lat_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">llcrnrlat</span><span class="o">+</span><span class="n">urcrnrlat</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>

            <span class="c1"># Construction of Basemap for coordinates transformation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">Basemap</span><span class="p">(</span><span class="n">llcrnrlon</span><span class="o">=</span><span class="n">llcrnrlon</span><span class="p">,</span> 
                             <span class="n">llcrnrlat</span><span class="o">=</span><span class="n">llcrnrlat</span><span class="p">,</span>
                             <span class="n">urcrnrlon</span><span class="o">=</span><span class="n">urcrnrlon</span><span class="p">,</span> 
                             <span class="n">urcrnrlat</span><span class="o">=</span><span class="n">urcrnrlat</span><span class="p">,</span>
                             <span class="n">resolution</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> 
                             <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span> 
                             <span class="n">lon_0</span><span class="o">=</span><span class="n">lon_0</span><span class="p">,</span> 
                             <span class="n">lat_0</span><span class="o">=</span><span class="n">lat_0</span><span class="p">)</span>
            

        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">has_section</span><span class="p">(</span><span class="s1">&#39;files&#39;</span><span class="p">):</span>
            <span class="c1"># self.filematini=config.get(&#39;files&#39;,&#39;materials&#39;)</span>
            <span class="c1"># self.fileslabini=config.get(&#39;files&#39;,&#39;slab&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filefur</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;files&#39;</span><span class="p">,</span> <span class="s1">&#39;furniture&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">has_section</span><span class="p">(</span><span class="s1">&#39;slabs&#39;</span><span class="p">):</span>
            <span class="c1">#filemat = self._filename.replace(&#39;ini&#39;, &#39;mat&#39;)</span>
            <span class="c1">#fileslab = self._filename.replace(&#39;ini&#39;, &#39;slab&#39;)</span>

            <span class="n">ds</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;slabs&#39;</span><span class="p">]</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">di</span><span class="p">[</span><span class="s1">&#39;materials&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dm</span><span class="p">:</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">dm</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">SlabDB</span><span class="p">(</span><span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="p">,</span> <span class="n">dm</span><span class="o">=</span><span class="n">dm</span><span class="p">)</span>

        <span class="c1"># In this section we handle the ini file format evolution</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;fileoverlay&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fileoverlay&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;box&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;inverse&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;inverse&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="c1"># convert graph Gs to numpy arrays for faster post processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filelay</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>
        

<div class="viewcode-block" id="Layout.loadfur"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.loadfur">[docs]</a>    <span class="k">def</span> <span class="nf">loadfur</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_filefur</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; loadfur load a furniture file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        _filefur  : string</span>
<span class="sd">            short name of the furniture ini file</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">            Furniture objects are stored in self.lfur list</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Load a Layout file and an associated furniture ini file</span>



<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout(&#39;WHERE1.ini&#39;)</span>
<span class="sd">            &gt;&gt;&gt; L.loadfur(&#39;Furw1.ini&#39;)</span>
<span class="sd">            &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">            &gt;&gt;&gt; ax = fig.gca()</span>
<span class="sd">            &gt;&gt;&gt; fig,ax = L.showGs(fig=fig,ax=ax,furniture=True)</span>
<span class="sd">            &gt;&gt;&gt; ti = plt.title(&#39;loadfur&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filefur</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filefur</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRFUR&#39;</span><span class="p">])</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filefur</span><span class="p">)</span>
        <span class="n">furname</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfur</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">furname</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">fur</span><span class="o">.</span><span class="n">Furniture</span><span class="p">()</span>
            <span class="n">F</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">_filefur</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lfur</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filefur</span> <span class="o">=</span> <span class="n">_filefur</span></div>

<div class="viewcode-block" id="Layout.load_modif"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.load_modif">[docs]</a>    <span class="k">def</span> <span class="nf">load_modif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_filename</span><span class="p">,</span> <span class="n">build</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dist_m</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; load a Layout in different formats</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        _filename : string</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        +  .lay   : ini file format (natural one) DIRLAY</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">newfile</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLAY&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>  <span class="c1"># which exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loadini</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># which do not exist</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">_filename</span>
            <span class="n">newfile</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;new file&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>

        <span class="c1">#  construct geomfile (.off) for vizualisation with geomview</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subseg</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">newfile</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geomfile</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;problem to construct geomfile&quot;</span><span class="p">)</span>
        <span class="c1"># if check:</span>
        <span class="c1">#     self.check()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></div>

        <span class="c1"># create shapely polygons L._shseg</span>

<div class="viewcode-block" id="Layout.subseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.subseg">[docs]</a>    <span class="k">def</span> <span class="nf">subseg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; establishes the association : name &lt;-&gt;  edgelist</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dico : dict</span>
<span class="sd">               sub segment name as key and segment number as value</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dico</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">listtransition</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;transition&#39;</span> <span class="ow">in</span> <span class="n">dk</span><span class="p">:</span>
                <span class="n">transition</span> <span class="o">=</span> <span class="n">dk</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">transition</span><span class="p">:</span>
                    <span class="n">listtransition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;ss_name&#39;</span> <span class="ow">in</span> <span class="n">dk</span><span class="p">:</span>
                <span class="n">lname</span> <span class="o">=</span> <span class="n">dk</span><span class="p">[</span><span class="s1">&#39;ss_name&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lname</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dico</span><span class="p">:</span>
                        <span class="n">dico</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dico</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dsseg</span> <span class="o">=</span> <span class="n">dico</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listtransition</span> <span class="o">=</span> <span class="n">listtransition</span>
        <span class="k">return</span><span class="p">(</span><span class="n">dico</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.add_pnod"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_pnod">[docs]</a>    <span class="k">def</span> <span class="nf">add_pnod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Project point p on segment e1 along segment e2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            p  : ndarray</span>
<span class="sd">                point</span>
<span class="sd">            e1 : int</span>
<span class="sd">                edge number 1</span>
<span class="sd">            e2 : int</span>
<span class="sd">                edge number 2</span>

<span class="sd">        ..todo</span>
<span class="sd">            This function is void</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#p1 = p + alpha*ve2</span>
        <span class="c1">#p1 = pa + beta * (pb-pa)</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Layout.add_fnod"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_fnod">[docs]</a>    <span class="k">def</span> <span class="nf">add_fnod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; add free node  p</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        p :  (1x2) tuple</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout(&#39;defstr.str&#39;)</span>
<span class="sd">            &gt;&gt;&gt; L.add_fnod((10.0,10.0))</span>
<span class="sd">            -9</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># update labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">num</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.add_nfpe"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_nfpe">[docs]</a>    <span class="k">def</span> <span class="nf">add_nfpe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add node on s1 from projection of np0 along s2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        np0  : point number</span>
<span class="sd">        s1   : edge number 1</span>
<span class="sd">        s2   : edge number 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
        <span class="n">np2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="n">xA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># printxA,yA</span>
        <span class="c1"># printxB,yB</span>
        <span class="c1"># printxC,yC</span>
        <span class="c1"># printxD,yD</span>
        <span class="c1"># printxP,yP</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xB</span> <span class="o">-</span> <span class="n">xA</span><span class="p">,</span> <span class="n">xD</span> <span class="o">-</span> <span class="n">xC</span><span class="p">],</span> <span class="p">[</span><span class="n">yB</span> <span class="o">-</span> <span class="n">yA</span><span class="p">,</span> <span class="n">yD</span> <span class="o">-</span> <span class="n">yC</span><span class="p">]])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xP</span> <span class="o">-</span> <span class="n">xA</span><span class="p">,</span> <span class="n">yP</span> <span class="o">-</span> <span class="n">yA</span><span class="p">])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_pons</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>
        <span class="c1"># printx</span>

<div class="viewcode-block" id="Layout.add_pons"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_pons">[docs]</a>    <span class="k">def</span> <span class="nf">add_pons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add point on segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ns  : int</span>
<span class="sd">            segment number</span>
<span class="sd">        alpha : parameterization of the point</span>
<span class="sd">            alpha = 0 (tail) alpha = 1 (head)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        delete segment ns</span>
<span class="sd">        create 2 segments with same properties</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
        <span class="n">namens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="n">zminns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">zmaxns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nop</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nop</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nop</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nop</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># delete old edge ns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">del_segment</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
        <span class="c1"># add new edge np[0] num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">nop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">namens</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span>
                         <span class="n">zminns</span><span class="p">,</span> <span class="n">zmaxns</span><span class="p">],</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># add new edge num np[1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">nop</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">namens</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span>
                         <span class="n">zminns</span><span class="p">,</span> <span class="n">zmaxns</span><span class="p">],</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.add_segment"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_segment">[docs]</a>    <span class="k">def</span> <span class="nf">add_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                    <span class="n">n1</span><span class="p">,</span>
                    <span class="n">n2</span><span class="p">,</span>
                    <span class="n">num</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">maxnum</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">transition</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PARTITION&#39;</span><span class="p">,</span> 
                    <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">40000000</span><span class="p">),</span> 
                    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  add segment between node n1 and node n2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        n1  : integer &lt; 0</span>
<span class="sd">        n2  : integer &lt; 0</span>
<span class="sd">        num : segment index (-1 default not given)</span>
<span class="sd">        maxnum : maximum number (-1 default not given) </span>
<span class="sd">        name : string</span>
<span class="sd">            layer name &#39;PARTITION&#39;</span>
<span class="sd">        z : tuple of 2 floats</span>
<span class="sd">            default = (0,40000000)</span>
<span class="sd">        offset : float</span>
<span class="sd">            [-1,1] default (0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        num : segment number (&gt;0)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        A segment dictionnary has the following mandatory attributes</span>

<span class="sd">        name : slab name associated with segment</span>
<span class="sd">        z : list (zmin,zmax)   (meters)</span>
<span class="sd">        norm : array  (1x3)  segment normal</span>
<span class="sd">        transition : boolean</span>
<span class="sd">        ncycles : list of involved cycles</span>
<span class="sd">        connect : list of point number</span>
<span class="sd">        iso : list of isosegment </span>

<span class="sd">        If a segment is _AIR it cannnot be duplicated </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if 2 points are selected</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">n1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n1</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">)):</span>
            <span class="n">nseg</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nseg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxnum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">nseg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># index not given </span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># first segment index not given</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1"># segment index given  </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;add_segment : error not a node&quot;</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># transition = False</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">):</span>
            <span class="c1"># if name == &#39;AIR&#39;:</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span>
        <span class="n">p2mp1</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">p2mp1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p2mp1</span><span class="p">,</span> <span class="n">p2mp1</span><span class="p">))</span>

        <span class="c1">#</span>
        <span class="c1"># n = t x z  (2D)</span>
        <span class="c1">#</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1">#</span>
        <span class="c1"># Two segments with the same end points are iso segments</span>
        <span class="c1">#</span>
        <span class="c1"># is there an other segments with the same neighbors ?</span>

        <span class="n">nbnta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">nbnhe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>

        <span class="n">same_seg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nbnta</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nbnhe</span><span class="p">))</span>

        <span class="c1">#</span>
        <span class="c1"># Impossible to have duplicated _AIR</span>
        <span class="c1">#</span>
        <span class="c1"># Warning : The 3 following lines are very important </span>
        <span class="c1"># it breaks buildGt if commented</span>
        <span class="c1"># Please do not comment them. </span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">same_seg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="c1">#</span>
        <span class="c1"># add a segment node to Gs</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">,</span>
                         <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">,</span>
                         <span class="n">transition</span> <span class="o">=</span> <span class="n">transition</span><span class="p">,</span>
                         <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                         <span class="n">connect</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">],</span>
                         <span class="n">iso</span> <span class="o">=</span> <span class="p">[],</span>
                         <span class="n">ncycles</span> <span class="o">=</span> <span class="p">[]</span>
                         <span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># update iso of the 2 segments </span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">same_seg</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Segment punctual position is in the middle of segment</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Connectivity between segment node num and points nodes n1 and n2</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Update current total number of segments</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># update slab name &lt;-&gt; edge number dictionnary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span><span class="p">]</span>
        <span class="c1"># update label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># update shseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">num</span><span class="p">:</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">]))})</span>

        <span class="k">return</span><span class="p">(</span><span class="n">num</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.wedge2"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.wedge2">[docs]</a>    <span class="k">def</span> <span class="nf">wedge2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apnt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate wedge angle of a point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        lpnt : array int</span>
<span class="sd">           list of point number</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">apnt</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">apnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">apnt</span><span class="p">)</span>

        <span class="c1"># 0. Find the position of diffraction point</span>
        <span class="n">ptdiff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iupnt</span><span class="p">[</span><span class="o">-</span><span class="n">apnt</span><span class="p">]]</span>

        <span class="c1"># 1. Find the associated segments and positions of a diff points</span>

        <span class="n">aseg</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">],</span>
                                    <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                   <span class="n">apnt</span><span class="p">)</span>
        <span class="c1"># manage flat angle : diffraction by flat segment e.g. door limitation)</span>
        <span class="p">[</span><span class="n">aseg</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aseg</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># get points positions</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">aseg</span><span class="p">))</span>

        <span class="n">pt1</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># tail seg1</span>
        <span class="n">ph1</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># head seg1</span>
        <span class="n">pt2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># tail seg2</span>
        <span class="n">ph2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># head seg2</span>

        <span class="c1"># 2. Make the correct association</span>
        <span class="c1"># pts is (nb_diffraction_points x 4 x 2)</span>
        <span class="c1"># - The dimension 4 represent the 2x2 points: t1,h1 and t2,h2</span>
        <span class="c1"># tail and head of segemnt 1 and 2 respectively</span>
        <span class="c1"># a segment</span>
        <span class="c1"># - The dimension 2 is x,y</span>
        <span class="c1">#</span>
        <span class="c1"># The following aims to determine which tails and heads of</span>
        <span class="c1"># segments associated to a give diffraction point</span>
        <span class="c1"># are connected</span>

        <span class="c1"># point diff is pt1</span>
        <span class="n">updpt1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># point diff is ph1</span>
        <span class="n">updph1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">ph1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># point diff is pt2</span>
        <span class="n">updpt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># point diff is ph2</span>
        <span class="n">updph2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span> <span class="o">==</span> <span class="n">ph2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">apnt</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">apnt</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># seg 1 :</span>
        <span class="c1"># if pt1 diff point =&gt;  ph1 is the other point</span>
        <span class="n">pa</span><span class="p">[</span><span class="n">updpt1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ph1</span><span class="p">[</span><span class="n">updpt1</span><span class="p">]</span>
        <span class="c1"># if ph1 diff point =&gt;  pt1 is the other point</span>
        <span class="n">pa</span><span class="p">[</span><span class="n">updph1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt1</span><span class="p">[</span><span class="n">updph1</span><span class="p">]</span>
        <span class="c1"># seg 2 :</span>
        <span class="c1"># if pt2 diff point =&gt;  ph2 is the other point</span>
        <span class="n">pb</span><span class="p">[</span><span class="n">updpt2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ph2</span><span class="p">[</span><span class="n">updpt2</span><span class="p">]</span>
        <span class="c1"># if ph2 diff point =&gt;  pt2 is the other point</span>
        <span class="n">pb</span><span class="p">[</span><span class="n">updph2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="n">updph2</span><span class="p">]</span>
        <span class="c1"># pt is the diffraction point</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">ptdiff</span><span class="o">.</span><span class="n">T</span>

        <span class="n">vptpa</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pa</span>
        <span class="n">vptpan</span> <span class="o">=</span> <span class="n">vptpa</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">vptpa</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vptpa</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">vptpb</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">pb</span>
        <span class="n">vptpbn</span> <span class="o">=</span> <span class="n">vptpb</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">vptpb</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">vptpb</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">vptpan</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">vptpbn</span>

        <span class="n">ang</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">vecang</span><span class="p">(</span><span class="n">vptpbn</span><span class="p">,</span> <span class="n">vptpan</span><span class="p">)</span>
        <span class="n">ang</span><span class="p">[</span><span class="o">~</span><span class="n">uleft</span><span class="p">]</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">vecang</span><span class="p">(</span><span class="n">vptpan</span><span class="p">,</span> <span class="n">vptpan</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.wedge"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.wedge">[docs]</a>    <span class="k">def</span> <span class="nf">wedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpnt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate wedge angle of a point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        lpnt : list of int</span>
<span class="sd">           list of point number</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">aseg</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">],</span>
                                    <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span>
                   <span class="n">lpnt</span><span class="p">)</span>

        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span>
            <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">aseg</span><span class="p">))</span>
        <span class="c1">#map(lambda x: pt ,pts)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sector</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">pt1</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">ph1</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pt2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ph2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pt1</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">ph1</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">ph2</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">pt1</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">sector</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pt1</span> <span class="o">==</span> <span class="n">ph2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">ph1</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">pt2</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">pt1</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">sector</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ph1</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">pt1</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">ph2</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">ph1</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">sector</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ph1</span> <span class="o">==</span> <span class="n">ph2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">pt1</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">pt2</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">ph1</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">sector</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>

            <span class="n">sector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">sector</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.add_furniture"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_furniture">[docs]</a>    <span class="k">def</span> <span class="nf">add_furniture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;R1_C&#39;</span><span class="p">,</span> <span class="n">matname</span><span class="o">=</span><span class="s1">&#39;PARTITION&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>
                      <span class="n">zmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  add piece of furniture</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        name : string</span>
<span class="sd">            default = &#39;R1_C&#39;</span>
<span class="sd">        matname : string</span>
<span class="sd">            default = &#39;PARTITION&#39;</span>
<span class="sd">        origin : tuple of floats</span>
<span class="sd">        height : float</span>
<span class="sd">            default = 0</span>
<span class="sd">        width : float</span>
<span class="sd">            default = 0</span>
<span class="sd">        length : float</span>
<span class="sd">            default = 0</span>
<span class="sd">        angle : float</span>
<span class="sd">            default = 0</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the four points</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)])</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">length</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">v</span> <span class="o">*</span> <span class="n">width</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">u</span> <span class="o">*</span> <span class="n">length</span>
        <span class="c1"># adding free nodes</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
        <span class="n">n3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">(</span><span class="n">p3</span><span class="p">)</span>
        <span class="c1"># adding segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">matname</span><span class="p">,</span> <span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span> <span class="o">+</span> <span class="n">height</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">matname</span><span class="p">,</span> <span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span> <span class="o">+</span> <span class="n">height</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">matname</span><span class="p">,</span> <span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span> <span class="o">+</span> <span class="n">height</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n3</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">matname</span><span class="p">,</span> <span class="p">[</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmin</span> <span class="o">+</span> <span class="n">height</span><span class="p">])</span></div>

<div class="viewcode-block" id="Layout.add_furniture_file"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.add_furniture_file">[docs]</a>    <span class="k">def</span> <span class="nf">add_furniture_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_filefur</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  add pieces of furniture from .ini files</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        _filefur : string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filefur</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filefur</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRFUR&#39;</span><span class="p">])</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
        <span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filefur</span><span class="p">)</span>
        <span class="n">furname</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fur</span> <span class="ow">in</span> <span class="n">furname</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>
            <span class="n">matname</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;matname&quot;</span><span class="p">)</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span><span class="p">)))</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">)</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;angle&quot;</span><span class="p">)</span>
            <span class="n">thickness</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="n">fur</span><span class="p">,</span> <span class="s2">&quot;thickness&quot;</span><span class="p">)</span>
            <span class="c1"># ~ if matname==&#39;WOOD&#39;:</span>
            <span class="c1"># ~ zmin = height</span>
            <span class="c1"># ~ height=thickness</span>
            <span class="c1"># ~ else:</span>
            <span class="c1"># ~ zmin=0.0</span>
            <span class="c1"># .. todo: be more generic relate to floor level</span>
            <span class="n">zmin</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_furniture</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">matname</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span>
                                   <span class="n">zmin</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_furniture</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">matname</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span>
                                       <span class="n">zmin</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;No such furniture type - &#39;</span> <span class="o">+</span> <span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.del_points"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.del_points">[docs]</a>    <span class="k">def</span> <span class="nf">del_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; delete points in list lp</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        lp : list</span>
<span class="sd">            node list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># test if array</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">ln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>

        <span class="c1"># test if list</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="p">[</span><span class="n">lp</span><span class="p">]</span>

        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;lp : &quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">)</span>
        <span class="c1"># get segments involved in points list</span>
        <span class="n">ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd2seg</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;ls : &quot;</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span>
        <span class="c1"># 1) delete involved segments</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_segment</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;del &#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="c1"># 2) delete involved points</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">lp</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">n1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># 3) updating structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.del_segment"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.del_segment">[docs]</a>    <span class="k">def</span> <span class="nf">del_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">le</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">g2npy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; delete segment e</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        le : list of segment number</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout.Layout.del_node</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        100% of time is in g2npy</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">le</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">le</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">le</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">le</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">le</span> <span class="o">=</span> <span class="p">[</span><span class="n">le</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">le</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iso</span> 
             <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">]]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>  <span class="c1"># delete edge position</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># update slab name &lt;-&gt; edge number dictionnary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="c1"># delete iso if required</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># remove shapely seg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">g2npy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.point_touches_seg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.point_touches_seg">[docs]</a>    <span class="k">def</span> <span class="nf">point_touches_seg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pt</span><span class="p">,</span><span class="n">lseg</span><span class="o">=</span><span class="p">[],</span><span class="n">segtol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span><span class="n">tahetol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; determine if a point is touching a segment</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">            pt : a point (2,)</span>
<span class="sd">            seg : a list of segments to test. </span>
<span class="sd">                 if [] =&gt; all Gs segments are tested</span>

<span class="sd">            segdtol : distance tolerance point to segment</span>
<span class="sd">            tahetol : distance tolerance point to segment extremeties</span>
<span class="sd">                        =&gt; a point on segment extremeties is considered</span>
<span class="sd">                           not touching the segseg</span>



<span class="sd">            Return</span>
<span class="sd">            ------</span>

<span class="sd">            ltseg : lsit of touched segments (by the point)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lseg</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">lseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>

        <span class="n">ltseg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lseg</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">allnodes</span><span class="p">:</span>
                <span class="n">n0</span><span class="p">,</span><span class="n">n1</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;connect&#39;</span><span class="p">]</span>
                <span class="n">dta</span><span class="p">,</span><span class="n">dhe</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">dptseg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)[:,</span><span class="bp">None</span><span class="p">],</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n0</span><span class="p">])[:,</span><span class="bp">None</span><span class="p">],</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])[:,</span><span class="bp">None</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;=</span> <span class="n">segtol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">dta</span> <span class="o">&gt;</span> <span class="n">tahetol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dhe</span> <span class="o">&gt;</span> <span class="n">tahetol</span><span class="p">)):</span>
                    <span class="n">ltseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ltseg</span></div>



<div class="viewcode-block" id="Layout.seg_intersection"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seg_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">seg_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            determine if a segment intersects any other segment of the layout</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">            shLine : a shapely LineString</span>
<span class="sd">            OR</span>
<span class="sd">            ta,he : tail/head coordinates of a segment</span>

<span class="sd">            Return</span>
<span class="sd">            ------</span>
<span class="sd">            </span>
<span class="sd">            llay_seg : list of layout&#39;s segments intersected</span>
<span class="sd">            lshP : list of shapely points of intersections.</span>
<span class="sd">            </span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;ta&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;he&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ta&#39;</span><span class="p">],</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;he&#39;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="s1">&#39;shLine&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shLine&#39;</span><span class="p">]</span>

        <span class="c1"># WARNING : use crosses instead of interesects</span>
        <span class="c1"># otherwise 2 segment connected to a same node</span>
        <span class="c1"># are considered as intersecting</span>
        <span class="n">binter</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">uinter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">binter</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">llay_seg</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lshP</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">uinter</span><span class="p">:</span>
                <span class="c1"># layout segment </span>
                <span class="n">llay_seg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">lay_shseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span><span class="p">[</span><span class="n">llay_seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># intersection shapely point</span>
                <span class="n">lshP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">lay_shseg</span><span class="p">))</span>

            <span class="k">return</span><span class="p">(</span><span class="n">llay_seg</span><span class="p">,</span><span class="n">lshP</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">([],[])</span></div>





<div class="viewcode-block" id="Layout.mask"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  returns the polygonal mask of the building</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        mask : geu.Polygon</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function assumes graph Gt has been generated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Gt</span><span class="p">):</span>
            <span class="c1"># takes the 1st cycle polygon</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="c1"># get the exterior of the polygon</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="p">)</span>
            <span class="c1"># make the union of the exterior of all the cycles</span>
            <span class="c1">#</span>
            <span class="c1"># cycle : -1 exterior</span>
            <span class="c1">#          0 ??</span>
            <span class="c1">#</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
                    <span class="n">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="p">))</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gt not built&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.translate"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; translate layout</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">     loa   vec :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Layout.rotate"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; rotate the layout</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        angle : float</span>
<span class="sd">            (degrees)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)]]),</span> <span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.check2"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.check2">[docs]</a>    <span class="k">def</span> <span class="nf">check2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Layout checking</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tseg</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lnp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">lnp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">lnp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">tseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">([(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])]))</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tseg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">seg1</span> <span class="o">=</span> <span class="n">tseg</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">seg2</span> <span class="o">=</span> <span class="n">tseg</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">seg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;crosses :&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">seg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;contains :&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">seg2</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">seg1</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;contains :&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">overlaps</span><span class="p">(</span><span class="n">seg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;overlaps :&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">seg2</span><span class="o">.</span><span class="n">overlaps</span><span class="p">(</span><span class="n">seg1</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;overlaps :&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span><span class="p">(</span><span class="n">tseg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.cleanup"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; cleanup the Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        1. Remove nodes which are not connected</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Np</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.displaygui"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.displaygui">[docs]</a>    <span class="k">def</span> <span class="nf">displaygui</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; open a GUI for displaying configuration</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">displaygui</span> <span class="o">=</span> <span class="n">eag</span><span class="o">.</span><span class="n">multenterbox</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Display Parameters&#39;</span><span class="p">,</span>
                                  <span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;nodes&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;ednodes&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;ndlabel&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;edlabel&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;edges&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;subseg&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;visu&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;thin&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;scaled&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;overlay&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;overlay_file&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;overlay_flip&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;alpha&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ednodes&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ndlabel&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlabel&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;subseg&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;visu&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;scaled&#39;</span><span class="p">]),</span>
                                   <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay&#39;</span><span class="p">]),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">displaygui</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">displaygui</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ednodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ndlabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;subseg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;visu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;scaled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">10</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">displaygui</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">displaygui</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span></div>

<div class="viewcode-block" id="Layout.info_segment"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.info_segment">[docs]</a>    <span class="k">def</span> <span class="nf">info_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; information about segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        s1 : segment number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nebd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">nebd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">nebd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nns1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">nns2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
        <span class="n">ds1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="s1">&#39; : &#39;</span><span class="p">,</span> <span class="n">nns1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="s1">&#39; : &#39;</span><span class="p">,</span> <span class="n">nns2</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;------------&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Slab     : &#39;</span><span class="p">,</span> <span class="n">ds1</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;zmin (m) : &#39;</span><span class="p">,</span> <span class="n">ds1</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;zmax (m) : &#39;</span><span class="p">,</span> <span class="n">ds1</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;------------&#39;</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">ds1</span><span class="p">[</span><span class="s1">&#39;ss_name&#39;</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;subseg Slabs  : &#39;</span><span class="p">,</span> <span class="n">ds1</span><span class="p">[</span><span class="s1">&#39;ss_name&#39;</span><span class="p">])</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;subseg (zmin,zmax) (m) : &#39;</span><span class="p">,</span> <span class="n">ds1</span><span class="p">[</span><span class="s1">&#39;ss_z&#39;</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="Layout.edit_point"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.edit_point">[docs]</a>    <span class="k">def</span> <span class="nf">edit_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; edit point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        np : integer</span>
<span class="sd">            point number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Enter coordinates &quot;</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">eag</span><span class="o">.</span><span class="n">multenterbox</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="p">((</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)),</span>
                            <span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="Layout.edit_segment"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.edit_segment">[docs]</a>    <span class="k">def</span> <span class="nf">edit_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">gui</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">outdata</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; edit segment WITH EasyGUI</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        e1 : integer</span>
<span class="sd">            edge number</span>
<span class="sd">        gui : boolean</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        A segment has the following properties :</span>
<span class="sd">            + name  : string</span>
<span class="sd">            + z  :  tuple</span>
<span class="sd">            + transition : boolean (default FALSE)</span>

<span class="sd">        If a segment has subsegments attached the following properties are</span>
<span class="sd">        added :</span>
<span class="sd">            + ss_name : string</span>
<span class="sd">            + ss_z : subsegment [(min height (meters),max height (meters))]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nebd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">nebd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">nebd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">de1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Segment (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;ss_name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">de1</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">de1k</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">]</span>
            <span class="n">de1v</span> <span class="o">=</span> <span class="p">[</span><span class="n">de1</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">de1k</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;ss_name&#39;</span><span class="p">,</span> <span class="s1">&#39;ss_z&#39;</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="s1">&#39;ss_offset&#39;</span><span class="p">]</span>
            <span class="n">de1v</span> <span class="o">=</span> <span class="p">[</span><span class="n">de1</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;ss_name&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;ss_z&#39;</span><span class="p">],</span>
                    <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">],</span> <span class="n">de1</span><span class="p">[</span><span class="s1">&#39;ss_offset&#39;</span><span class="p">]]</span>
        <span class="c1">#de1v    = de1.values()</span>
        <span class="k">if</span> <span class="n">gui</span><span class="p">:</span>
            <span class="n">outdata</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">data0</span> <span class="o">=</span> <span class="n">choicebox</span><span class="p">(</span><span class="s1">&#39;chose slab&#39;</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data1</span> <span class="o">=</span> <span class="n">eag</span><span class="o">.</span><span class="n">multenterbox</span><span class="p">(</span>
                    <span class="s1">&#39;attribute for &#39;</span> <span class="o">+</span> <span class="n">data0</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">de1k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">de1v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="n">d1t</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="nb">eval</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">eval</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                <span class="n">data1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1t</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data0</span><span class="p">]</span> <span class="o">+</span> <span class="n">data1</span>
                <span class="c1">#data = eag.multenterbox(message, title, tuple(de1k), tuple(de1v))</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">de1</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">de1k</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">outdata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">outdata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">e1</span><span class="p">]</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># if cancel</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outdata</span> <span class="o">==</span> <span class="p">{}:</span>
                <span class="k">pass</span>
                <span class="c1"># data = {}</span>
                <span class="c1"># val = &#39;1&#39;</span>
                <span class="c1"># while(val!=&#39;0&#39;):</span>
                <span class="c1">#     clear</span>
                <span class="c1">#     print&#39;0 : exit&#39;</span>
                <span class="c1">#     for e,(k,v) in enumerate(zip(de1k,de1v)):</span>
                <span class="c1">#         printstr(e+1)+ &#39; &#39;+k+&#39;: &#39;+  str(v)+&#39;\n&#39;</span>
                <span class="c1">#     val = input(&#39;Your choice :&#39;)</span>
                <span class="c1">#     if val!=&#39;0&#39;:</span>
                <span class="c1">#         pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">de1k</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">outdata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outdata</span></div>

<div class="viewcode-block" id="Layout.edit_seg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.edit_seg">[docs]</a>    <span class="k">def</span> <span class="nf">edit_seg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; edit segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        e1 : integer</span>
<span class="sd">            edge number</span>
<span class="sd">        data : dict</span>
<span class="sd">            dictionnary of value of seg or subseg</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        A segment has the following properties :</span>
<span class="sd">            + name  : string</span>
<span class="sd">            + z  :  tuple</span>
<span class="sd">            + transition : boolean (default FALSE)</span>
<span class="sd">            + offset : [-1,1]</span>
<span class="sd">        If a segment has subsegments attached the following properties are</span>
<span class="sd">        added :</span>
<span class="sd">            + ss_name : list of string</span>
<span class="sd">            + ss_z : list of subsegment e.q. [(min height (meters),max height (meters))]</span>
<span class="sd">            + ss_offset : list of offset in [0,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">ename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="c1"># manage self.name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">ename</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">ename</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">e1</span><span class="p">))</span>
            <span class="c1"># manage self.display[&#39;name&#39;]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">ename</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ename</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span><span class="o">=</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;layers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Layout.have_subseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.have_subseg">[docs]</a>    <span class="k">def</span> <span class="nf">have_subseg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check if edge e1 have subseg</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            e1 : int </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">            have_subseg_bool : boolean </span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;ss_name&#39;</span> <span class="ow">in</span> <span class="n">dk</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="Layout.find_edgelist"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.find_edgelist">[docs]</a>    <span class="k">def</span> <span class="nf">find_edgelist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        edgelist = find_edgelist(edgelist,nodelist)</span>

<span class="sd">        edgelist : input edgelist</span>
<span class="sd">        nodelist : input nodelist</span>

<span class="sd">        return the subset of edgelist</span>

<span class="sd">        Not Finished :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">]</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">]</span>

        <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d_nu</span><span class="p">[</span><span class="n">tail</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">]</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d_nu</span><span class="p">[</span><span class="n">head</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">]</span>

        <span class="n">edgelist</span> <span class="o">=</span> <span class="n">edgelist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ed_t</span><span class="p">,</span> <span class="n">ed_h</span><span class="p">)]</span>
        <span class="k">return</span><span class="p">(</span><span class="n">edgelist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.diag"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.diag">[docs]</a>    <span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">al1</span><span class="p">,</span> <span class="n">al2</span><span class="p">,</span> <span class="n">quadsel</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return edge list from a diagonal zone</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        p1  : np.array</span>
<span class="sd">        p2  : np.array</span>
<span class="sd">        tol :</span>
<span class="sd">        al1 :</span>
<span class="sd">        al2 :</span>
<span class="sd">        quadsel : 0   all quadrant</span>
<span class="sd">              2 1</span>
<span class="sd">              3 4</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        edgelist</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1">#</span>
        <span class="c1"># selection du quadran</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">quadsel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Np</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">quadsel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">quadsel</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">quadsel</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">quadsel</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">x_u0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">u0</span><span class="p">]</span>
        <span class="n">y_u0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u0</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Permutation points</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">p2</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">pt</span>
        <span class="c1">#</span>
        <span class="c1"># Box length</span>
        <span class="c1">#</span>

        <span class="n">Dx</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Dy</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Dx</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Dy</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># p1 p2</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">Dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">Dy</span> <span class="o">/</span> <span class="n">Dx</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span>

            <span class="n">delta_b</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Dx</span><span class="p">)</span>
            <span class="n">delta_b1</span> <span class="o">=</span> <span class="n">al1</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Dy</span><span class="p">)</span>
            <span class="n">delta_b2</span> <span class="o">=</span> <span class="n">al2</span> <span class="o">*</span> <span class="n">L</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Dy</span><span class="p">)</span>

            <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_u0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">delta_b</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x_u1</span> <span class="o">=</span> <span class="n">x_u0</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span>
            <span class="n">y_u1</span> <span class="o">=</span> <span class="n">y_u0</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span>
            <span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u1</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_u1</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="n">delta_b</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x_u2</span> <span class="o">=</span> <span class="n">x_u1</span><span class="p">[</span><span class="n">u2</span><span class="p">]</span>
            <span class="n">y_u2</span> <span class="o">=</span> <span class="n">y_u1</span><span class="p">[</span><span class="n">u2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">u3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u2</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">x_u2</span> <span class="o">/</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">delta_b1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x_u3</span> <span class="o">=</span> <span class="n">x_u2</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">y_u3</span> <span class="o">=</span> <span class="n">y_u2</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">u4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u3</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">x_u3</span> <span class="o">/</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">delta_b2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u2</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">x_u2</span> <span class="o">/</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">+</span> <span class="n">delta_b1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x_u3</span> <span class="o">=</span> <span class="n">x_u2</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">y_u3</span> <span class="o">=</span> <span class="n">y_u2</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">u4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u3</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">x_u3</span> <span class="o">/</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">delta_b2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x_u4</span> <span class="o">=</span> <span class="n">x_u3</span><span class="p">[</span><span class="n">u4</span><span class="p">]</span>
                <span class="n">y_u4</span> <span class="o">=</span> <span class="n">y_u3</span><span class="p">[</span><span class="n">u4</span><span class="p">]</span>
<span class="c1">#</span>
<span class="c1"># p1 p2 vertical</span>
<span class="c1">#</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Dx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
            <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">tol</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x_u1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span>
            <span class="n">y_u1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span>
            <span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x_u1</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tol</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y_u2</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">u3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u2</span> <span class="o">&lt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">al1</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y_u3</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">u4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u3</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">al2</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u2</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">al2</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y_u3</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">u4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u3</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">al1</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#</span>
<span class="c1"># p1 p2 horizontal</span>
<span class="c1">#</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Dy</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
            <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tol</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y_u1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span>
            <span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">y_u1</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tol</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x_u2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">u2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">u3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x_u2</span> <span class="o">&lt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">al1</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x_u3</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">u4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x_u3</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">al2</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x_u2</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">al2</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x_u3</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">u3</span><span class="p">]</span>
                <span class="n">u4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">al1</span> <span class="o">*</span> <span class="n">L</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">u0</span><span class="p">[</span><span class="n">u1</span><span class="p">[</span><span class="n">u2</span><span class="p">[</span><span class="n">u3</span><span class="p">[</span><span class="n">u4</span><span class="p">]]]]</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_edge_list</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,</span> <span class="n">nodelist</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">edgelist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.nd2seg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.nd2seg">[docs]</a>    <span class="k">def</span> <span class="nf">nd2seg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; convert node list to edge list</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ndlist : list or ndarray</span>
<span class="sd">            node list</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        seglist : ndarray</span>
<span class="sd">            edge list</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        previously nd2ed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ndlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">ndlist</span> <span class="o">=</span> <span class="n">ndlist</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># for n in ndlist:</span>
        <span class="c1">#    seglist = seglist + self.Gs.adj[n].keys()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">ndlist</span><span class="p">)</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seglist</span><span class="p">))</span></div>

<div class="viewcode-block" id="Layout.ed2nd"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.ed2nd">[docs]</a>    <span class="k">def</span> <span class="nf">ed2nd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; convert edgelist to nodelist</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edlist : list or ndarray</span>
<span class="sd">            edge list</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndlist : ndarray</span>
<span class="sd">            node list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edlist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="n">edlist</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="c1"># mecanisme de concatenation de listes</span>
        <span class="n">ndlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edlist</span><span class="p">:</span>
            <span class="n">ndlist</span> <span class="o">=</span> <span class="n">ndlist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ndlist</span><span class="p">))</span></div>

<div class="viewcode-block" id="Layout.get_zone"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.get_zone">[docs]</a>    <span class="k">def</span> <span class="nf">get_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get point list and segment list in a rectangular zone</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax  : list ot tuple</span>
<span class="sd">            [xmin,xmax,ymin,ymax]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ptlist,seglist</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xmin</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">ptlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">ymax</span><span class="p">)):</span>
                    <span class="n">ptlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd2seg</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ptlist</span><span class="p">,</span> <span class="n">seglist</span></div>

<div class="viewcode-block" id="Layout.get_points"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get points list and segments list in a polygonal zone</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ax  : list ot tuple</span>
<span class="sd">            [xmin,xmax,ymin,ymax]</span>
<span class="sd">              or shapely Polygon </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        (pt,ke) : points coordinates and index </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This methods returns all the </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">==</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">eax</span>  <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">eax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">eax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">eax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">eax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        
        <span class="c1">#</span>
        <span class="c1"># layout points </span>
        <span class="c1">#</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>

        <span class="n">uxmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;=</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">uymin</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">&gt;=</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">uxmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">uymax</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">ymax</span><span class="p">)</span>
        
        <span class="c1">#</span>
        <span class="c1"># k True when all conditons are True simultaneously</span>
        <span class="c1"># </span>
        <span class="n">k</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">uxmin</span><span class="o">*</span><span class="n">uymin</span><span class="o">*</span><span class="n">uxmax</span><span class="o">*</span><span class="n">uymax</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upnt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># if(pt.shape[1]&lt;N):</span>
        <span class="c1">#     plt.ion()</span>
        <span class="c1">#     fig,a=self.showG(&#39;s&#39;)</span>
        <span class="c1">#     a.plot(pt[0,:],pt[1,:],&#39;or&#39;)</span>
        <span class="c1">#     a.plot(eax[0],eax[1],&#39;or&#39;)</span>
        <span class="c1">#     plt.show()</span>
        <span class="c1"># ux = ((x&gt;=xmin).all() and (x&lt;=xmax).all())</span>
        <span class="c1"># uy = ((y&gt;=ymin).all() and (y&lt;=ymax).all())</span>
        <span class="k">return</span><span class="p">((</span><span class="n">pt</span><span class="p">,</span><span class="n">ke</span><span class="p">))</span></div>

<div class="viewcode-block" id="Layout.angleonlink3"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.angleonlink3">[docs]</a>    <span class="k">def</span> <span class="nf">angleonlink3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">p2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot; angleonlink(self,p1,p2) return (seglist,angle) between p1 and p2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        p1 : np.array (3 x N) or (3,)  </span>
<span class="sd">        p2 : np.array (3 x N) or (3,)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        data : structured array x N</span>
<span class="sd">            &#39;i&#39; : index </span>
<span class="sd">            &#39;s&#39; : slab </span>
<span class="sd">            &#39;a&#39; : angle (in radians)</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;DLR.lay&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p1 = np.array([0,0,1])</span>
<span class="sd">        &gt;&gt;&gt; p2 = np.array([10,3,2])</span>
<span class="sd">        &gt;&gt;&gt; data = L.angleonlink3(p1,p2)</span>

<span class="sd">        #array([(0, 141, 1.2793395519256592), (0, 62, 0.29145678877830505),</span>
<span class="sd">               (0, 65, 0.29145678877830505)],</span>
<span class="sd">              dtype=[(&#39;i&#39;, &#39;&lt;i8&#39;), (&#39;s&#39;, &#39;&lt;i8&#39;), (&#39;a&#39;, &#39;&lt;f4&#39;)])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        antprop.loss.Losst </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sh1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">sh2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">sh1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">sh2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sh2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sh1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># 3 x N</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>
        <span class="c1"># 1 x N</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># 3 x N</span>
        <span class="n">un</span> <span class="o">=</span> <span class="n">u</span> <span class="o">/</span> <span class="n">nu</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1">#</span>
        <span class="c1"># warning : seglist contains the segment number in tahe not in Gs</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        
        <span class="n">seglist</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seginframe2</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
    

        <span class="n">upos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">seglist</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">uneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">seglist</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        

        <span class="c1"># nNLOS = len(uneg) + 1</span>
        <span class="c1"># # retrieve the number of segments per link</span>
        <span class="c1"># if nNLOS &gt; 1:</span>
        <span class="c1">#     llink = np.hstack(</span>
        <span class="c1">#         (uneg[0], np.hstack((uneg[1:], array([len(seglist)]))) - uneg - 1))</span>
        <span class="c1"># else:</span>
        <span class="c1">#     llink = np.array([len(seglist)])</span>
        <span class="c1"># [(link id,number of seg),...]</span>
        <span class="c1"># nl = zip(np.arange(nlink),llink)n</span>

        <span class="n">npta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglist</span><span class="p">[</span><span class="n">upos</span><span class="p">]]</span>
        <span class="n">nphe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">seglist</span><span class="p">[</span><span class="n">upos</span><span class="p">]]</span>

        <span class="n">Pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">npta</span><span class="p">]</span>
        <span class="n">Phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">nphe</span><span class="p">]</span>

        
        <span class="c1"># #</span>
        <span class="c1"># # This part should possibly be improved</span>
        <span class="c1"># #</span>

        <span class="c1"># for i, nl in enumerate(llink):</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         # P1 = np.hstack((P1,np.outer(p1[:,i],np.ones(nl))))</span>
        <span class="c1">#         # P2 = np.hstack((P2,np.outer(p2[:,i],np.ones(nl))))</span>
        <span class="c1">#         ilink = np.hstack(</span>
        <span class="c1">#             (ilink, array([-1]), i * np.ones(nl, dtype=&#39;int&#39;)))</span>
        <span class="c1">#     except:</span>
        <span class="c1">#         # P1 = np.outer(p1[:,i],np.ones(nl))</span>
        <span class="c1">#         # P2 = np.outer(p2[:,i],np.ones(nl))</span>
        <span class="c1">#         ilink = i * np.ones(nl, dtype=&#39;int&#39;)</span>

        <span class="c1"># check for intersection P1P2 PtaPhe</span>
        <span class="c1"># bo = geu.intersect(P1[0:-1], P2[0:-1], Pta, Phe)</span>
        <span class="n">Nscreen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">npta</span><span class="p">)</span>
        <span class="c1"># get segment height bounds</span>
        <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">[</span><span class="n">seglist</span><span class="p">[</span><span class="n">upos</span><span class="p">]]])</span>
        <span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">[</span><span class="n">seglist</span><span class="p">[</span><span class="n">upos</span><span class="p">]]])</span>
        <span class="c1"># centroid of the screen</span>
        <span class="n">Pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(((</span><span class="n">Phe</span> <span class="o">+</span> <span class="n">Pta</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="p">(</span><span class="n">zmax</span> <span class="o">+</span> <span class="n">zmin</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span>
        <span class="n">Ptahe</span> <span class="o">=</span> <span class="n">Phe</span> <span class="o">-</span> <span class="n">Pta</span>
        <span class="n">L1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Ptahe</span> <span class="o">*</span> <span class="n">Ptahe</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># 3 x Nscreen U1 is in plane xy</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Ptahe</span> <span class="o">/</span> <span class="n">L1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nscreen</span><span class="p">)))</span>
        <span class="n">L2</span> <span class="o">=</span> <span class="n">zmax</span> <span class="o">-</span> <span class="n">zmin</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])[:,</span> <span class="bp">None</span><span class="p">]</span>  <span class="c1"># 3 x 1  U2 is along z</span>
        <span class="c1">#</span>
        <span class="c1"># p1 : 3 x Ng </span>
        <span class="c1"># p2 : 3 x Ng</span>
        <span class="c1"># Pg : 3 x Nscreen</span>
        <span class="c1"># U1 : 3 x Nscreen </span>
        <span class="c1"># U2 : 3 x 1 </span>
        <span class="c1"># L1 : ,Nscreen</span>
        <span class="c1"># L2 : ,Nscreen </span>

        <span class="n">bo</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">intersect3</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">Pg</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">U2</span><span class="p">,</span> <span class="n">L1</span><span class="p">,</span> <span class="n">L2</span><span class="p">)</span>
        <span class="n">ubo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bo</span><span class="p">)</span>

        <span class="n">Nseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ubo</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nseg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
                        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)])</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ubo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">[</span><span class="n">ubo</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="c1">#</span>
        <span class="c1"># Calculate angle of incidence refered from segment normal</span>
        <span class="c1">#</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[:,</span> <span class="n">ubo</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># vector along the link</span>
        <span class="n">uu</span> <span class="o">=</span> <span class="n">un</span><span class="p">[:,</span> <span class="n">ubo</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">unn</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uu</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">unn</span><span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>

        <span class="k">return</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.angleonlink"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.angleonlink">[docs]</a>    <span class="k">def</span> <span class="nf">angleonlink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">p2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot; angleonlink(self,p1,p2) return (seglist,angle) between p1 and p2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        p1 : np.array (2 x Np) or (2,)</span>
<span class="sd">        p2 : np.array (2 x Np) or (2,)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        data[&#39;i&#39;] </span>
<span class="sd">        data[&#39;s&#39;] : list of segment number </span>
<span class="sd">        data[&#39;a&#39;] : angle (in radians) between segment and LOS axis</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;DLR.lay&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p1 = np.array([0,0])</span>
<span class="sd">        &gt;&gt;&gt; p2 = np.array([10,3])</span>
<span class="sd">        &gt;&gt;&gt; alpha = L.angleonlink(p1,p2)</span>

<span class="sd">        #array([(0, 141, 1.2793395519256592), (0, 62, 0.29145678877830505),</span>
<span class="sd">               (0, 65, 0.29145678877830505)],</span>
<span class="sd">              dtype=[(&#39;i&#39;, &#39;&lt;i8&#39;), (&#39;s&#39;, &#39;&lt;i8&#39;), (&#39;a&#39;, &#39;&lt;f4&#39;)])</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sh1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">sh2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">sh1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">sh2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sh2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sh1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># 2 x N</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>
        <span class="c1"># 1 x N</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># 2 x N</span>
        <span class="n">un</span> <span class="o">=</span> <span class="n">u</span> <span class="o">/</span> <span class="n">nu</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seginframe2</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">upos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">seglist</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">uneg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">seglist</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nNLOS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uneg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># retrieve the number of segments per link</span>
        <span class="k">if</span> <span class="n">nNLOS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">llink</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">uneg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">uneg</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)])))</span> <span class="o">-</span> <span class="n">uneg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">llink</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)])</span>
        
        <span class="c1"># llink : list of link length </span>

        <span class="n">npta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglist</span><span class="p">[</span><span class="n">upos</span><span class="p">]]</span>
        <span class="n">nphe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">seglist</span><span class="p">[</span><span class="n">upos</span><span class="p">]]</span>

        <span class="n">Pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">npta</span><span class="p">]</span>
        <span class="n">Phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">nphe</span><span class="p">]</span>

        
        <span class="c1">#</span>
        <span class="c1"># This part should possibly be improved</span>
        <span class="c1">#</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">llink</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">P1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nl</span><span class="p">))))</span>
                <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">P2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nl</span><span class="p">))))</span>
                <span class="n">ilink</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">ilink</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nl</span><span class="p">))</span>
                <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nl</span><span class="p">))</span>
                <span class="n">ilink</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

        <span class="n">bo</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Pta</span><span class="p">,</span> <span class="n">Phe</span><span class="p">)</span>

        <span class="n">upos_intersect</span> <span class="o">=</span> <span class="n">upos</span><span class="p">[</span><span class="n">bo</span><span class="p">]</span>

        <span class="n">seglist2</span> <span class="o">=</span> <span class="n">seglist</span><span class="p">[</span><span class="n">upos_intersect</span><span class="p">]</span>

        <span class="n">idxlnk</span> <span class="o">=</span> <span class="n">ilink</span><span class="p">[</span><span class="n">upos_intersect</span><span class="p">]</span>
        <span class="c1">#</span>
        <span class="c1"># Calculate angle of incidence refered from segment normal</span>
        <span class="c1">#</span>

        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">seglist2</span><span class="p">]</span>
        <span class="c1"># vector along the linkco</span>
        <span class="n">uu</span> <span class="o">=</span> <span class="n">un</span><span class="p">[:,</span><span class="n">idxlnk</span><span class="p">]</span>
        <span class="n">unn</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uu</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">unn</span><span class="p">)</span>

        <span class="c1"># seglist = seglist+1</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">seglist2</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
                        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)])</span>

        <span class="c1">#</span>
        <span class="c1"># update subsegment in seglist</span>
        <span class="c1">#</span>
        <span class="c1"># self.lsss</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxlnk</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seglist</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
        <span class="k">return</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.angleonlinkold"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.angleonlinkold">[docs]</a>    <span class="k">def</span> <span class="nf">angleonlinkold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">p2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot; angleonlink(self,p1,p2) returns seglist between p1 and p2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        p1 : (1 x 2 )</span>
<span class="sd">            [0,0]</span>
<span class="sd">        p2 : (1 x 2 )</span>
<span class="sd">            [10,3]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        seglist : list</span>
<span class="sd">                  list of segment number on the link</span>
<span class="sd">        theta</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        #&gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        #&gt;&gt;&gt; L = Layout(&#39;DLR.lay&#39;,&#39;matDB.ini&#39;,&#39;slabDB.ini&#39;)</span>
<span class="sd">        #&gt;&gt;&gt; p1 = np.array([0,0])</span>
<span class="sd">        #&gt;&gt;&gt; p2 = np.array([10,3])</span>
<span class="sd">        #&gt;&gt;&gt; L.angleonlinkold(p1,p2)</span>
<span class="sd">        #(array([59, 62, 65]), array([ 1.27933953,  0.29145679,  0.29145679]))</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;This function is deprecated use&#39;</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
        <span class="n">un</span> <span class="o">=</span> <span class="n">u</span> <span class="o">/</span> <span class="n">nu</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seginframe</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="c1"># new implementation of seginframe is faster</span>
        <span class="c1">#</span>
        <span class="c1">#seglist = self.seginframe2(p1, p2)</span>

        <span class="n">npta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglist</span><span class="p">]</span>
        <span class="n">nphe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">seglist</span><span class="p">]</span>

        <span class="n">Pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">npta</span><span class="p">]</span>
        <span class="n">Phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">nphe</span><span class="p">]</span>

        <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)))</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)))</span>

        <span class="n">bo</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Pta</span><span class="p">,</span> <span class="n">Phe</span><span class="p">)</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="n">seglist</span><span class="p">[</span><span class="n">bo</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Calculate normal angle angle of incidence</span>
        <span class="c1">#</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglist</span><span class="p">]</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">seglist</span><span class="p">]</span>

        <span class="n">vn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">head</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">tail</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">tail</span><span class="p">]))</span>
        <span class="n">mvn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vn</span> <span class="o">*</span> <span class="n">vn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">vn</span> <span class="o">/</span> <span class="n">mvn</span>
        <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)))</span>
        <span class="n">unn</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">uu</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">unn</span><span class="p">)</span>

        <span class="c1"># printvn</span>
        <span class="c1"># printmvn</span>
        <span class="c1"># print&#39;n :&#39;,n</span>
        <span class="c1"># print&#39;un : &#39;,unn</span>
        <span class="c1"># print&#39;theta (deg)&#39;,the*180./pi</span>

        <span class="c1"># seglist = seglist+1</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">seglist</span><span class="p">))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">seglist</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.layeronlink"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.layeronlink">[docs]</a>    <span class="k">def</span> <span class="nf">layeronlink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        layeronlink(self,p1,p2) return seglist between p1 and p2</span>

<span class="sd">        p1 : (1 x 2 )</span>
<span class="sd">        p2 : (1 x 2 )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seginframe</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">npta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">seglist</span><span class="p">]</span>
        <span class="n">nphe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">seglist</span><span class="p">]</span>

        <span class="n">Pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">npta</span><span class="p">]</span>
        <span class="n">Phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">nphe</span><span class="p">]</span>

        <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)))</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seglist</span><span class="p">)))</span>

        <span class="nb">bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Pta</span><span class="p">,</span> <span class="n">Phe</span><span class="p">)</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="n">seglist</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">seglist</span></div>

<div class="viewcode-block" id="Layout.seguv"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seguv">[docs]</a>    <span class="k">def</span> <span class="nf">seguv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iseg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns unitary vector along segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        iseg : np.array</span>
<span class="sd">                index of segments</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;DLR.lay&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx = np.array([1,2,3,17])</span>
<span class="sd">        &gt;&gt;&gt; v1 = L.seguv(idx)</span>
<span class="sd">        &gt;&gt;&gt; idx = np.array([1])</span>
<span class="sd">        &gt;&gt;&gt; v2= L.seguv(idx)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># idx : npt</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">iseg</span><span class="p">]</span>
        <span class="c1"># tahe : 2 x npt</span>
        <span class="n">tahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iseg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">ta</span><span class="p">]</span>
        <span class="n">phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">he</span><span class="p">]</span>
        <span class="c1"># v  : 2 x npt</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">pta</span> <span class="o">-</span> <span class="n">phe</span>
        <span class="c1"># mv : npt</span>
        <span class="n">mv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># vn : 2 x npt</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">mv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vn</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="n">mv</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot; return the seg list of a sequence of point number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptlist</span>

<span class="sd">            array(1xNp) Point number array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        seglist</span>
<span class="sd">            array seglist associated with ptlist</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ptlist  = np.array([0,1])</span>
<span class="sd">        &gt;&gt;&gt; L.segpt(ptlist)</span>
<span class="sd">        array([44, 50, 84, 86])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#seglist = np.array([], dtype=int)</span>
        <span class="n">ut</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">ptlist</span><span class="p">)</span>
        <span class="n">utstack</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">ut</span><span class="p">)</span>
        <span class="c1">#uvstack = reduce(lambda x,y : np.hstack((x,y)),uv)</span>
        <span class="c1"># for i in ptlist:</span>
        <span class="c1">#    ut = np.nonzero(self.tahe[0, :] == i)[0]</span>
        <span class="c1">#    uv = np.nonzero(self.tahe[1, :] == i)[0]</span>
        <span class="c1">#    seglist = np.hstack((seglist, ut, uv))</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">utstack</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.seg2pts"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seg2pts">[docs]</a>    <span class="k">def</span> <span class="nf">seg2pts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aseg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; convert segments array from Gs numerotation </span>
<span class="sd">        to corresponding termination points array in pt</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        aseg : np.array (,Ns) or int for single value:w</span>
<span class="sd">            array of segment number (&gt;0)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pth : np.array (4 x Ns)</span>
<span class="sd">            pth is a vstacking of tail point (2,Ns) and head point (2,Ns)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;defstr.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; aseg = np.array([1,3,6])</span>
<span class="sd">        &gt;&gt;&gt; pt =  L.seg2pts(aseg)</span>

<span class="sd">        OBSOLETE : Use self.s2pc instead</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aseg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">aseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">aseg</span><span class="p">])</span>

        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aseg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">utahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">aseg</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">utahe</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">tahe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span> <span class="n">utahe</span><span class="p">]</span>
            <span class="n">ptail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
            <span class="n">phead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span>
            <span class="n">pth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ptail</span><span class="p">,</span> <span class="n">phead</span><span class="p">))</span>

            <span class="n">pth</span> <span class="o">=</span> <span class="n">pth</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">pth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span></div>



<div class="viewcode-block" id="Layout.segpt"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.segpt">[docs]</a>    <span class="k">def</span> <span class="nf">segpt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])):</span>
        <span class="sd">&quot;&quot;&quot; return the seg list of a sequence of point number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ptlist array(1xNp)</span>
<span class="sd">            point number array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        seglist</span>
<span class="sd">            array seglist associated with ptlist</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ptlist  = np.array([0,1])</span>
<span class="sd">        &gt;&gt;&gt; seg = L.segpt(ptlist)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        segpt is faster than segpt2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ptlist</span><span class="p">:</span>
            <span class="n">ut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">seglist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">seglist</span><span class="p">,</span> <span class="n">ut</span><span class="p">,</span> <span class="n">uv</span><span class="p">))</span>
        <span class="n">seglist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.extrseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.extrseg">[docs]</a>    <span class="k">def</span> <span class="nf">extrseg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate extremum of segments</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        update the following members</span>
<span class="sd">            `min_sx`</span>
<span class="sd">            `max_sx`</span>
<span class="sd">            `min_sy`</span>
<span class="sd">            `max_sy`</span>
<span class="sd">        Used in seginframe</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 2 x Np</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span>
        <span class="c1"># tahe 2 x Nseg</span>
        <span class="n">th</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">th</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">th</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">th</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">th</span><span class="p">))</span></div>

<div class="viewcode-block" id="Layout.seginframe2"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seginframe2">[docs]</a>    <span class="k">def</span> <span class="nf">seginframe2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the seg list of a given zone defined by two points</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">            p1 array (2 x N)</span>
<span class="sd">                array of N 2D points</span>
<span class="sd">            p2 array (2 x N)</span>
<span class="sd">                array of N 2D points </span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>

<span class="sd">            seglist</span>
<span class="sd">                list of segment number inside a planar region defined by p1 an p2</span>


<span class="sd">            Examples</span>
<span class="sd">            --------</span>

<span class="sd">            .. plot::</span>
<span class="sd">                :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">            &gt;&gt;&gt; p1 = np.array([[0,0,0],[0,0,0]])</span>
<span class="sd">            &gt;&gt;&gt; p2 = np.array([[10,10,10],[10,10,10]])</span>
<span class="sd">            &gt;&gt;&gt; seglist = L.seginframe2(p1,p2)</span>
<span class="sd">            &gt;&gt;&gt; edlist  = map(lambda x: L.tsg[x],seglist)</span>
<span class="sd">            &gt;&gt;&gt; fig,ax = L.showG(&#39;s&#39;,edlist=edlist)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sh1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">sh2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">sh1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">sh2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sh2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sh1</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># clipping conditions to keep segment</span>
        <span class="c1">#</span>
        <span class="c1"># max_sx &gt; min_x</span>
        <span class="c1"># min_sx &lt; max_x</span>
        <span class="c1"># max_sy &gt; min_y</span>
        <span class="c1"># min_sy &lt; max_y</span>

        <span class="c1"># N x 1</span>

        <span class="n">max_x</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">min_y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sx</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sx</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sy</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sy</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]))[</span><span class="mi">0</span><span class="p">],</span>
                      <span class="nb">zip</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">))</span>

        <span class="c1"># np.array stacking</span>
        <span class="c1"># -1 acts as a deliminiter (not as a segment number)</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">y</span><span class="p">)),</span> <span class="n">seglist</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.seginframe"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seginframe">[docs]</a>    <span class="k">def</span> <span class="nf">seginframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the seg list of a given zone defined by two points</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">            p1</span>
<span class="sd">                array (1 x 2)</span>
<span class="sd">            p2</span>
<span class="sd">                array (1 x 2)</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>

<span class="sd">            seglist</span>
<span class="sd">                list of segment number inside a planar region defined by p1 an p2</span>


<span class="sd">            Examples</span>
<span class="sd">            --------</span>

<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">            &gt;&gt;&gt; p1 = np.array([0,0])</span>
<span class="sd">            &gt;&gt;&gt; p2 = np.array([10,10])</span>
<span class="sd">            &gt;&gt;&gt; L.seginframe(p1,p2)</span>
<span class="sd">            array([ 1,  3,  7,  8, 14, 15, 16, 17, 18, 20, 21, 23, 24, 26, 27, 29, 30,</span>
<span class="sd">                   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 46, 47, 52, 53, 54,</span>
<span class="sd">                   55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,</span>
<span class="sd">                   72, 73, 74, 75, 76, 77, 78, 81, 82, 85, 86])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">min_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">Dx</span> <span class="o">=</span> <span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span>
        <span class="n">Dy</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span>

        <span class="k">if</span> <span class="n">Dx</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">max_x</span> <span class="o">=</span> <span class="n">max_x</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">min_x</span> <span class="o">=</span> <span class="n">min_x</span> <span class="o">-</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">Dy</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">min_y</span> <span class="o">=</span> <span class="n">min_y</span> <span class="o">-</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Dy</span> <span class="o">&lt;</span> <span class="n">Dx</span><span class="p">):</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">max_x</span><span class="p">)</span> <span class="o">&amp;</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">min_x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">max_y</span><span class="p">)</span> <span class="o">&amp;</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">min_y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">seglist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segpt</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">seglist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.layerongrid"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.layerongrid">[docs]</a>    <span class="k">def</span> <span class="nf">layerongrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">Tx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; grid Nx,Ny,2</span>
<span class="sd">        Tx   1x2</span>
<span class="sd">        .. todo:: layeron grid Not finished</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">seglist</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layeronlink</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Tx</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.cycleinline"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.cycleinline">[docs]</a>    <span class="k">def</span> <span class="nf">cycleinline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the intersection between a given line and all segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        c1 : int</span>
<span class="sd">            point</span>
<span class="sd">        c2 : int</span>
<span class="sd">            point</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        I : numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.antprop.signature.Signatures.rays</span>
<span class="sd">        pylayers.gis.layout.Layout.seginframe2</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function is used to detect LOS conditions</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># polygon cycle 1</span>
        <span class="n">poly1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">p1t</span> <span class="o">=</span> <span class="n">poly1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="c1"># polygon cycle 2</span>
        <span class="n">poly2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">c2</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
        <span class="n">p2t</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span>

        <span class="c1"># centroid of cycle 1 and 2</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p1t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p2t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>

        <span class="c1"># els = self.seginframe(p1,p2)</span>
        <span class="c1"># new implementation of seginframe is faster</span>
        <span class="n">els</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seginframe2</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>

        <span class="n">elg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">[</span><span class="n">els</span><span class="p">]</span>

        <span class="n">lc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">elg</span><span class="p">:</span>
            <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
            <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
            <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>

            <span class="n">segline</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">segline</span><span class="p">):</span>
                <span class="n">lc</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">seg</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span>
            <span class="c1"># printseg,self.Gs.node[seg][&#39;ncycles&#39;]</span>
                <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                <span class="n">psh</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segline</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">psh</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">psh</span><span class="o">.</span><span class="n">y</span><span class="p">]])))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span>
        <span class="n">lss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ls</span><span class="p">)[</span><span class="n">u</span><span class="p">]</span>

        <span class="n">lc</span> <span class="o">=</span> <span class="p">[</span><span class="n">c1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lss</span><span class="p">:</span>
            <span class="n">cy1</span><span class="p">,</span> <span class="n">cy2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cy1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lc</span><span class="p">:</span>
                <span class="n">lc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cy1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cy2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lc</span><span class="p">:</span>
                <span class="n">lc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cy2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Bad transisiton in Layout.cycleinline&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lc</span></div>

<div class="viewcode-block" id="Layout.seginline"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seginline">[docs]</a>    <span class="k">def</span> <span class="nf">seginline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the intersection between a given line and all segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            p1 : numpy.ndarray</span>
<span class="sd">            p2 : numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            I : numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ta</span><span class="p">,</span> <span class="n">he</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ta</span><span class="p">])</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">he</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">pa</span>

            <span class="n">segline</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">((</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">segline</span><span class="p">):</span>
                <span class="n">psh</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">segline</span><span class="p">)</span>
                <span class="n">liseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">psh</span><span class="o">.</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">psh</span><span class="o">.</span><span class="n">y</span><span class="p">]])</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">I</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(([[</span><span class="n">seg</span><span class="p">]],</span> <span class="n">liseg</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">I</span></div>

<div class="viewcode-block" id="Layout.visilist"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.visilist">[docs]</a>    <span class="k">def</span> <span class="nf">visilist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the list of nodes which are visible from point p</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p</span>
<span class="sd">            np.array point</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        AAS = [0:2pi]</span>
<span class="sd">        While (AAS != void set)</span>
<span class="sd">             1) Find segment ns either</span>
<span class="sd">                i)  the closest segment from p in AAS</span>
<span class="sd">                ii) neighbor of prec(ns)</span>
<span class="sd">             2) Find the edgelist visible from ns</span>
<span class="sd">            edgelist = vedgelist(ns)</span>
<span class="sd">             3) Check_occultation(p,ns,edgelist)</span>
<span class="sd">                Occultation 8  situations</span>
<span class="sd">                [p1,pM,p2] = [T,T,T]  : fully occulted</span>
<span class="sd">                         [     ]    partially visible</span>
<span class="sd">                         [F,F,F]  : fully visible</span>
<span class="sd">             4) Update Allowed Angular Sector  (AAS)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AAS</span> <span class="o">=</span> <span class="n">Intvl</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">])</span>
        <span class="n">nsprev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">edgelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">while</span> <span class="n">AAS</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsprev</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">AAS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">nsprev</span><span class="p">)</span>
            <span class="n">edgelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vedgelist</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
            <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">bM</span><span class="p">,</span> <span class="n">b2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span> <span class="o">-</span> <span class="n">occultation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">edgelist</span><span class="p">)</span>
            <span class="n">AAS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">AAS</span><span class="p">,)</span></div>

<div class="viewcode-block" id="Layout.closest_edge"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.closest_edge">[docs]</a>    <span class="k">def</span> <span class="nf">closest_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">AAS</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; not implemented</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        This function return the closest segment from p which belong to</span>
<span class="sd">        the AAS (Allowed Angular Sector)</span>

<span class="sd">        [ns] = closest_edge(self,p,AAS)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
        <span class="c1"># not implemented</span>

<div class="viewcode-block" id="Layout.visi_papb"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.visi_papb">[docs]</a>    <span class="k">def</span> <span class="nf">visi_papb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">edgelist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        visi_papb : determine if pa and pb are in visibility for the structure graph</span>

<span class="sd">        visi_papb(pa,pb,edgelist)</span>

<span class="sd">        pa       : 1x2</span>
<span class="sd">        pb       : 1x2</span>
<span class="sd">        edgelist : exclusion edge list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># .. todo: avoid utilisation tahe</span>
        <span class="c1">#</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">ta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">he</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ta</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ta</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">he</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">he</span><span class="p">]</span>

        <span class="n">den</span> <span class="o">=</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">den</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">den</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-12</span>
        <span class="n">numa</span> <span class="o">=</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">pb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> \
            <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">numb</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">pa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">ua</span> <span class="o">=</span> <span class="n">numa</span> <span class="o">/</span> <span class="n">den</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">numb</span> <span class="o">/</span> <span class="n">den</span>

        <span class="c1">#ua[edgelist] = 1000</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">ua</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ua</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ub</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ub</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Si le segment de droite pa-pb intercepte des paroies de la structure</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="p">[]):</span>
            <span class="n">visi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">visi</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span><span class="p">(</span><span class="n">visi</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.show_nodes"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.show_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">show_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndlist</span><span class="o">=</span><span class="p">[</span><span class="mf">1e8</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">dlabels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; show nodes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ndlist</span>
<span class="sd">        size   : int</span>
<span class="sd">            default 10</span>
<span class="sd">        color :  &#39;b&#39;</span>
<span class="sd">        dlabels : Boolean</span>
<span class="sd">            False</span>
<span class="sd">        font_size : int</span>
<span class="sd">            15</span>
<span class="sd">        alpha : float</span>
<span class="sd">            transparancy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ndlist</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">ndlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ndlist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ndlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># ndlist.append(1e8)</span>
            <span class="n">dlabels</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">ndlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1e8</span><span class="p">:</span>
            <span class="n">ndlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># elif ndlist[0]==1e8:</span>
        <span class="c1">#    ndlist  = self.Gs.node.keys()</span>

        <span class="c1"># printndlist</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                   <span class="n">node_size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">ndlist</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                   <span class="n">node_shape</span><span class="o">=</span><span class="n">node_shape</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">figure</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">axes</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">dlabels</span><span class="p">:</span>
            <span class="n">dicopos</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">dicolab</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ndlist</span><span class="p">:</span>
                <span class="n">dicopos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="n">dicolab</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">dicopos</span><span class="p">,</span> <span class="n">dicolab</span><span class="p">,</span>
                                        <span class="n">font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">figure</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">axes</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Layout.show_seg1"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.show_seg1">[docs]</a>    <span class="k">def</span> <span class="nf">show_seg1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edlist</span><span class="o">=</span><span class="p">[],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">dlabels</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        edlist</span>
<span class="sd">        alpha</span>
<span class="sd">        width</span>
<span class="sd">        size</span>
<span class="sd">        color</span>
<span class="sd">        font_size</span>
<span class="sd">        dlabels</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">edlist</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">:</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="n">edlist</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">edlist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">edlist</span><span class="p">]</span>

        <span class="c1"># printndlist</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">edlist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dlabels</span><span class="p">:</span>
            <span class="n">dicopos</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">dicolab</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ndlist</span><span class="p">:</span>
                <span class="c1"># dicopos[n]=tuple(np.array(self.Gs.pos[n])+np.array((0.8,0.2)))</span>
                <span class="n">dicopos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="n">dicolab</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">dicopos</span><span class="p">,</span> <span class="n">dicolab</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.show_segment"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.show_segment">[docs]</a>    <span class="k">def</span> <span class="nf">show_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        edlist : list</span>
<span class="sd">            segment list</span>
<span class="sd">        alpha : float</span>
<span class="sd">            transparency 0&lt; alpha &lt; 1</span>
<span class="sd">        width : float</span>
<span class="sd">            line width (default 1)</span>
<span class="sd">        color : string</span>
<span class="sd">            default &#39;black&#39;</span>
<span class="sd">        dnodes : boolean</span>
<span class="sd">            display nodes ( Default False)</span>
<span class="sd">        dlabels : boolean</span>
<span class="sd">            display labels ( Default False)</span>
<span class="sd">        font_size : int</span>
<span class="sd">            Default 15</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fig&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;edlist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;dnodes&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;dlabels&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;font_size&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
                    <span class="s1">&#39;node_shape&#39;</span><span class="p">:</span> <span class="s1">&#39;o&#39;</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span>
        <span class="n">clrlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cold</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">coldict</span><span class="p">()</span>

        <span class="c1"># html color or string</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="n">clrlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cold</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;#FFFFF0&#39;</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#00000F&#39;</span>
            <span class="n">clrlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">ecmap</span> <span class="o">=</span> <span class="n">clr</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">clrlist</span><span class="p">)</span>

        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edlist&#39;</span><span class="p">])</span>
        <span class="c1"># ue = (np.ones(2 * len(kwargs[&#39;edlist&#39;]))).astype(&#39;int&#39;).tolist()</span>
        <span class="n">ue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">edgelist</span><span class="o">=</span><span class="n">U</span><span class="p">,</span>
                                       <span class="n">edge_color</span><span class="o">=</span><span class="n">ue</span><span class="p">,</span> <span class="n">edge_cmap</span><span class="o">=</span><span class="n">ecmap</span><span class="p">,</span>
                                       <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">figure</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">axes</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dlabels&#39;</span><span class="p">]:</span>
                <span class="c1"># printedlist</span>
                <span class="c1"># nodelist = self.ed2nd(edlist)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_nodes</span><span class="p">(</span><span class="n">ndlist</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edlist&#39;</span><span class="p">],</span> <span class="n">dlabels</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dlabels&#39;</span><span class="p">],</span>
                                      <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;font_size&#39;</span><span class="p">],</span>
                                      <span class="n">node_shape</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;node_shape&#39;</span><span class="p">],</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dnodes&#39;</span><span class="p">]:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_nodes</span><span class="p">(</span>
                <span class="n">ndlist</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edlist&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Layout.show_layer"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.show_layer">[docs]</a>    <span class="k">def</span> <span class="nf">show_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">edlist</span><span class="o">=</span><span class="p">[],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">dnodes</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dthin</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">dlabels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">fGHz</span><span class="o">=</span><span class="p">[],</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; show layer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        name :</span>
<span class="sd">        edlist : []</span>
<span class="sd">        alpha : float</span>
<span class="sd">            transparency</span>
<span class="sd">        width : int</span>
<span class="sd">            if width = 0 width depends on slab property</span>
<span class="sd">        color : string</span>
<span class="sd">            default black&#39;</span>
<span class="sd">        dnodes :</span>
<span class="sd">            display nodes (False )</span>
<span class="sd">        dthin :</span>
<span class="sd">            display thin ( False )</span>
<span class="sd">        dlabels :</span>
<span class="sd">            display labels ( False )</span>
<span class="sd">        font_size</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edlist</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># intersect layer edge list with local zone edge list (in function</span>
            <span class="c1"># argument)</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edlist</span><span class="p">)</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_segment</span><span class="p">(</span><span class="n">edlist</span><span class="o">=</span><span class="n">edlist</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                        <span class="n">dlabels</span><span class="o">=</span><span class="n">dlabels</span><span class="p">,</span>
                                        <span class="n">font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">linewidth</span> <span class="o">=</span> <span class="n">slab</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linewidth</span> <span class="o">=</span> <span class="n">width</span>
            <span class="k">if</span> <span class="n">fGHz</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">slab</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;METAL&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;METALIC&#39;</span><span class="p">):</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">tocolor</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_segment</span><span class="p">(</span><span class="n">edlist</span><span class="o">=</span><span class="n">edlist</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                        <span class="n">width</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">dnodes</span><span class="o">=</span><span class="n">dnodes</span><span class="p">,</span>
                                        <span class="n">dlabels</span><span class="o">=</span><span class="n">dlabels</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

    <span class="k">def</span> <span class="nf">_showGi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  show graph of interactions Gi</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seed : float</span>
<span class="sd">        alpha : float </span>
<span class="sd">            transparency </span>
<span class="sd">        sig : list of signatures (isequence of Gi nodes format) </span>
<span class="sd">        cycles : list </span>
<span class="sd">            [cystart,cyend] </span>
<span class="sd">        ninter : int</span>
<span class="sd">            interaction index</span>
<span class="sd">        inter : tuple</span>
<span class="sd">            interaction tuple </span>

<span class="sd">        See Also </span>
<span class="sd">        --------</span>

<span class="sd">        Signatures.siginter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;seed&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mf">0.4</span><span class="p">,</span>
                    <span class="s1">&#39;sig&#39;</span><span class="p">:[],</span>
                    <span class="s1">&#39;cycles&#39;</span><span class="p">:[],</span>
                    <span class="s1">&#39;ninter&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                    <span class="s1">&#39;node_size&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span>
                    <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span><span class="mi">18</span><span class="p">,</span>
                    <span class="s1">&#39;labels&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;inter&#39;</span><span class="p">:[]}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> 

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cycles&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cy</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="n">pstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">pstop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="n">lsig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span>
            <span class="n">edgelist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">startlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">stoplist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">phe_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">phe_stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">phe_start</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">phe_stop</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">lsig</span><span class="p">:</span>
                <span class="n">edgelist</span> <span class="o">=</span> <span class="n">edgelist</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="k">if</span> <span class="n">cy</span><span class="o">!=</span><span class="p">[]:</span>
                    <span class="n">p1</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[:,</span><span class="bp">None</span><span class="p">]</span>
                    <span class="n">p2</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">sig</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])[:,</span><span class="bp">None</span><span class="p">]</span>
                    <span class="n">phe_start</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">phe_start</span><span class="p">,</span><span class="n">p1</span><span class="p">))</span>
                    <span class="n">phe_stop</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">phe_stop</span><span class="p">,</span><span class="n">p2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="n">edinter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span>
            <span class="n">outlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">[</span><span class="n">edinter</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edinter</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="n">outprob</span> <span class="o">=</span> <span class="n">outlist</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">edgelist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">edinter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outlist</span><span class="p">]</span> 
            <span class="n">dprob</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outprob</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ninter&#39;</span><span class="p">]</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="n">edinter</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ninter&#39;</span><span class="p">]]</span>
            <span class="n">outlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">[</span><span class="n">edinter</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edinter</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="n">outprob</span> <span class="o">=</span> <span class="n">outlist</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="n">edgelist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">edinter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outlist</span><span class="p">]</span> 
            <span class="n">dprob</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edgelist</span><span class="p">,[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outprob</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>


        <span class="n">ns</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;node_size&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">])</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">edgelist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span><span class="n">width</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">==</span><span class="p">[]):</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">edinter</span><span class="p">],</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">edgelist</span><span class="o">=</span><span class="n">edgelist</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="n">aw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">edgelist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span><span class="n">width</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()],</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fontsize&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">==</span><span class="p">[]):</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">edinter</span><span class="p">],</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">edgelist</span><span class="o">=</span><span class="n">edgelist</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
        <span class="c1">#pdb.set_trace()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span><span class="o">==</span><span class="p">[]):</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span><span class="n">edge_labels</span><span class="o">=</span><span class="n">dprob</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fontsize&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cy</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="n">ptstart</span> <span class="o">=</span> <span class="n">pstart</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">phe_start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="bp">None</span><span class="p">,:]</span>
            <span class="n">ptstop</span> <span class="o">=</span> <span class="n">pstop</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">phe_start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="bp">None</span><span class="p">,:]</span>
            <span class="n">plu</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">ptstart</span><span class="p">,</span><span class="n">phe_start</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">plu</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">phe_stop</span><span class="p">,</span><span class="n">ptstop</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span><span class="n">arrow</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># interactions corresponding to edge en</span>
<span class="c1">#        int0, int1 = self.Gi.edges()[kwargs[&#39;en&#39;]]</span>
<span class="c1">#</span>
<span class="c1">#        print(&quot;int0 : &quot;, int0)</span>
<span class="c1">#        print(&quot;int1 : &quot;, int1)</span>
<span class="c1">#</span>
<span class="c1">#        # if interaction is tuple (R or T)</span>
<span class="c1">#        if ((len(int0) &gt; 1) &amp; (len(int1) &gt; 1)):</span>
<span class="c1">#            nstr0 = int0[0]</span>
<span class="c1">#            nstr1 = int1[0]</span>
<span class="c1">#            e01 = self.Gi.edge[int0][int1]</span>
<span class="c1">#            lseg = []</span>
<span class="c1">#            if e01.has_key(&#39;output&#39;):</span>
<span class="c1">#                output = e01[&#39;output&#39;]</span>
<span class="c1">#                print(&quot; output &quot;, output)</span>
<span class="c1">#                ltup = filter(lambda x: type(x) == tuple, output.keys())</span>
<span class="c1">#                lref = filter(lambda x: len(x) == 2, ltup)</span>
<span class="c1">#                ltran = filter(lambda x: len(x) == 3, ltup)</span>
<span class="c1">#                lseg = np.unique(np.array(map(lambda x: x[0], output.keys())))</span>
<span class="c1">#                probR = np.array(map(lambda x: output[x], lref))</span>
<span class="c1">#                segR = np.array(map(lambda x: x[0], lref))</span>
<span class="c1">#                probT = np.array(map(lambda x: output[x], ltran))</span>
<span class="c1">#                segT = np.array(map(lambda x: x[0], lref))</span>
<span class="c1">#                dprobR = dict(zip(segR, probR))</span>
<span class="c1">#                dprobT = dict(zip(segT, probT))</span>
<span class="c1">#            # print&quot; Sum pR : &quot;,sum(dprobR.values())</span>
<span class="c1">#            # print&quot; Sum pT : &quot;,sum(dprobT.values())</span>
<span class="c1">#            # print&quot;lseg&quot;, lseg</span>
<span class="c1">#            # termination points from seg0 and seg1</span>
<span class="c1">#            pseg0 = self.s2pc[nstr0].toarray().reshape(2, 2).T</span>
<span class="c1">#            pseg1 = self.s2pc[nstr1].toarray().reshape(2, 2).T</span>
<span class="c1">#            #</span>
<span class="c1">#            # create the cone seg0 seg1</span>
<span class="c1">#            #</span>
<span class="c1">#            cn = cone.Cone()</span>
<span class="c1">#            cn.from2segs(pseg0, pseg1)</span>
<span class="c1">#            # show cone</span>
<span class="c1">#            # show Gt</span>
<span class="c1">#            self.display[&#39;thin&#39;] = True</span>
<span class="c1">#            self.display[&#39;subseg&#39;] = False</span>
<span class="c1">#            fig, ax = self.showG(&#39;s&#39;,aw=1,labels=True)</span>
<span class="c1">#            fig, ax = cn.show(fig=fig, ax=ax)</span>
<span class="c1">#            for nse in lseg:</span>
<span class="c1">#                ta, he = self.Gs.neighbors(nse)</span>
<span class="c1">#                pta = np.array(self.Gs.pos[ta])</span>
<span class="c1">#                phe = np.array(self.Gs.pos[he])</span>
<span class="c1">#</span>
<span class="c1">#                try:</span>
<span class="c1">#                    pR = dprobR[nse]</span>
<span class="c1">#                except:</span>
<span class="c1">#                    pR = 0</span>
<span class="c1">#</span>
<span class="c1">#                try:</span>
<span class="c1">#                    pT = dprobT[nse]</span>
<span class="c1">#                except:</span>
<span class="c1">#                    pT = 0</span>
<span class="c1">#</span>
<span class="c1">#                alpha = (pR + pT) / 2.</span>
<span class="c1">#                segment = ax.plot([pta[0], phe[0]],</span>
<span class="c1">#                                  [pta[1], phe[1]],</span>
<span class="c1">#                                  &#39;g&#39;, linewidth=7, visible=True, alpha=alpha)</span>
<span class="c1">#</span>
        <span class="k">return</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_showGt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="p">[],</span> <span class="n">roomlist</span><span class="o">=</span><span class="p">[],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;indoor&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show topological graph Gt</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        ax : matlplotlib axes</span>
<span class="sd">        roomlist : list</span>
<span class="sd">            list of room numbers</span>
<span class="sd">        mode : string </span>
<span class="sd">            &#39;indoor&#39;,&#39;open&#39;,&#39;area&#39;,&#39;start&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">):</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span>

        <span class="c1"># pdb.set_trace()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">nc</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>

                <span class="n">a</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">signedarea</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;area&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;indoor&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;open&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nc</span><span class="p">][</span><span class="s1">&#39;isopen&#39;</span><span class="p">]:</span>
                        <span class="n">poly</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     poly.plot(color=&#39;blue&#39;, alpha=0.5,fig=fig,ax=ax)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Layout.showGs"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.showGs">[docs]</a>    <span class="k">def</span> <span class="nf">showGs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show structure graph Gs</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ndlist  : np.array</span>
<span class="sd">            set of nodes to be displayed</span>
<span class="sd">        edlist  : np.array</span>
<span class="sd">            set of edges to be displayed</span>
<span class="sd">        roomlist : list</span>
<span class="sd">            default : []</span>
<span class="sd">        axis :</span>
<span class="sd">        width : int</span>
<span class="sd">            2</span>
<span class="sd">        fGHz : float</span>
<span class="sd">        show    : boolean</span>
<span class="sd">            default True</span>
<span class="sd">        furniture : boolean</span>
<span class="sd">            default False</span>

<span class="sd">        display parameters are defined in  display dictionnary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ax</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout.showG</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ndlist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;edlist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;roomlist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s1">&#39;fGHz&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;furniture&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;fig&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;ax&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;clear&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="c1"># display overlay image</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay&#39;</span><span class="p">]:</span>
            <span class="c1"># imok : Image is OK</span>
            <span class="n">imok</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;http:&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#img_file = urllib.urlopen(self.display[&#39;overlay_file&#39;])</span>
                <span class="n">img_file</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">])</span>
                <span class="c1">#im = StringIO(img_file.read())</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
                <span class="n">imok</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">pro</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRIMAGE&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]))</span>
                    <span class="n">imok</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">imok</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">FLIP_LEFT_RIGHT</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;h&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">FLIP_TOP_BOTTOM</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span>
                          <span class="s1">&#39;overlay_axis&#39;</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ndlist&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">tn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ndlist</span> <span class="o">=</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edlist&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">tn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="c1">#u  = np.nonzero(tn &gt; 0)[0]</span>
            <span class="c1">#edlist = tn[u]</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tn</span><span class="p">)</span>
            <span class="c1">#&amp; (not self.Gs.node[x].has_key(&#39;ss_name&#39;)),tn)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edlist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edlist&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]:</span>
            <span class="n">dlabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ndlabel&#39;</span><span class="p">]</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_nodes</span><span class="p">(</span>
                <span class="n">ndlist</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">dlabels</span><span class="o">=</span><span class="n">dlabels</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;isonb&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;lsss&#39;</span><span class="p">):</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># psseg = np.array([[self.Gs.pos[x][0],self.Gs.pos[x][1]] for x in seg])</span>
                <span class="c1"># nbsseg = np.array([len(self.Gs.node[x][&#39;iso&#39;]) for x in seg],dtype=&#39;int&#39;)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">psseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seg</span> 
                                   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">])</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span>  
                <span class="k">except</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">ipdb</span>
                    <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

        <span class="c1">#         [ax.text(psseg[x,0]+0.2,psseg[x,1]+0.2,str(nbsseg[x]),</span>
        <span class="c1"># fontdict={&#39;size&#39;:8},ha=&#39;center&#39;) for x in range(len(seg))]</span>
                <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">psseg</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.2</span><span class="p">,</span><span class="n">psseg</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.2</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
                <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span><span class="mi">8</span><span class="p">},</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psseg</span><span class="p">))]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">segwtrans</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span>
                    <span class="n">y</span><span class="p">][</span><span class="s1">&#39;transition&#39;</span><span class="p">]]</span>
                <span class="n">posseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segwtrans</span><span class="p">])</span>
                <span class="n">normseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segwtrans</span><span class="p">])[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">posseg</span> <span class="o">-</span> <span class="n">normseg</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">posseg</span> <span class="o">+</span> <span class="n">normseg</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">b1</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                             <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                             <span class="n">xytext</span><span class="o">=</span><span class="n">b2</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                             <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                             <span class="n">arrowprops</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;arrowstyle&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;-&gt;&#39;</span><span class="p">})</span>
                 <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segwtrans</span><span class="p">))]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">slablist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]:</span>
            <span class="n">dlabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;edlabel&#39;</span><span class="p">]</span>
            <span class="n">font_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;fontsize&#39;</span><span class="p">]</span>
            <span class="n">dnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ednodes&#39;</span><span class="p">]</span>
            <span class="n">dthin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;thin&#39;</span><span class="p">]</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">nameslab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">nameslab</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
                <span class="n">edlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">nameslab</span><span class="p">]</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_layer</span><span class="p">(</span><span class="n">nameslab</span><span class="p">,</span> <span class="n">edlist</span><span class="o">=</span><span class="n">edlist</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                          <span class="n">dthin</span><span class="o">=</span><span class="n">dthin</span><span class="p">,</span> <span class="n">dnodes</span><span class="o">=</span><span class="n">dnodes</span><span class="p">,</span> <span class="n">dlabels</span><span class="o">=</span><span class="n">dlabels</span><span class="p">,</span>
                                          <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                          <span class="n">font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span>
                                          <span class="n">width</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">],</span>
                                          <span class="n">fGHz</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fGHz&#39;</span><span class="p">],</span>
                                          <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;subseg&#39;</span><span class="p">]:</span>
            <span class="n">dico</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseg</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dico</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fGHz&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;METAL&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;METALIC&#39;</span><span class="p">):</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tocolor</span><span class="p">(</span><span class="n">fGHz</span><span class="p">)</span>
                        <span class="c1">#color = &#39;red&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span>
                        <span class="c1"># printk,color</span>
                <span class="n">edlist2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">dico</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">edlist2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># edlist2.append(ts)</span>
                <span class="n">edlist3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edlist2</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edlist</span><span class="p">)))</span>
                <span class="c1"># printk , color , edlist</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_segment</span><span class="p">(</span>
                    <span class="n">edlist</span><span class="o">=</span><span class="n">edlist3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;scaled&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">])</span>
        <span class="c1">#fig = plt.gcf()</span>
        <span class="c1">#ax  = fig.axes[0]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ticksoff&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">spine</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;furniture&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s1">&#39;lfur&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fur1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lfur</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fur1</span><span class="o">.</span><span class="n">Matname</span> <span class="o">==</span> <span class="s1">&#39;METAL&#39;</span><span class="p">:</span>
                        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">fur1</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Warning : no furniture file loaded&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;roomlist&#39;</span><span class="p">]:</span>
            <span class="n">ncy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Layout.build"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="s1">&#39;tvirw&#39;</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">difftol</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span><span class="n">multi</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; build graphs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        graph : string composed of</span>
<span class="sd">            &#39;t&#39; : Gt</span>
<span class="sd">            &#39;v&#39; : Gv</span>
<span class="sd">            &#39;i&#39; : Gi</span>
<span class="sd">            &#39;r&#39; : Gr</span>
<span class="sd">            &#39;w&quot; : Gw</span>
<span class="sd">        verbose : boolean</span>
<span class="sd">        difftol : diffraction tolerance</span>
<span class="sd">        multi : boolean </span>
<span class="sd">            enable multi processing</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This function build all the graph associated with the Layout. </span>

<span class="sd">        Warning : by default the layout is saved (dumpw) after each build</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># list of built graphs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasboundary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">()</span>

        <span class="c1"># to save graoh Gs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>

        <span class="n">Buildpbar</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Build Layout&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Buildpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildGt</span><span class="p">(</span><span class="n">difftol</span><span class="o">=</span><span class="n">difftol</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Buildpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildGv</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Buildpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;i&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buildGi</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multi</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outputGi</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outputGi_mp</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Buildpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># if &#39;r&#39; in graph:</span>
        <span class="c1">#     if verbose:</span>
        <span class="c1">#         print&quot;Gr&quot;</span>
        <span class="c1">#     self.buildGr()</span>
        <span class="c1">#     self.lbltg.extend(&#39;r&#39;)</span>

        <span class="c1"># if &#39;w&#39; in graph and len(self.Gr.nodes())&gt;1:</span>
        <span class="c1">#     self.buildGw()</span>
        <span class="c1">#     self.lbltg.extend(&#39;w&#39;)</span>

        <span class="c1"># add hash to node 0 of Gs</span>

        <span class="n">filelay</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRLAY&#39;</span><span class="p">])</span>
        <span class="n">_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filelay</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="n">_hash</span><span class="p">)</span>

        <span class="c1"># There is a dumpw after each build</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dumpw</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isbuilt</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Buildpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.dumpw"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.dumpw">[docs]</a>    <span class="k">def</span> <span class="nf">dumpw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; write a dump of given Graph</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        &#39;t&#39; : Gt</span>
<span class="sd">        &#39;r&#39; : Gr</span>
<span class="sd">        &#39;s&#39; : Gs</span>
<span class="sd">        &#39;v&#39; : Gv</span>
<span class="sd">        &#39;i&#39; : Gi</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create layout directory</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.ini&#39;</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.ini&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.lay&#39;</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.lay&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="s1">&#39;struc&#39;</span><span class="p">,</span> <span class="s1">&#39;gpickle&#39;</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if g in [&#39;v&#39;,&#39;i&#39;]:</span>
                <span class="c1">#     gname1 =&#39;G&#39;+g</span>
                <span class="c1">#     write_gpickle(getattr(self,gname1),os.path.join(basename,&#39;struc&#39;,&#39;gpickle&#39;,&#39;G&#39;+g+&#39;_&#39;+self._filename+&#39;.gpickle&#39;))</span>
                <span class="c1"># else:</span>
                <span class="n">gname</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">g</span>
                <span class="n">write_gpickle</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gname</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">path</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="s1">&#39;.gpickle&#39;</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="s1">&#39; graph cannot be saved, probably because it has not been built&#39;</span><span class="p">)</span>
        <span class="c1"># save dictionnary which maps string interaction to [interaction node,</span>
        <span class="c1"># interaction type]</span>
        <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;ddiff&#39;</span><span class="p">):</span>
                <span class="n">write_gpickle</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ddiff&#39;</span><span class="p">),</span>
                          <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;ddiff.gpickle&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;lnss&#39;</span><span class="p">):</span>
                <span class="n">write_gpickle</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lnss&#39;</span><span class="p">),</span>
                          <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;lnss.gpickle&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;dca&#39;</span><span class="p">):</span>
            <span class="n">write_gpickle</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dca&#39;</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;dca.gpickle&#39;</span><span class="p">))</span>
        <span class="c1"># write_gpickle(getattr(self,&#39;sla&#39;),os.path.join(path,&#39;sla.gpickle&#39;))</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">):</span>
            <span class="n">write_gpickle</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;m.gpickle&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Layout.dumpr"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.dumpr">[docs]</a>    <span class="k">def</span> <span class="nf">dumpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graphs</span><span class="o">=</span><span class="s1">&#39;stvirw&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; read of given graphs</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        graph : string</span>
<span class="sd">            &#39;s&#39; : Gv</span>
<span class="sd">            &#39;t&#39; : Gt</span>
<span class="sd">            &#39;r&#39; : Gr</span>
<span class="sd">            &#39;v&#39; : Gv</span>
<span class="sd">            &#39;i&#39; : Gi</span>


<span class="sd">        .gpickle files are store under the struc directory of the project</span>
<span class="sd">        specified by the $BASENAME environment variable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.ini&#39;</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.ini&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;.lay&#39;</span><span class="p">:</span>
            <span class="n">dirname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.lay&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pro</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="s1">&#39;struc&#39;</span><span class="p">,</span> <span class="s1">&#39;gpickle&#39;</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># if g in [&#39;v&#39;,&#39;i&#39;]:</span>
                <span class="c1">#     gname1 =&#39;G&#39;+g</span>
                <span class="c1">#     setattr(self, gname1, read_gpickle(os.path.join(pro.basename,&#39;struc&#39;,&#39;gpickle&#39;,&#39;G&#39;+g+&#39;_&#39;+self._filename+&#39;.gpickle&#39;)))</span>
                <span class="c1"># else:</span>
                <span class="n">gname</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">g</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="s1">&#39;.gpickle&#39;</span><span class="p">)</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">read_gpickle</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gname</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lbltg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Warning Unable to read graph G&quot;</span><span class="o">+</span><span class="n">g</span><span class="p">)</span>
                <span class="k">pass</span>

        <span class="c1"># retrieve md5 sum of the original ini file</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">graphs</span><span class="p">:</span>
            <span class="c1">#self._hash = self.Gs.node.pop(0)[&#39;hash&#39;]</span>
            <span class="c1"># self._hash = self.Gs.node[0][&#39;hash&#39;]</span>
            <span class="c1"># update self.name</span>
            <span class="n">lseg</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lseg</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span>

        
            <span class="n">filediff</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;ddiff.gpickle&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filediff</span><span class="p">):</span>
                <span class="n">ddiff</span> <span class="o">=</span> <span class="n">read_gpickle</span><span class="p">(</span><span class="n">filediff</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ddiff&#39;</span><span class="p">,</span> <span class="n">ddiff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">=</span><span class="p">{}</span>

            <span class="n">filelnss</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;lnss.gpickle&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filelnss</span><span class="p">):</span>
                <span class="n">lnss</span> <span class="o">=</span> <span class="n">read_gpickle</span><span class="p">(</span><span class="n">filelnss</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lnss&#39;</span><span class="p">,</span> <span class="n">lnss</span><span class="p">)</span> 
            <span class="k">else</span> <span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">lnss</span><span class="o">=</span><span class="p">[]</span>

        <span class="n">filedca</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;dca.gpickle&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filedca</span><span class="p">):</span>
            <span class="n">dca</span> <span class="o">=</span> <span class="n">read_gpickle</span><span class="p">(</span><span class="n">filedca</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dca&#39;</span><span class="p">,</span><span class="n">dca</span><span class="p">)</span> 

        <span class="n">filem</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;m.gpickle&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filem</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">read_gpickle</span><span class="p">(</span><span class="n">filem</span><span class="p">))</span></div>

<div class="viewcode-block" id="Layout.polysh2geu"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.polysh2geu">[docs]</a>    <span class="k">def</span> <span class="nf">polysh2geu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; transform sh.Polygon into geu.Polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="n">Gsnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
            <span class="c1"># get node coordinates</span>
            <span class="n">nodept</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Gsnodes</span><span class="p">]</span>
            <span class="c1"># transform into shapely points</span>
            <span class="n">shpt</span> <span class="o">=</span> <span class="p">[</span><span class="n">sh</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">nodept</span><span class="p">]</span>
            <span class="c1"># IV 1 get nodes and vnodes</span>
            <span class="c1"># Create a ring to avoid taking points inside the polygon.</span>
            <span class="c1"># This helps to avoid polygon inside polygons</span>
            <span class="c1"># take exterior of polygon. embose it with buffer and find difference with original polygon*.</span>
            <span class="c1"># polye = poly.intersection((poly.exterior).buffer(1e-3))</span>

            <span class="n">uvn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">shpt</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">vnodes</span> <span class="o">=</span> <span class="n">Gsnodes</span><span class="p">[</span><span class="n">uvn</span><span class="p">]</span>
            <span class="c1"># IV 1.b transform vnodes to an ordered cycle with Cycle class</span>
            <span class="c1"># NOTE ! Using class cycle is MANDATORY</span>
            <span class="c1"># because, some extra vnodes can be pickup during the contain</span>
            <span class="c1"># process before</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">vnodes</span><span class="p">)</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycle</span><span class="p">])</span>
                <span class="n">dif</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lc</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vnodes</span><span class="p">))</span>
                <span class="n">ud</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">dif</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">ud</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycle</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># IV 1.c create a new polygon with correct vnodes and correct</span>
            <span class="c1"># points</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">vnodes</span><span class="o">=</span><span class="n">cycle</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">ipdb</span>
            <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="Layout.getangles"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.getangles">[docs]</a>    <span class="k">def</span> <span class="nf">getangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">inside</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; find angles of a polygon</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        poly : geu.Polygon or sh.Polygon</span>
<span class="sd">        unit : str</span>
<span class="sd">            &#39;deg&#39; : degree values</span>
<span class="sd">            &#39;rad&#39; : radian values</span>
<span class="sd">        inside : boolean</span>
<span class="sd">            True :  compute the inside angles of the cycle.</span>
<span class="sd">                    (a.k.a. the interior of the polygon) </span>
<span class="sd">            False : compute the outside angles of the cycle.</span>
<span class="sd">                    (a.k.a. the exterior of the polygon)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        (u,a)</span>
<span class="sd">        u : int (Np)</span>
<span class="sd">            point number</span>
<span class="sd">        a : float (Np)</span>
<span class="sd">            associated angle to the point</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        http://www.mathopenref.com/polygonexteriorangles.html</span>

<span class="sd">        TODO : This function should be moved in geomutil.py  (NOT USED) </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">polysh2geu</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

        <span class="n">cycle</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">vnodes</span>

        <span class="n">upt</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">cycle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># rupt=np.roll(upt,1)         # for debug</span>
        <span class="c1"># rupt2=np.roll(upt,-1)         # for debug</span>
        <span class="c1">#</span>
        <span class="c1"># See OSM bug fix</span>
        <span class="c1">#</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iupnt</span><span class="p">[</span><span class="o">-</span><span class="n">upt</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">geu</span><span class="o">.</span><span class="n">SignedArea</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">upt</span> <span class="o">=</span> <span class="n">upt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ptroll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">pt</span> <span class="o">-</span> <span class="n">ptroll</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="bp">None</span><span class="p">]))</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">v</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">vn</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">vn</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v1</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span> <span class="o">*</span> <span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cross</span><span class="p">,</span> <span class="n">dot</span><span class="p">)</span>
        <span class="n">uneg</span> <span class="o">=</span> <span class="n">ang</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">ang</span><span class="p">[</span><span class="n">uneg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ang</span><span class="p">[</span><span class="n">uneg</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">ang</span><span class="p">[</span><span class="o">~</span><span class="n">uneg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">ang</span><span class="p">[</span><span class="o">~</span><span class="n">uneg</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inside</span><span class="p">:</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">ang</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">upt</span><span class="p">,</span> <span class="n">ang</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;rad&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">upt</span><span class="p">,</span> <span class="n">ang</span></div>
            <span class="c1"># atan2(cross(a,b)), dot(a,b))</span>

<div class="viewcode-block" id="Layout.pltlines"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.pltlines">[docs]</a>    <span class="k">def</span> <span class="nf">pltlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot a line with a specified color and transparency</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        lines : shapely lines</span>
<span class="sd">        fig</span>
<span class="sd">        ax </span>
<span class="sd">        color  : string </span>
<span class="sd">        alpha  : float </span>
<span class="sd">            transparency</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout.Layout.plot</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">xy</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">])</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.pltpoly"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.pltpoly">[docs]</a>    <span class="k">def</span> <span class="nf">pltpoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot a polygon with a specified color and transparency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mpl</span> <span class="o">=</span> <span class="p">[</span><span class="n">PolygonPatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">mpl</span> <span class="o">=</span> <span class="p">[</span><span class="n">PolygonPatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">poly</span><span class="p">]]</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mpl</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.pltvnodes"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.pltvnodes">[docs]</a>    <span class="k">def</span> <span class="nf">pltvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[],):</span>
        <span class="sd">&quot;&quot;&quot; plot vnodes </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        vn : list of nodes</span>
<span class="sd">        fig : </span>
<span class="sd">        ax : </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vn</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;or&#39;</span><span class="p">)</span>
            <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vn</span><span class="p">[</span><span class="n">xx</span><span class="p">])</span> <span class="k">for</span> <span class="n">xx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Layout.updateshseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.updateshseg">[docs]</a>    <span class="k">def</span> <span class="nf">updateshseg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; update shapely segment</span>

<span class="sd">        build a shapely object for all segments</span>

<span class="sd">        This function is called at the beginning of buildGt.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        buildGt</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">seg_connect</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;connect&#39;</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">dpts</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seg_connect</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dpts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

    <span class="k">def</span> <span class="nf">_triangle_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly_surround</span><span class="p">,</span> <span class="n">poly_holes</span><span class="o">=</span><span class="p">[],</span> <span class="n">mesh_holes</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        perfome a delaunay partitioning on shapely polygons</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            poly_surround : sh.Polygon </span>
<span class="sd">                A single polygon to be partitionned</span>
<span class="sd">            poly_holes : list of sh.Polygon</span>
<span class="sd">                A list of polygon contained inside poly_surround. they are considered as holes</span>
<span class="sd">            mesh_holes : bool</span>
<span class="sd">                If True make the delaunay partition of poly_holes</span>
<span class="sd">                else : only partitioning poly_surround  and traits poly_holes as holes</span>


<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">            T : dict </span>
<span class="sd">                dictionnary from triangle.triangulate library</span>
<span class="sd">                &gt;&gt;&gt; T.keys()</span>
<span class="sd">                [&#39;segment_markers&#39;, &#39;segments&#39;, &#39;holes&#39;, &#39;vertices&#39;, &#39;vertex_markers&#39;, &#39;triangles&#39;]</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        uses triangle library</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly_surround</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">poly_surround</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly_surround</span><span class="p">]</span>

        <span class="n">lP</span> <span class="o">=</span> <span class="n">poly_surround</span> <span class="o">+</span> <span class="n">poly_holes</span>

        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">segcpt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lP</span><span class="p">:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">)[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">vertices</span><span class="p">,</span> <span class="n">pts</span><span class="p">))</span>
            <span class="n">nbv</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">segments</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbv</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nbv</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">segcpt</span><span class="p">))</span>
            <span class="n">segcpt</span> <span class="o">=</span> <span class="n">segcpt</span> <span class="o">+</span> <span class="n">nbv</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh_holes</span><span class="p">:</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">holes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh_holes</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span> <span class="n">segments</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;holes&#39;</span><span class="p">:</span> <span class="n">holes</span><span class="o">.</span><span class="n">T</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span> <span class="n">segments</span><span class="o">.</span><span class="n">T</span><span class="p">}</span>
        <span class="kn">import</span> <span class="nn">ipdb</span>
        <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;pa&#39;</span><span class="p">)</span>

        <span class="c1"># import triangle.plot as plot</span>
        <span class="c1"># ax=plt.gca()</span>
        <span class="c1"># plot.plot(ax,**T)</span>

        <span class="k">return</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">_merge_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; merge triangle (polygon object) to cvx polygon</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            lP : list</span>
<span class="sd">                list of polygon to be merged</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>

<span class="sd">            lMP : list</span>
<span class="sd">                list of merged polygons</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lMP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># MERGE POLYGONS</span>
        <span class="c1"># move from delaunay triangles to convex polygons</span>
        <span class="k">while</span> <span class="n">lP</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">lP</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># restrict research to polygon that are touching themself</span>
            <span class="n">restp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ix</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lP</span><span class="p">)</span>
                     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">)]</span>
            <span class="c1"># self.pltpoly(p,ax=plt.gca())</span>

            <span class="n">conv</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">pold</span> <span class="o">=</span> <span class="n">p</span>
            <span class="c1"># for ip2,p2 in restp:</span>
            <span class="k">for</span> <span class="n">ip2</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">restp</span><span class="p">:</span>
                <span class="c1"># inter = p.intersection(p2)</span>
                <span class="c1"># if 2 triangles have a common segment</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">p2</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">isconvex</span><span class="p">():</span>
                    <span class="n">lP</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ip2</span><span class="p">)</span>
                    <span class="n">lP</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="n">conv</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if pold not in cpolys:</span>
                    <span class="c1">#     cpolys.append(pold)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pold</span>
            <span class="c1"># if (ip2 &gt;= len(polys)):# and (conv):</span>
            <span class="c1"># if conv :</span>
            <span class="c1">#     if p not in cpolys:</span>
            <span class="c1">#         cpolys.append(p)</span>
            <span class="k">if</span> <span class="n">restp</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">conv</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">lMP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">conv</span><span class="p">:</span>  <span class="c1"># else:</span>
                <span class="k">if</span> <span class="n">pold</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lMP</span><span class="p">:</span>
                    <span class="n">lMP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pold</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lMP</span><span class="p">:</span>
                    <span class="n">lMP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lMP</span>

    <span class="k">def</span> <span class="nf">_triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="p">[],</span> <span class="n">vnodes</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        perfom a Delaunay partitioning on shapely polygons</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            holes : ndarray</span>
<span class="sd">                if holes ==[] : it means the merge is applied on the interior of the layout (indoor)</span>
<span class="sd">                if holes == np.ndarray (centroid of polygon). indoor is discarded and delaunay</span>
<span class="sd">                        is applied on outdoor</span>


<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">            T : dict </span>
<span class="sd">                dictionnary from triangle.triangulate library</span>
<span class="sd">                &gt;&gt;&gt; T.keys()</span>
<span class="sd">                [&#39;segment_markers&#39;, &#39;segments&#39;, &#39;holes&#39;, &#39;vertices&#39;, &#39;vertex_markers&#39;, &#39;triangles&#39;]</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This methoc uses the triangle library</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this means Delaunay is applied on exterior</span>
        <span class="c1"># and inside polygon will be discarded</span>
        <span class="n">segbounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ptbounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">holes</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="c1"># remove air segments around layout</span>
            <span class="k">pass</span>
            <span class="c1"># [segbounds.extend(nx.neighbors(L.Gs,x)) for x in L.lboundary]</span>
            <span class="c1"># ptbounds = L.lboundary</span>

        <span class="k">if</span> <span class="n">vnodes</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="c1"># find segments of layout</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vnodes</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="ow">and</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">segbounds</span><span class="p">])</span>
        <span class="c1"># get vertices/points of layout</span>
        <span class="n">ivertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vnodes</span>
                              <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>
                              <span class="ow">and</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ptbounds</span><span class="p">])</span>
        <span class="n">map_vertices</span> <span class="o">=</span> <span class="n">ivertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">ivertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">sorter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">map_vertices</span><span class="p">)</span>

        <span class="c1"># mapping between Gs graph segments and triangle segments</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">sorter</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_vertices</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">holes</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span> <span class="n">segments</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vertices&#39;</span><span class="p">:</span> <span class="n">vertices</span><span class="p">,</span> <span class="s1">&#39;segments&#39;</span><span class="p">:</span> <span class="n">segments</span><span class="p">,</span> <span class="s1">&#39;holes&#39;</span><span class="p">:</span> <span class="n">holes</span><span class="p">}</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;pa&#39;</span><span class="p">)</span>

        <span class="c1"># import triangle.plot as plot</span>
        <span class="c1"># ax=plt.gca()</span>
        <span class="c1"># plot.plot(ax,**T)</span>
        <span class="c1"># plt.show()</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">map_vertices</span>

<div class="viewcode-block" id="Layout.buildGt"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.buildGt">[docs]</a>    <span class="k">def</span> <span class="nf">buildGt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">difftol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; build graph of convex cycle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        check : boolean </span>
<span class="sd">        difftol : float </span>
<span class="sd">        verbose : boolean </span>
<span class="sd">        tqdmpos : progressbar </span>

<span class="sd">        todo :</span>
<span class="sd">        - add an option to only take outside polygon </span>
<span class="sd">            =&gt; pass to self._triangle a hole coreesponding to centroid of</span>
<span class="sd">            polygon except those of boundary ( see buildGtold )</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1. Do a Delaunay triangulation</span>
        <span class="c1"># build a list of triangle polygons : lTP</span>
        <span class="c1"># vnodes refers to the nodes of Gs</span>
        <span class="c1"># if vnodes == 0 it means this is a created</span>
        <span class="c1"># segment which is tagged as _AIR</span>
        <span class="c1">###</span>

        <span class="c1"># if verbose :</span>
        <span class="c1">#     Gtpbar = tqdm.tqdm(total=100., desc=&#39;BuildGt&#39;,position=0)</span>
        <span class="c1">#     pbar_awloop =  tqdm.tqdm(total=100., desc =&#39;airwalls loop&#39;,leave=False,position=1)</span>

        <span class="n">Gtpbar</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;BuildGt&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="p">)</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Triangulation&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">T</span><span class="p">,</span> <span class="n">map_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_triangle</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>
        <span class="c1"># point index are integer</span>
        <span class="n">map_vertices</span> <span class="o">=</span> <span class="n">map_vertices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ptri</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">][</span><span class="n">T</span><span class="p">[</span><span class="s1">&#39;triangles&#39;</span><span class="p">]]</span>

        <span class="c1"># List of Triangle Polygons</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> 
                        <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Transfer polygons list&#39;</span><span class="p">,</span>
                        <span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">lTP</span> <span class="o">=</span> <span class="p">[</span><span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ptri</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>

        <span class="c1"># update vnodes of Polygons</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> 
                        <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Update Polygons vnodes&#39;</span><span class="p">,</span>
                        <span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># p is a polygon </span>
        <span class="c1"># get_points(p) : get points from polygon</span>
        <span class="c1"># this is for limiting the search region for large Layout </span>
        <span class="c1">#</span>
        <span class="p">[</span> <span class="n">p</span><span class="o">.</span><span class="n">setvnodes_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lTP</span> <span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>


        <span class="c1"># 2.add air walls to triangle poly</span>
        <span class="c1">###</span>
        <span class="c1"># luaw  : list of tuples</span>
        <span class="c1"># ( polygon , array of _AIR segments)</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> 
                        <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Buiild list of airwalls&#39;</span><span class="p">,</span>
                        <span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">luaw</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lTP</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>



        <span class="c1">#</span>
        <span class="c1"># For a triangle polygon the number of vnodes</span>
        <span class="c1"># creates new _AIR segments</span>
        <span class="c1">#</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">luaw</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_airseg</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Add airwalls&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">uaw</span> <span class="ow">in</span> <span class="n">luaw</span><span class="p">:</span>
            <span class="c1"># for each vnodes == 0, add an _AIR</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
                <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">*</span><span class="n">cpt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">aw</span> <span class="ow">in</span> <span class="n">uaw</span><span class="p">:</span>
                <span class="n">modpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
                <span class="n">_airseg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">aw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">modpt</span><span class="p">)],</span>
                                                <span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">aw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">modpt</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">,</span>
                                                <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40000000</span><span class="p">),</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
            <span class="c1"># update polygon segments with new added airwalls</span>
            <span class="n">p</span><span class="o">.</span><span class="n">setvnodes_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>


        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Update Graph&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>


        <span class="n">tri</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="s1">&#39;triangles&#39;</span><span class="p">]</span>
        <span class="n">nbtri</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="s1">&#39;triangles&#39;</span><span class="p">])</span>
        <span class="c1"># temporary name/node_index of triangles</span>
        <span class="n">MT</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbtri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 3. Create a temporary graph</span>
        <span class="c1"># where : positive nodes (&gt;0) are triangles segments</span>
        <span class="c1"># negative nodes (&lt;0) are triangles centroids</span>
        <span class="c1"># edges link triangle centroids to their respective segments</span>

        <span class="c1"># Ex represent list of points in Gs corresponging to segments</span>
        <span class="c1">#[pt_head pt_tail]</span>

        <span class="n">E0</span> <span class="o">=</span> <span class="n">map_vertices</span><span class="p">[</span><span class="n">tri</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]]</span>
        <span class="n">E1</span> <span class="o">=</span> <span class="n">map_vertices</span><span class="p">[</span><span class="n">tri</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">E2</span> <span class="o">=</span> <span class="n">map_vertices</span><span class="p">[</span><span class="n">tri</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1"># from [pt_tail pt_head] get segment id in Gs</span>

        <span class="n">n0</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numseg</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E0</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numseg</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E1</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numseg</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E2</span><span class="p">]</span>

        <span class="c1"># creation of a temporary graph</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">MT</span><span class="p">))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">MT</span><span class="p">))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">MT</span><span class="p">))</span>

        <span class="c1"># 4. search in the temporary graph</span>
        <span class="c1">###</span>
        <span class="c1"># nodes of degree 2  :</span>
        <span class="c1"># - they correspond to Gs segments that link to triangle centroid</span>
        <span class="c1"># - their neighbors are the triangles centroids</span>

        <span class="c1"># find nodes of degree 2 (corresponding to segments linked to a</span>
        <span class="c1"># triangle centroid)</span>
        <span class="n">rn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rn</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">un</span> <span class="k">for</span> <span class="n">un</span> <span class="ow">in</span> <span class="n">n0</span> <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">un</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">rn</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">un</span> <span class="k">for</span> <span class="n">un</span> <span class="ow">in</span> <span class="n">n1</span> <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">un</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">rn</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">un</span> <span class="k">for</span> <span class="n">un</span> <span class="ow">in</span> <span class="n">n2</span> <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">un</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">rn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">rn</span><span class="p">)</span>

        <span class="c1"># determine the neighbors of those segments (the 2 connected triangles</span>
        <span class="c1"># centroids)</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">un</span><span class="p">)</span> <span class="k">for</span> <span class="n">un</span> <span class="ow">in</span> <span class="n">rn</span><span class="p">]</span>

        <span class="c1"># store into networkx compliant format</span>

        <span class="n">uE</span> <span class="o">=</span> <span class="p">[(</span><span class="n">neigh</span><span class="p">[</span><span class="n">un</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">neigh</span><span class="p">[</span><span class="n">un</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;segment&#39;</span><span class="p">:</span> <span class="p">[</span>
               <span class="n">rn</span><span class="p">[</span><span class="n">un</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">rn</span><span class="p">[</span><span class="n">un</span><span class="p">]][</span><span class="s1">&#39;iso&#39;</span><span class="p">]})</span> <span class="k">for</span> <span class="n">un</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rn</span><span class="p">))]</span>
        <span class="n">iuE</span> <span class="o">=</span> <span class="p">{</span><span class="n">rn</span><span class="p">[</span><span class="n">un</span><span class="p">]:</span> <span class="p">[</span><span class="o">-</span><span class="n">neigh</span><span class="p">[</span><span class="n">un</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">neigh</span><span class="p">[</span><span class="n">un</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
               <span class="k">for</span> <span class="n">un</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rn</span><span class="p">))}</span>

        <span class="c1"># delete temporary graph</span>
        <span class="k">del</span> <span class="n">G</span>

        <span class="c1"># pdb.set_trace()</span>

        <span class="c1"># create graph Gt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">uE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># add polyg  to nodes</span>
        <span class="c1"># add indoor to nodes</span>
        <span class="c1"># add isopen to nodes</span>

        <span class="n">nno</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;polyg&#39;</span><span class="p">:</span> <span class="n">lTP</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;indoor&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span> <span class="s1">&#39;isopen&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">})</span>
               <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nno</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()})</span>

        <span class="c1"># self.Gtpos = {-MT[i]:pMT[i] for i in xrange(len(MT))}</span>
        <span class="c1"># plt.figure()</span>
        <span class="c1"># # G=nx.Graph()</span>
        <span class="c1"># # G.add_edges_from(E0)</span>
        <span class="c1"># # G.add_edges_from(E1)</span>
        <span class="c1"># # G.add_edges_from(E2)</span>

        <span class="n">_airseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_airseg</span><span class="p">)</span>
        <span class="n">_airseg</span> <span class="o">=</span> <span class="n">_airseg</span><span class="p">[</span><span class="n">_airseg</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Mikado like progression for simplification of a set of convex polygons</span>
        <span class="c1">#</span>
        <span class="c1">#    Loop over AIR segments</span>
        <span class="c1">#</span>
        <span class="n">mapoldcy</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>

        <span class="c1"># self.showG(&#39;st&#39;,aw=1)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>



        <span class="n">Nairseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_airseg</span><span class="p">)</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nairseg</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Mikado&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_airseg</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">*</span><span class="n">cpt</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1"># n0,n1 : cycle number</span>
            <span class="c1">#</span>
            <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">iuE</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">nn0</span> <span class="o">=</span> <span class="n">mapoldcy</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">n0</span> <span class="o">==</span> <span class="n">nn0</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n0</span> <span class="o">=</span> <span class="n">nn0</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">nn1</span> <span class="o">=</span> <span class="n">mapoldcy</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">nn1</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="n">nn1</span>

            <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n0</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>

            <span class="c1"># Merge polygon</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">p1</span>
            <span class="c1"># If the new Polygon is convex update Gt</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">geu</span><span class="o">.</span><span class="n">isconvex</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
                <span class="c1"># updates vnodes of the new merged polygon</span>
                <span class="n">P</span><span class="o">.</span><span class="n">setvnodes_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(</span><span class="n">P</span><span class="p">),</span><span class="bp">self</span><span class="p">)</span>
                <span class="c1"># update edge</span>
                <span class="n">n0s</span> <span class="o">=</span> <span class="n">n0</span>
                <span class="n">n1s</span> <span class="o">=</span> <span class="n">n1</span>
                <span class="c1"># get segments information from cycle n0</span>
                <span class="n">dne</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span>
                <span class="c1"># remove connection to n0 to avoid a cycle being</span>
                <span class="c1"># connected to itself</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span>
                <span class="c1"># add information from adjacent cycle n1</span>
                <span class="n">dne</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span>
                <span class="c1"># list of items of the merged dictionnary</span>
                <span class="n">ine</span> <span class="o">=</span> <span class="n">dne</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="c1"># update n0 with the new merged polygon</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">polyg</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>
                <span class="c1"># connect new cycle n0 to neighbors</span>
                <span class="c1"># for x in ine:</span>
                <span class="c1">#     if x[0]!=n0:</span>
                <span class="c1">#         ncy  = x[0]</span>
                <span class="c1">#         dseg = x[1]</span>
                <span class="c1">#         # a link between cycles already exists</span>
                <span class="c1">#         if self.Gt.has_edge(n0,ncy):</span>
                <span class="c1">#             dseg_prev = self.Gt.edge[n0][ncy]</span>
                <span class="c1">#             dseg[&#39;segment&#39;]=list(set(dseg[&#39;segment&#39;]+dseg_prev[&#39;segment&#39;]))</span>
                <span class="c1">#         printn0,ncy,dseg[&#39;segment&#39;]</span>
                <span class="c1">#         self.Gt.add_edge(n0,ncy,segment=dseg[&#39;segment&#39;])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">n0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ine</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n0</span><span class="p">])</span>
                <span class="c1"># remove old cycle n1 n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                <span class="c1"># update pos of the cycle with merged polygon centroid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">P</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                <span class="c1"># delete _air segment a</span>
                <span class="c1"># do not apply g2npy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_segment</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">g2npy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">mapoldcy</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n0</span>
                <span class="c1"># fig,a=self.showG(&#39;st&#39;,aw=1)</span>
                <span class="c1"># plt.show()</span>
        <span class="c1">######</span>
        <span class="c1"># fix renumbering Gt nodes</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>
        
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Update Gs ncy&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">uc</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">uc</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">())}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span> <span class="n">nl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">nl</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span> <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nl</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updGsncy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># add cycle 0 to boundaries segments</span>
        <span class="c1"># cycle 0 is necessarily outdoor</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indoor</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># boundary adjascent cycles</span>
        <span class="c1">#</span>
        <span class="n">adjcyair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="p">))</span>
        <span class="c1"># connect cycles separated by air wall to cycle 0</span>
        <span class="k">for</span> <span class="n">cy</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjcyair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;isopen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="p">[</span><span class="n">seg</span><span class="p">])</span>
        
        <span class="c1"># </span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="c1"># print(&quot;check len(ncycles) == 2&quot;,)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">cncy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
            <span class="n">ucncyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cncy</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ucncym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cncy</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ucncyl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Some segments are connected to LESS than 2 cycles&quot;</span> <span class="o">+</span> \
                <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)[</span><span class="n">ucncyl</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ucncym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Some segments are connected to MORE than 2 cycles&quot;</span> <span class="o">+</span> \
                <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)[</span><span class="n">ucncym</span><span class="p">])</span>
            <span class="c1"># print(&quot;passed&quot;)</span>

        <span class="c1"># self.degree is updated in g2npy</span>
        <span class="c1"># self.degree has to be called before determination of diffraction points</span>
        <span class="c1"># which relies of the full determination of the degree of each point of Gs</span>
        <span class="c1"># including the corner point with degree 0 ( only connected to _AIR)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span>
        <span class="c1"># find diffraction points : updating self.ddiff</span>
        <span class="n">tqdmkwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="mf">100.</span><span class="p">,</span><span class="s1">&#39;desc&#39;</span><span class="p">:</span><span class="s1">&#39;Find Diffractions&#39;</span><span class="p">,</span><span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_diffractions</span><span class="p">(</span><span class="n">difftol</span><span class="o">=</span><span class="n">difftol</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tqdmkwargs</span><span class="o">=</span><span class="n">tqdmkwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>
            <span class="c1"># print(&#39;find diffraction...Done 8/12&#39;)</span>
            <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Diffraction on airwalls&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># </span>
        <span class="c1"># explanation of lnss</span>
        <span class="c1">#</span>
        <span class="c1"># list of diffraction point involving different segment </span>
        <span class="c1"># list of diffraction point involving subsegment ( = iso segments)</span>
        <span class="c1"># needs checking height in rays.to3D for constructing the 3D ray</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lnss</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lsss</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1">#   VIII -  Construct the list of interactions associated to each cycle</span>
        <span class="c1">#</span>
        <span class="c1"># Interaction labeling convention</span>
        <span class="c1">#</span>
        <span class="c1">#   tuple (npoint,)  : Diffraction on point npoint</span>
        <span class="c1">#   tuple (nseg,ncycle) : Reflection on nseg toward cycle ncycle</span>
        <span class="c1">#   tuple (nseg,cy0,cy1) : Transmission from cy0 to cy1 through nseg</span>
        <span class="c1">#</span>
        <span class="c1">#   At that stage the diffraction points are not included</span>
        <span class="c1">#   not enough information available.</span>
        <span class="c1">#   The diffraction points are not known yet</span>
        <span class="n">tqdmkwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="mf">100.</span><span class="p">,</span><span class="s1">&#39;desc&#39;</span><span class="p">:</span><span class="s1">&#39;List of interactions&#39;</span><span class="p">,</span><span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interlist</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tqdmkwargs</span><span class="o">=</span><span class="n">tqdmkwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># dca : dictionnary of cycles which have an air wall</span>
        <span class="c1">#</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Build dca&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dca</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">):</span>
                    <span class="n">cy</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dca</span><span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># print(&#39;build dca...Done 11/12&#39;)</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># indoor property is spread by contagion</span>
        <span class="c1">#</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Indoor properties&#39;</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>


        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">law</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># get current cycle</span>
            <span class="n">cur_cy</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># get neighbors of current_cycle</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span> <span class="n">cur_cy</span><span class="p">)</span>
            <span class="c1"># get neighbors separated by an air_wall</span>
            <span class="n">neighbors_aw</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neighbors</span> 
                            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">cur_cy</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;segment&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">cur_cy</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;segment&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">law</span>
                                <span class="p">)</span>
                            <span class="p">]</span>
            <span class="c1"># get not visited neighbors_aw</span>
            <span class="n">nv_neighbors_aw</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neighbors_aw</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">visited</span> <span class="o">+</span> <span class="n">to_visit</span><span class="p">)]</span>
            <span class="c1"># not visited neighbors air wall separated cycles are outdoor cycle</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nv_neighbors_aw</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;isopen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># extend to_visit to not visited neighbors</span>
            <span class="n">to_visit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nv_neighbors_aw</span><span class="p">)</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_cy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>
            <span class="n">Gtpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">/</span><span class="mf">12.</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_visual_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; visual checking of graphs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        fontsize : int </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span>
                            <span class="n">right</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> 
                            <span class="n">bottom</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span>
                            <span class="n">top</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">,</span>
                            <span class="n">wspace</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> 
                            <span class="n">hspace</span> <span class="o">=</span><span class="mi">0</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gs&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gt&#39;</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">aw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>

            <span class="n">indoor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]]</span>
            <span class="n">outdoor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span> 
                      <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>  <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pltpoly</span><span class="p">(</span><span class="n">indoor</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pltpoly</span><span class="p">(</span><span class="n">outdoor</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">aw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
            <span class="n">diffpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">diffpos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">diffpos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">s</span><span class="o">=</span><span class="mi">130</span><span class="p">)</span>
            <span class="c1">#ax.set_title(&#39;Diffraction points&#39;)</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;st&#39;</span><span class="p">,</span> <span class="n">aw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
            <span class="c1">#ax.set_title(&#39;$\mathcal{G}_t$&#39;,fontsize=fontsize)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;Gv&#39;</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;sv&#39;</span><span class="p">,</span> <span class="n">aw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
            <span class="c1">#ax.set_title(&#39;$\mathcal{G}_v$&#39;,fontsize=fontsize)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;no Gv found. Yet computed ?&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;visual_check.pdf&#39;</span><span class="p">)</span>
        <span class="c1">#plt.tight_layout()</span>
        <span class="c1"># axs[2,1].remove()</span>

    <span class="k">def</span> <span class="nf">_delaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">polyholes</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; make a Delaunay partitioning of a polygon</span>

<span class="sd">            If polyhole == []</span>


<span class="sd">                if a cycle is non convex</span>

<span class="sd">                1- find its polygon</span>
<span class="sd">                2- partition polygon into convex polygons (Delaunay)</span>
<span class="sd">                3- try to merge partitioned polygons in order to obtain</span>
<span class="sd">                   the minimal number of convex polygons</span>


<span class="sd">            If polyholes != []</span>

<span class="sd">                polygon poly contains holes (polyholes)</span>

<span class="sd">            This methods returns a partitioning of the polygon poly </span>
<span class="sd">            into several convex polygons (voronoi). </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            poly : sh.Polygon</span>
<span class="sd">            polyhole : list of sh.Polygon</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            ncpol : list</span>
<span class="sd">                list of new created geu.Polygons</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The algorithm updates the Gt nodes and edges created into self.buildGt</span>
<span class="sd">        by adding new nodes and new _AIR segments.</span>

<span class="sd">        Called In </span>
<span class="sd">        ---------</span>

<span class="sd">        pylayers.gis.layout.buildGt</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout.buildGt</span>
<span class="sd">        pylayers.gis.layout.add_segment</span>
<span class="sd">        pylayers.gis.layout.del_segment</span>
<span class="sd">        pylayers.util.geomutil.Polygon</span>
<span class="sd">        sp.spatial.Delaunay</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pucs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># keep all convex points (in + out) to build a Delaunay triangulation</span>
        <span class="k">if</span> <span class="n">polyholes</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polyholes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">polyholes</span> <span class="o">=</span> <span class="p">[</span><span class="n">polyholes</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">polyholes</span><span class="p">:</span>
                <span class="c1"># sum up polyholes to their gathered polygones</span>
                <span class="n">pucsh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ph</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">pucs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pucs</span><span class="p">,</span> <span class="n">pucsh</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pucs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">####</span>
            <span class="c1"># perform a Delaunay Partioning</span>
            <span class="c1">####</span>

            <span class="n">trid</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">pucs</span><span class="p">)</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">trid</span><span class="o">.</span><span class="n">simplices</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">naw</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">popo</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tri</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">pucs</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                <span class="c1"># check if the new polygon is contained into</span>
                <span class="c1"># the original polygon (non guarantee by Delaunay)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">C0</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">IPython.core.debugger</span> <span class="kn">import</span> <span class="n">Tracer</span>
                    <span class="n">Tracer</span><span class="p">()()</span>
                <span class="k">if</span> <span class="n">polyholes</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span>
                    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ii</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">polyholes</span><span class="p">]</span>

                <span class="n">popo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="c1"># if poly contains triangle but not the polyholes</span>
                <span class="c1"># if polyholes !=[]:</span>
                <span class="c1">#     self.pltpoly([ts],color=&#39;b&#39;)</span>
                <span class="c1">#     import ipdb</span>
                <span class="c1">#     ipdb.set_trace()</span>
                <span class="k">if</span> <span class="n">C0</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">C</span><span class="p">)):</span>
                    <span class="c1"># if polyholes!=[]:</span>
                    <span class="c1">#     self.pltpoly([ts],color=&#39;r&#39;)</span>
                    <span class="c1">#     plt.draw()</span>

                    <span class="n">cp</span> <span class="o">=</span> <span class="n">ts</span>
                    <span class="n">cp</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">uaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">lvn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uaw</span><span class="p">:</span>
                        <span class="c1"># keep track of created airwalls, because some</span>
                        <span class="c1"># of them will be destroyed in step 3.</span>
                        <span class="n">naw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span>
                                   <span class="n">cp</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lvn</span><span class="p">)],</span>
                                   <span class="n">cp</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lvn</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">))</span>
                    <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1"># 3. merge Delaunay triangulation in order to obtain</span>
            <span class="c1">#   the larger convex polygons partitioning</span>
            <span class="c1">#</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">(</span><span class="n">polys</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">([</span><span class="n">diff</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">:</span>
                    <span class="n">extra</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="n">extra</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>

            <span class="n">cpolys</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nbpolys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">polys</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">polys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ip2</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
                    <span class="n">conv</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">inter</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
                    <span class="c1"># if 2 triangles have a common segment</span>
                    <span class="n">pold</span> <span class="o">=</span> <span class="n">p</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inter</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">):</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">p2</span>
                        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">isconvex</span><span class="p">():</span>
                            <span class="n">polys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ip2</span><span class="p">)</span>
                            <span class="n">polys</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                            <span class="n">conv</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># if pold not in cpolys:</span>
                            <span class="c1">#     cpolys.append(pold)</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">pold</span>
                <span class="c1"># if (ip2 &gt;= len(polys)):# and (conv):</span>
                <span class="c1"># if conv :</span>
                <span class="c1">#     if p not in cpolys:</span>
                <span class="c1">#         cpolys.append(p)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">conv</span><span class="p">:</span>  <span class="c1"># else:</span>
                    <span class="k">if</span> <span class="n">pold</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cpolys</span><span class="p">:</span>
                        <span class="n">cpolys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pold</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cpolys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="c1"># 4. ensure the correct vnode numerotation of the polygons</span>
            <span class="c1"># and remove unecessary airwalls</span>

            <span class="c1"># ncpol : new created polygons</span>
            <span class="n">ncpol</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vnodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cpolys</span><span class="p">:</span>
                <span class="n">interpoly</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interpoly</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;multi polygon encountered&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ptmp</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">interpoly</span><span class="p">)</span>
                        <span class="c1"># ptmp = self.polysh2geu(interpoly)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="kn">import</span> <span class="nn">ipdb</span>
                        <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

                <span class="n">ptmp</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">ncpol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptmp</span><span class="p">)</span>
                <span class="n">vnodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ptmp</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>

            <span class="c1"># if no polyholes</span>
            <span class="k">if</span> <span class="n">polyholes</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="c1"># 4bis</span>
                <span class="c1"># Check if all the original area is covered</span>
                <span class="c1"># sometimes, area surrounded by 2 new airwalls is not found</span>
                <span class="c1"># the following code re-add it.</span>
                <span class="n">cpdiff</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">cascaded_union</span><span class="p">(</span><span class="n">cpolys</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cpdiff</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                    <span class="n">cpdiff</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">([</span><span class="n">cpdiff</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cpdiff</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">cpdiff</span><span class="p">:</span>
                        <span class="n">ptmp</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
                        <span class="n">ptmp</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="n">ncpol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptmp</span><span class="p">)</span>
                        <span class="n">vnodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ptmp</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>

            <span class="n">daw</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vnodes</span><span class="p">,</span> <span class="n">naw</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">daw</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_segment</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">g2npy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g2npy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ncpol</span>

<div class="viewcode-block" id="Layout.buildGt_old"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.buildGt_old">[docs]</a>    <span class="k">def</span> <span class="nf">buildGt_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        DEPRECATED</span>
<span class="sd">        build graph of convex cycles </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        check : booolean</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">pltpoly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[]):</span>
            <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">mpl</span> <span class="o">=</span> <span class="p">[</span><span class="n">PolygonPatch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">]</span>
            <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mpl</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">pltGt</span><span class="p">(</span><span class="n">Gt</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="p">[]):</span>
            <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="p">[</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;poly&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="c1"># I. get cycle basis</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">cycles</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">C</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">]</span>

        <span class="c1"># pdb.set_trace()</span>
        <span class="c1"># II. create the hull of the layout by merging all polygons</span>
        <span class="c1"># corresponding to cycles basis</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">lnode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
            <span class="n">npoints</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lnode</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">npoints</span><span class="p">)</span>
            <span class="n">poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
        <span class="c1"># union all polygons</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">cascaded_union</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

        <span class="c1"># transform into geomutil polygon</span>
        <span class="c1"># if  polygon is a layout</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">ma</span><span class="p">)</span>
            <span class="n">ma</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is a fix for non enclosed layouts</span>
            <span class="c1"># with multiple non joint polygons (a.k.a. a city)</span>
            <span class="c1"># raise AttributeError(&#39;this is a city&#39;)</span>
            <span class="n">macvx</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">convex_hull</span>

            <span class="n">streets</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">macvx</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">ma</span><span class="p">))</span>
            <span class="n">streets</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># add air walls where to close the street &amp; ma polygon</span>
            <span class="n">uaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">streets</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lvn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">streets</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uaw</span><span class="p">:</span>
                <span class="c1"># keep trace of created airwalls, because some</span>
                <span class="c1"># of them will be destroyed in step 3.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span>
                    <span class="n">streets</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lvn</span><span class="p">)],</span>
                    <span class="n">streets</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lvn</span><span class="p">)],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>

            <span class="n">ma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polysh2geu</span><span class="p">(</span><span class="n">macvx</span><span class="p">)</span>
            <span class="n">ma</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">streets</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">ma</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ma</span> <span class="o">=</span> <span class="n">ma</span>

        <span class="c1"># III .FIND POLYGONS</span>
        <span class="c1">###</span>
        <span class="c1"># polygons of each cycle are found by finding the interesection between</span>
        <span class="c1"># all segments of the layout and the layout hull.</span>
        <span class="c1"># The shapely diff return a multipolygon where all polygons corresponds to</span>
        <span class="c1"># a cycle</span>
        <span class="c1">#</span>

        <span class="c1"># get connected points from segments</span>
        <span class="c1"># connect is equivalent to self.tahe and lpos to self.pt</span>
        <span class="c1">#</span>
        <span class="n">connect</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;connect&#39;</span><span class="p">]</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># get their coordinates</span>
        <span class="n">lpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connect</span><span class="p">])</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lpos</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">LineString</span><span class="p">([</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="c1"># create associated multilines</span>
        <span class="n">ml</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="c1"># increase buffer size ( width of polyline) to create a multipolygon</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">buffersize</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">)</span> <span class="ow">and</span> <span class="n">buffersize</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="c1"># create polygon from multiline by given a width to lines</span>
            <span class="n">mlp</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffersize</span><span class="p">)</span>
            <span class="c1"># the difference between the layout hull and polygons built from lines</span>
            <span class="c1"># returns the ndesired multipolygon</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">mlp</span><span class="p">)</span>
            <span class="c1"># increase size of the buffer</span>
            <span class="n">buffersize</span> <span class="o">=</span> <span class="n">buffersize</span> <span class="o">*</span> <span class="mi">10</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">([</span><span class="n">R</span><span class="p">])</span>

        <span class="c1"># assert isinstance(R,sh.MultiPolygon), &quot;Shapely.MultiPolygon decomposition Failed&quot;</span>

        <span class="c1">####################</span>
        <span class="c1"># Manage inner hole in polygons</span>
        <span class="c1"># ------------------------------</span>
        <span class="c1"># This part manages layout not correctly described, where</span>
        <span class="c1"># polygons remains in the middle of others</span>
        <span class="c1">######</span>

        <span class="c1"># if !=0 it means some polygons are inside of others</span>
        <span class="c1"># which is not allowed. Some Layout modification will be performed</span>

        <span class="n">Rgeu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">contain</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">ur</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>

                <span class="n">Rgeu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polysh2geu</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="c1"># self.pltpoly([Rgeu[-1]],color=&#39;b&#39;)</span>
                <span class="c1"># plt.draw()</span>
                <span class="c1"># Rgeu.append(geu.Polygon(r))</span>
                <span class="c1"># Rgeu[-1].setvnodes(self)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;reject&quot;</span><span class="p">)</span>
            <span class="c1"># if area are not the same, it means that there is inner holes in r</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">Rgeu</span><span class="p">[</span><span class="n">ur</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">area</span><span class="p">):</span>
                <span class="c1"># detect inclusion</span>
                <span class="n">uc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">Rgeu</span><span class="p">[</span><span class="n">ur</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">R</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">contain</span><span class="p">[</span><span class="n">ur</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">uc</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">ur</span><span class="p">]</span>

        <span class="c1"># # split polygons with holes into several polygons without holes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">macvx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">contain</span><span class="p">:</span>

            <span class="n">polyholes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Rgeu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">contain</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>

            <span class="c1"># 1 convexify polyholes</span>
            <span class="n">polyg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convex_hull</span><span class="p">(</span><span class="n">polyholes</span><span class="p">)</span>
            <span class="n">polyholes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">polyg</span><span class="p">)</span>
            <span class="n">Rgeu</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">polyg</span><span class="p">)</span>
            <span class="c1"># 2 delaunay on exterior</span>
            <span class="n">ncpol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delaunay</span><span class="p">(</span><span class="n">Rgeu</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">polyholes</span><span class="o">=</span><span class="n">polyholes</span><span class="p">)</span>

            <span class="n">Rgeu</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">Rgeu</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ncpol</span><span class="p">)</span>

            <span class="c1"># add polyhole to convex mask ( macvx) list</span>
            <span class="n">macvx</span> <span class="o">=</span> <span class="n">cascaded_union</span><span class="p">(</span><span class="n">polyholes</span><span class="p">)</span>
            <span class="n">macvx</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">macvx</span><span class="p">)</span>
            <span class="n">macvx</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">macvx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">macvx</span><span class="p">)</span>

        <span class="c1">####################</span>
        <span class="c1"># Manage  convex hull of the layout</span>
        <span class="c1"># -------------------</span>

        <span class="c1"># polys = self._convex_hull()</span>
        <span class="c1"># Rgeu.extend(polys)</span>

        <span class="c1">####################</span>
        <span class="c1"># Manage Non convex polygons</span>
        <span class="c1"># -------------------</span>
        <span class="c1"># 1 . determine which polygons are not convex</span>
        <span class="c1"># 2 . apply a delaunay and tranform a single non convexpolygon</span>
        <span class="c1"># into several convex ( self.delaunay)</span>
        <span class="c1"># 3. remove old non convex polygon and readd new convex ones.</span>

        <span class="n">ncpol</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ur</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Rgeu</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">isconvex</span><span class="p">():</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;nt cvx&#39;</span><span class="p">)</span>
                <span class="n">ncpol</span><span class="p">[</span><span class="n">ur</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delaunay</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

                <span class="c1"># plt.ion()</span>
                <span class="c1"># self.pltpoly(ncpol[ur],fig=plt.gcf(),ax=plt.gca())</span>
                <span class="c1"># plt.show()</span>
                <span class="c1"># plt.draw()</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>
        <span class="n">Rgeu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">Rgeu</span><span class="p">,</span> <span class="n">ncpol</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="p">[</span><span class="n">Rgeu</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ncpol</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ncpol</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># IV Find Vnodes and Final polygons</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">ncyid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">sma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># smac = self.macvx.vnodes[self.macvx.vnodes&gt;0]</span>
        <span class="c1"># segma = np.unique(np.concatenate((sma,smac)))</span>
        <span class="n">segma</span> <span class="o">=</span> <span class="n">sma</span>
        <span class="c1"># VI  add node 0</span>
        <span class="c1">#</span>
        <span class="c1">#   This shapely polygon has an interior</span>
        <span class="c1">#    Cycles = 0 exterior cycle (assumed outdoor)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">S</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">()})</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="n">cycl</span><span class="o">.</span><span class="n">Cycle</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">),</span> <span class="n">delta</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">boundary</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">vnodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">polyg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="p">,</span> <span class="n">cycle</span><span class="o">=</span><span class="n">cycle</span><span class="p">,</span>
                         <span class="n">indoor</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">isopen</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># IV 1 get nodes and vnodes</span>

        <span class="k">for</span> <span class="n">ui</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Rgeu</span><span class="p">):</span>
            <span class="n">cyid</span> <span class="o">=</span> <span class="n">ui</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">outdoor</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c1"># IV 1.a get vnode associated to the polygon</span>
            <span class="c1"># get vnodes not in the correct order</span>
            <span class="c1"># uvn = np.where([r.buffer(1e-3).contains(p) for p in shpt])[0]</span>
            <span class="c1"># vnodes = Gsnodes[uvn]</span>

            <span class="c1"># IV 1.b transform vnodes to an ordered cycle with Cycle class</span>
            <span class="c1"># NOTE ! Using class cycle is MANDATORY</span>
            <span class="c1"># because, some extra vnodes can be picked up during the contain</span>
            <span class="c1"># process before</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
            <span class="n">S</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">S</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">nodes</span><span class="p">()})</span>

            <span class="n">cycle</span> <span class="o">=</span> <span class="n">cycl</span><span class="o">.</span><span class="n">Cycle</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

            <span class="c1"># IV 1.c create a new polygon with correct vnodes and correct points</span>
            <span class="c1"># P = geu.Polygon(p=cycle.p,vnodes=cycle.cycle)</span>
            <span class="c1"># import ipdb</span>
            <span class="c1"># ipdb.set_trace()</span>
            <span class="c1"># IV 1.d add node to Gt + position</span>
            <span class="c1">#</span>

            <span class="n">seg</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">lair</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seg</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lair</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isopen</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isopen</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># IV 1.e</span>
            <span class="c1">#   + add new node (convex cycle) to Gt</span>
            <span class="c1">#   + add centroid of cycle as position of cycle</span>
            <span class="c1"># if ((cyid==40) or (cyid==41)):</span>
            <span class="c1">#     pdb.set_trace()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">cyid</span><span class="p">,</span> <span class="n">cycle</span><span class="o">=</span><span class="n">cycle</span><span class="p">,</span> <span class="n">polyg</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                             <span class="n">isopen</span><span class="o">=</span><span class="n">isopen</span><span class="p">,</span> <span class="n">indoor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">cyid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">xy</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]})</span>

        <span class="c1"># IV 2. get edges</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">)</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]):</span>
                        <span class="c1"># find common segments</span>
                        <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cycle</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cycle</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)])</span>
                        <span class="c1"># if cycle are connected by at least a segmnet but not</span>
                        <span class="c1"># a point</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="n">seg</span><span class="p">)</span>

        <span class="c1"># import ipdb</span>
        <span class="c1"># ipdb.set_trace()</span>
        <span class="c1">#  V update Gs</span>
        <span class="c1">#   V 1.Update graph Gs nodes with their cycles information</span>
        <span class="c1">#</span>
        <span class="c1">#   initialize a void list &#39;ncycles&#39; for each node of Gs</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updGsncy</span><span class="p">()</span>
        <span class="c1"># make a convex hull of layout</span>
        <span class="c1"># get segments of the mask ( equivalent to thoose connected to 0)</span>
        <span class="c1"># seg0 = [i for i in self.ma.vnodes if i &gt;0]</span>
        <span class="c1"># [self.Gs.node[i][&#39;ncycles&#39;].append(0) for i in seg0]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_addoutcy</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>

        <span class="c1">#   V 2. add outside cycle (absorbant region index 0 )</span>
        <span class="c1">#   if ncycles is a list which has only one element then the adjascent cycle is the</span>
        <span class="c1">#   outside region (cycle 0)</span>
        <span class="c1">#</span>
        <span class="c1">#   VII - Connect cycle 0 to each cycle connected to the layout</span>
        <span class="c1">#   boundary</span>
        <span class="c1">#</span>

        <span class="c1"># all segments of the Layout boundary</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">boundary</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>
        <span class="c1"># air segments of the Layout boundary</span>
        <span class="n">nsegair</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">],</span> <span class="n">nseg</span><span class="p">)</span>
        <span class="c1"># wall segments of the Layout boundary</span>
        <span class="n">nsegwall</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">],</span> <span class="n">nseg</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># boundary adjascent cycles</span>
        <span class="c1">#</span>

        <span class="n">adjcyair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsegair</span><span class="p">))</span>
        <span class="n">adjcwall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsegwall</span><span class="p">))</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="c1"># adjcyair = np.unique(adjcyair)</span>
        <span class="c1"># adjcwall = np.unique(adjcwall)</span>

        <span class="c1"># connect cycles separated by air wall to cycle 0</span>
        <span class="k">for</span> <span class="n">cy</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjcyair</span><span class="p">,</span> <span class="n">nsegair</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;isopen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">seg</span><span class="p">]))</span>

        <span class="c1"># connect cycles separated by wall to cycle 0</span>
        <span class="k">for</span> <span class="n">cy</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjcwall</span><span class="p">,</span> <span class="n">nsegwall</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">seg</span><span class="p">]))</span>

        <span class="c1"># IV Handle indoor/outdoor cycle</span>
        <span class="c1">#</span>
        <span class="c1"># Rule : A cycle is outdoor if it is separated from an outdoor cycle by an AIR segment</span>
        <span class="c1">#</span>
        <span class="c1"># An outdoor cycle has no associated ceil</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">lncy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ncy</span> <span class="ow">in</span> <span class="n">lncy</span><span class="p">:</span>
                <span class="n">segnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;segment&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">segnum</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;AIR&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_find_diffractions</span><span class="p">()</span>
        <span class="c1">#</span>
        <span class="c1">#   VIII -  Construct the list of interactions associated to each cycle</span>
        <span class="c1">#</span>
        <span class="c1"># Interaction labeling convention</span>
        <span class="c1">#</span>
        <span class="c1">#   tuple (npoint,)  : Diffraction on point npoint</span>
        <span class="c1">#   tuple (nseg,ncycle) : Reflection on nseg toward cycle ncycle</span>
        <span class="c1">#   tuple (nseg,cy0,cy1) : Transmission from cy0 to cy1 through nseg</span>
        <span class="c1">#</span>
        <span class="c1">#   At that stage the diffraction points are not included</span>
        <span class="c1">#   not enough information available.</span>
        <span class="c1">#   The diffraction points are not known yet</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interlist</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_updGsncy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; update Gs ncycles using Gt information</span>

<span class="sd">        Update graph Gs segment with their 2 cycles information</span>

<span class="sd">        initialize a void list &#39;ncycles&#39; for each segment of Gs</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout.buildGt</span>
<span class="sd">        pylayers.gis.layout.convexify</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># filter out node 0</span>
        <span class="n">Gtnodes</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

        <span class="c1"># loop over all cycles</span>
        <span class="k">for</span> <span class="n">ncy</span> <span class="ow">in</span> <span class="n">Gtnodes</span><span class="p">:</span>
            <span class="c1"># get vnodes : points and segments number</span>
            <span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vnodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ncy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ncy</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s1">&#39;A segment cannot relate more than 2 cycles&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nseg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nseg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ncycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nseg</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncycles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nseg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">ncycles</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ncycles</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;segment&#39;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">ncycles</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ncycles</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span>
                            <span class="s1">&#39;segment&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nseg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_addoutcy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Probably use in a future version of buildGt , managing the upcoming inifile</span>
<span class="sd">        add outside cycle (absorbant region index 0 )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        check : Boolean </span>

<span class="sd">        #   if ncycles is a list which has only one element then the adjascent</span>
<span class="sd">        #   cycle is the  outside region (cycle 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seg0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">macvx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">macvx</span><span class="p">:</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">macvx</span><span class="o">.</span><span class="n">vnodes</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">seg0</span> <span class="o">=</span> <span class="n">seg0</span> <span class="o">+</span> <span class="n">seg</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seg0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;check len(ncycles) == 2&quot;</span><span class="p">,)</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">cncy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
            <span class="n">ucncyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cncy</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ucncym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cncy</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ucncyl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Some segments are connected to LESS than 2 cycles&quot;</span> <span class="o">+</span> \
                <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)[</span><span class="n">ucncyl</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ucncym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Some segments are connected to MORE than 2 cycles&quot;</span> <span class="o">+</span> \
                <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)[</span><span class="n">ucncym</span><span class="p">])</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;passed&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_interlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="p">[],</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span><span class="n">tqdmkwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; Construct the list of interactions associated to each cycle</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        nodelist: list</span>
<span class="sd">            list of Gt nodes (cycles) for which interactions have to be found</span>
<span class="sd">    </span>
<span class="sd">            </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        if selfr.indoor==True , get list of interaction of Gt cycle with indoor =True</span>
<span class="sd">            else list of indoor interaction is skipped</span>

<span class="sd">         Interaction labeling convention</span>

<span class="sd">           tuple (npoint,)  : Diffraction on point npoint</span>
<span class="sd">           tuple (nseg,ncycle) : Reflection on nseg toward cycle ncycle</span>
<span class="sd">           tuple (nseg,cy0,cy1) : Transmission from cy0 to cy1 through nseg</span>

<span class="sd">           At that stage the diffraction points are not included</span>
<span class="sd">           not enough information available. The diffraction point are not</span>
<span class="sd">           known yet</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout.buildGt</span>
<span class="sd">        pylayers.gis.layout._convex_hull</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tqdmkwargs</span><span class="o">==</span><span class="p">{}:</span>
            <span class="n">tqdmkwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="mf">100.</span><span class="p">,</span>
                        <span class="s1">&#39;desc&#39;</span><span class="p">:</span><span class="s1">&#39;list of interactions&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">nodelist</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">nodelist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodelist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">nodelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodelist</span><span class="p">]</span>

        <span class="c1"># for all cycles k (node of Gt)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
            <span class="n">cpt</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span>
            <span class="n">pbar</span> <span class="o">=</span>  <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">tqdmkwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">*</span><span class="n">cpt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;indoor&#39;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]:</span>
                    <span class="c1">#vnodes = self.Gt.node[k][&#39;vnodes&#39;]</span>
                    <span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span>
                    <span class="n">ListInteractions</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">inode</span> <span class="ow">in</span> <span class="n">vnodes</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">inode</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># segments</span>
                            <span class="n">cy</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">inode</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span>
                            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">inode</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>  <span class="c1"># segment name</span>
                            <span class="c1">#</span>
                            <span class="c1"># Reflexion occurs on segment different</span>
                            <span class="c1"># from AIR and ABSORBENT  (segment number, cycle)</span>
                            <span class="c1">#</span>
                            <span class="k">if</span> <span class="p">((</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ABSORBENT&#39;</span><span class="p">)):</span>
                                <span class="n">ListInteractions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">inode</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                            <span class="c1">#</span>
                            <span class="c1"># Transmission requires 2 cycles separated by a</span>
                            <span class="c1"># segment which is different from METAL and ABSORBENT</span>
                            <span class="c1">#</span>
                            <span class="c1"># (segment number, cycle in , cycle out )</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;METAL&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s1">&#39;ABSORBENT&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">):</span>
                                    <span class="n">ncy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cy</span><span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="n">k</span><span class="p">}))[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="n">ListInteractions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">inode</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ncy</span><span class="p">))</span>
                                    <span class="n">ListInteractions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">inode</span><span class="p">,</span> <span class="n">ncy</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># points</span>
                            <span class="k">pass</span>
                    <span class="c1"># add list of interactions of a cycle</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">inter</span><span class="o">=</span><span class="n">ListInteractions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">inter</span><span class="o">=</span><span class="p">[])</span>

    <span class="k">def</span> <span class="nf">_convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add air walls to the layout enveloppe in self.Gs </span>
<span class="sd">        in order the hull of the Layout to be convex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        mask : Polygon</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        polys : list of geu.Polygon</span>
<span class="sd">            nsew polygon of the convex hull</span>

<span class="sd">        self.macvx : convex mask of the layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This is a post processing of BuildGt</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.gis.layout._interlist</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1 - Find differences between the convex hull and the Layout contour</span>
        <span class="c1">#     The result of the difference are polygons</span>

        <span class="n">masku</span> <span class="o">=</span> <span class="n">cascaded_union</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">masku</span><span class="o">.</span><span class="n">convex_hull</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">masku</span><span class="p">)</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
                    <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                    <span class="n">polys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setvnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">lncy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="c1"># p.coorddeter()</span>
            <span class="n">uaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">aw</span> <span class="ow">in</span> <span class="n">uaw</span><span class="p">:</span>
                <span class="c1"># 2 - non existing segments are created as airwalls</span>
                <span class="n">awid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">aw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">aw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AIR&#39;</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span><span class="n">aw</span><span class="p">]</span> <span class="o">=</span> <span class="n">awid</span>

        <span class="c1"># U = cascaded_union([mask]+polys)</span>

        <span class="c1"># self.macvx = geu.Polygon(U)</span>
        <span class="c1"># self.macvx.setvnodes(self)</span>

        <span class="k">return</span> <span class="n">polys</span>


<div class="viewcode-block" id="Layout.buildGv"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.buildGv">[docs]</a>    <span class="k">def</span> <span class="nf">buildGv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; build visibility graph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        show : boolean</span>
<span class="sd">            default False</span>
<span class="sd">        verbose : boolean </span>
<span class="sd">        tqdmpos : progressbar</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; L.buildGt()</span>
<span class="sd">        &gt;&gt;&gt; Ga = L.buildGr()</span>
<span class="sd">        &gt;&gt;&gt; L.buildGv()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method exploits cycles convexity.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;ddiff&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">Gvpbar</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;build Gv&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gv&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># loop over convex cycles (nodes of Gt)</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dGv</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dict of Gv graph</span>

        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">icycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">Gvpbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">*</span><span class="n">cpt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">icycle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#if self.indoor or not self.Gt.node[icycle][&#39;indoor&#39;]:</span>
                    <span class="c1">#print(icycle)</span>
                <span class="c1">#    pass</span>
                <span class="c1">#</span>
                <span class="c1">#  If indoor or outdoor all visibility are calculated</span>
                <span class="c1">#  If outdoor only visibility between iso = &#39;AIR&#39; and &#39;_AIR&#39; are calculated </span>
                <span class="c1"># </span>
                <span class="c1">#if self.indoor or not self.Gt.node[icycle][&#39;indoor&#39;]:</span>
                <span class="n">polyg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">icycle</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>

                <span class="c1"># plt.show(polyg.plot(fig=plt.gcf(),ax=plt.gca())</span>
                
                <span class="c1"># take a single segment between 2 points </span>
                
                <span class="n">vnodes</span> <span class="o">=</span> <span class="n">polyg</span><span class="o">.</span><span class="n">vnodes</span>

                <span class="c1"># list of index of points in vodes</span>
                <span class="n">unodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">vnodes</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="c1"># list of position of an incomplete list of segments </span>
                <span class="c1"># used rule : after a point there is always a segment </span>
                <span class="n">useg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">unodes</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">vnodes</span><span class="p">))</span>
                
                <span class="c1"># list of points </span>
                <span class="c1">#npt  = filter(lambda x: x &lt; 0, vnodes)</span>
                <span class="n">npt</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vnodes</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span>
                
                <span class="n">nseg_full</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vnodes</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="c1"># nseg : incomplete list of segments</span>
                <span class="c1">#</span>
                <span class="c1"># if mode outdoor and cycle is indoor only </span>
                <span class="c1"># the part above the building (AIR and _AIR) is considered</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;outdoor&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">icycle</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">])):</span>
                    <span class="n">nseg</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nseg_full</span> <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nseg</span> <span class="o">=</span> <span class="n">vnodes</span><span class="p">[</span><span class="n">useg</span><span class="p">]</span>

                
                <span class="c1"># # nseg_full : full list of segments</span>
                <span class="c1"># #nseg_full = filter(lambda x: x &gt; 0, vnodes)</span>

                <span class="c1"># # keep only airwalls without iso single (_AIR)</span>
                <span class="c1"># nseg_single = filter(lambda x: len(self.Gs.node[x][&#39;iso&#39;])==0, nseg)</span>

                <span class="c1"># lair1 = self.name[&#39;AIR&#39;] </span>
                <span class="c1"># lair2 = self.name[&#39;_AIR&#39;]</span>
                <span class="c1"># lair  = lair1 + lair2</span>

                <span class="c1"># # list of airwalls in nseg_single</span>

                <span class="c1"># airwalls = filter(lambda x: x in lair, nseg_single)</span>

                <span class="c1"># diffraction points </span>

                <span class="n">ndiff</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">npt</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                <span class="c1">#</span>
                <span class="c1"># Create a graph</span>
                <span class="c1">#</span>

                <span class="n">Gv</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gv&#39;</span><span class="p">)</span>
                <span class="c1">#</span>
                <span class="c1"># in convex case :</span>
                <span class="c1">#</span>
                <span class="c1">#    i)  every non aligned segments see each other</span>
                <span class="c1">#</span>
                <span class="k">for</span> <span class="n">nk</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">nseg</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">nk0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">nk1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tgs</span><span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">tahe0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span> <span class="n">nk0</span><span class="p">]</span>
                    <span class="n">tahe1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[:,</span> <span class="n">nk1</span><span class="p">]</span>

                    <span class="n">pta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">tahe0</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">phe0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">tahe0</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">pta1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">tahe1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">phe1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">tahe1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="n">aligned</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">is_aligned4</span><span class="p">(</span><span class="n">pta0</span><span class="p">,</span><span class="n">phe0</span><span class="p">,</span><span class="n">pta1</span><span class="p">,</span><span class="n">phe1</span><span class="p">)</span>
                    <span class="c1"># A0 = np.vstack((pta0, phe0, pta1))</span>
                    <span class="c1"># A0 = np.hstack((A0, np.ones((3, 1))))</span>

                    <span class="c1"># A1 = np.vstack((pta0, phe0, phe1))</span>
                    <span class="c1"># A1 = np.hstack((A1, np.ones((3, 1))))</span>

                    <span class="c1"># d0 = np.linalg.det(A0)</span>
                    <span class="c1"># d1 = np.linalg.det(A1)</span>

                    <span class="c1">#if not ((abs(d0) &lt; 1e-1) &amp; (abs(d1) &lt; 1e-1)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">aligned</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">])):</span>
                            <span class="c1"># get the iso segments of both nk[0] and nk[1]</span>
                            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;indoor&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">icycle</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">])):</span>
                                <span class="n">l0</span> <span class="o">=</span> <span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span>
                                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;iso&#39;</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">l0</span> <span class="o">=</span> <span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                                <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="n">nk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                            <span class="k">for</span> <span class="n">vlink</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">):</span>
                                <span class="c1">#printicycle,vlink[0],vlink[1]</span>
                                <span class="n">Gv</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">vlink</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vlink</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1">#</span>
                <span class="c1"># Handle diffraction points</span>
                <span class="c1">#</span>
                <span class="c1">#    ii) all non adjascent valid diffraction points see each other</span>
                <span class="c1">#    iii) all valid diffraction points see segments non aligned</span>
                <span class="c1">#    with adjascent segments</span>
                <span class="c1">#</span>
                <span class="c1">#if diffraction:</span>
                <span class="c1">#</span>
                <span class="c1"># diffraction only if indoor or outdoor cycle if outdoor</span>
                <span class="c1"># </span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;indoor&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">icycle</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">])):</span>
                    <span class="n">ndiffvalid</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ndiff</span> <span class="k">if</span> <span class="n">icycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

                        <span class="c1"># non adjascent segment of vnodes see valid diffraction</span>
                        <span class="c1"># points</span>
                    <span class="k">for</span> <span class="n">idiff</span> <span class="ow">in</span> <span class="n">ndiffvalid</span><span class="p">:</span>
                        <span class="c1">#</span>
                        <span class="c1"># segments voisins du point de diffraction valide</span>
                        <span class="c1">#</span>
                        <span class="n">nsneigh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> 
                                   <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">idiff</span><span class="p">)</span> 
                                   <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nseg_full</span><span class="p">]</span>
                        <span class="c1"># segvalid : not adjascent segment</span>
                        <span class="n">seen_from_neighbors</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="c1">#</span>
                        <span class="c1"># point to point</span>
                        <span class="c1">#</span>
                        <span class="k">for</span> <span class="n">npoint</span> <span class="ow">in</span> <span class="n">ndiffvalid</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">npoint</span> <span class="o">!=</span> <span class="n">idiff</span><span class="p">:</span>
                                <span class="n">Gv</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">idiff</span><span class="p">,</span> <span class="n">npoint</span><span class="p">)</span>

                        <span class="c1">#</span>
                        <span class="c1"># All the neighbors segment in visibility which are not connected to cycle 0</span>
                        <span class="c1"># and which are not neighbrs of the point idiff</span>
                        <span class="c1">#</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nsneigh</span><span class="p">:</span>
                            <span class="n">neighbx</span> <span class="o">=</span> <span class="p">[</span> <span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">Gv</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> 
                                        <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span> 
                                        <span class="ow">and</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nsneigh</span><span class="p">]</span>
                            <span class="n">seen_from_neighbors</span> <span class="o">+=</span> <span class="n">neighbx</span>

                        <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">seen_from_neighbors</span><span class="p">:</span>
                            <span class="n">Gv</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">idiff</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Graph Gv composition</span>
                <span class="c1">#</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="n">Gv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGv</span><span class="p">[</span><span class="n">icycle</span><span class="p">]</span> <span class="o">=</span> <span class="n">Gv</span></div>

<div class="viewcode-block" id="Layout.buildGi"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.buildGi">[docs]</a>    <span class="k">def</span> <span class="nf">buildGi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; build graph of interactions</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        For each node of graph Gv creates</span>
<span class="sd">        5 different nodes associated to the same segment</span>

<span class="sd">        (np,) D</span>
<span class="sd">        (ns,cy0) R -&gt; cy0</span>
<span class="sd">        (ns,cy1) R -&gt; cy1</span>
<span class="sd">        (ns,cy0,cy1) T 0-&gt;1</span>
<span class="sd">        (ns,cy1,cy0) T 1-&gt;0</span>

<span class="sd">        Gi is an oriented Graph (DiGraph) </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Gipbar</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Build Gi&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Gipbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gi&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1">#</span>
        <span class="c1"># 1 ) Create nodes of Gi and their positions</span>
        <span class="c1">#</span>
        <span class="c1"># diffraction node  (D,)</span>
        <span class="c1"># reflexion node    (R,cy0)</span>
        <span class="c1"># transmission node (T,cy0,cy1)</span>
        <span class="c1">#</span>

        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">100.</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">node</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Create Gi nodes&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="c1"># espoo_journal debug</span>
            <span class="c1">#if n == 530:</span>
            <span class="c1">#    pdb.set_trace()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># D</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[(</span><span class="n">n</span><span class="p">,)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># R | T</span>
                <span class="n">cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">cy0</span> <span class="o">=</span> <span class="n">cy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cy1</span> <span class="o">=</span> <span class="n">cy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">nei</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># get neighbor</span>
                <span class="n">np1</span> <span class="o">=</span> <span class="n">nei</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">np2</span> <span class="o">=</span> <span class="n">nei</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">])</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">])</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span>
                <span class="n">nl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="n">ln</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="n">nl</span>

                <span class="n">delta</span> <span class="o">=</span> <span class="n">nl</span> <span class="o">/</span> <span class="mf">10.</span>

                <span class="c1"># On AIR or ABSORBENT there is no reflection</span>

                <span class="k">if</span> <span class="p">((</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ABSORBENT&#39;</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">cy0</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">cy0</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">ln</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">cy1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">cy1</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">ln</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>

                <span class="c1"># Through METAL or ABSORBENT there is no transmission</span>
                <span class="c1"># except if n has a subsegment</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;METAL&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;ABSORBENT&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">cy0</span><span class="p">,</span> <span class="n">cy1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">cy1</span><span class="p">,</span> <span class="n">cy0</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">cy0</span><span class="p">,</span> <span class="n">cy1</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">ln</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">cy1</span><span class="p">,</span> <span class="n">cy0</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">ln</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># 2) Establishing link between interactions</span>
        <span class="c1">#</span>
        <span class="c1"># Loop over all Gt nodes cy </span>
        <span class="c1">#</span>
        <span class="c1">#   if cy &gt; 0 </span>
        <span class="c1">#     calculates vnodes of cycles</span>
        <span class="c1">#     for all node of vnodes</span>
        <span class="c1">#</span>
        <span class="n">iprint</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
            <span class="n">Gipbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">33.</span><span class="p">)</span>

        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">100.</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;Create Gi nodes&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span>
            <span class="c1"># for all &gt;0 convex cycles</span>
            <span class="k">if</span> <span class="n">cy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span>
                <span class="n">npt</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1">#</span>
                <span class="c1"># find all diffraction points involved in the cycle cy </span>
                <span class="c1">#</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vnodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">cy</span><span class="p">:</span>
                                    <span class="n">npt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                
                <span class="n">nseg</span> <span class="o">=</span> <span class="p">[</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vnodes</span> <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">]</span>
                <span class="c1"># all segments and diffraction points of the cycle</span>
                <span class="n">vnodes</span> <span class="o">=</span> <span class="n">nseg</span> <span class="o">+</span> <span class="n">npt</span>

                <span class="k">for</span> <span class="n">nstr</span> <span class="ow">in</span> <span class="n">vnodes</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">nstr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                        <span class="c1"># list 1 of interactions</span>
                        
                        <span class="n">li1</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="n">nstr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># output cycle </span>
                            <span class="c1"># cy -&gt; cyo1 </span>
                            <span class="n">cyo1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nstr</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
                            <span class="n">cyo1</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cyo1</span> <span class="k">if</span> <span class="n">x</span><span class="o">!=</span> <span class="n">cy</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="c1">#cyo1 = filter(lambda x: x != cy, cyo1)[0]</span>

                            <span class="c1"># R , Tin , Tout</span>
                            <span class="k">if</span> <span class="n">cyo1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                    <span class="n">li1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span>  <span class="c1"># R </span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cyo1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                    <span class="n">li1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cyo1</span><span class="p">))</span> <span class="c1"># T cy -&gt; cyo1 </span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cyo1</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                    <span class="n">li1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cyo1</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span> <span class="c1"># T : cyo1 -&gt; cy </span>
                                <span class="c1"># if (nstr,cy) in self.Gi.nodes():</span>
                                <span class="c1">#     li1 = [(nstr,cy),(nstr,cy,cyo1),(nstr,cyo1,cy)]</span>
                                <span class="c1"># else:# no reflection on airwall</span>
                                <span class="c1">#     li1 = [(nstr,cyo1,cy)]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                    <span class="n">li1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nstr</span><span class="p">,</span> <span class="n">cy</span><span class="p">)]</span>
                                <span class="c1"># else:</span>
                                <span class="c1">#     li1 =[]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># D</span>
                            <span class="n">li1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nstr</span><span class="p">,)]</span>
                        <span class="c1"># list of cycle entities in visibility of nstr</span>
                        <span class="n">lneighb</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="n">nstr</span><span class="p">)</span>
                        <span class="c1">#if (self.Gs.node[nstr][&#39;name&#39;]==&#39;AIR&#39;) or (</span>
                        <span class="c1">#        self.Gs.node[nstr][&#39;name&#39;]==&#39;_AIR&#39;):</span>
                        <span class="c1">#    lneighcy = lneighb</span>
                        <span class="c1">#else:</span>
                        <span class="c1"># list of cycle entities in visibility of nstr in the same cycle </span>
                        <span class="n">lneighcy</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lneighb</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vnodes</span> <span class="p">]</span> 
                        <span class="c1"># lneighcy = filter(lambda x: x in vnodes, lneighb)</span>

                        <span class="k">for</span> <span class="n">nstrb</span> <span class="ow">in</span> <span class="n">lneighcy</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nstrb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                <span class="n">li2</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="k">if</span> <span class="n">nstrb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">cyo2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nstrb</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
                                    <span class="n">cyo2</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cyo2</span> <span class="k">if</span> <span class="n">x</span><span class="o">!=</span> <span class="n">cy</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="c1">#cyo2 = filter(lambda x: x != cy, cyo2)[0]</span>
                                    <span class="k">if</span> <span class="n">cyo2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                            <span class="n">li2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cyo2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                            <span class="n">li2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cyo2</span><span class="p">))</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cyo2</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                            <span class="n">li2</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cyo2</span><span class="p">,</span> <span class="n">cy</span><span class="p">))</span>
                                        <span class="c1"># if (nstrb,cy) in self.Gi.nodes():</span>
                                        <span class="c1">#     li2 = [(nstrb,cy),(nstrb,cy,cyo2),(nstrb,cyo2,cy)]</span>
                                        <span class="c1"># else: #no reflection on airwall</span>
                                        <span class="c1">#     li2 = [(nstrb,cy,cyo2),(nstrb,cyo2,cy)]</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                                            <span class="n">li2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nstrb</span><span class="p">,</span> <span class="n">cy</span><span class="p">)]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">li2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">nstrb</span><span class="p">,)]</span>

                                <span class="c1"># if cy==4:</span>
                                <span class="c1">#     printnstr,nstrb</span>
                                <span class="c1">#if iprint:</span>
                                <span class="c1">#     print(&quot;li1&quot;,li1)</span>
                                <span class="c1">#     print(&quot;li2&quot;,li2)</span>
                                <span class="c1">#if cy == 91:</span>
                                <span class="c1">#    print(&quot;     &quot;,li2)</span>
                                
                                <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="n">li1</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">li2</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;RR&quot;</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;RT&quot;</span>
                                                <span class="k">if</span> <span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;TR&quot;</span>
                                                <span class="k">if</span> <span class="n">i1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;TT&quot;</span>
                                                <span class="k">if</span> <span class="n">i1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                                <span class="k">if</span> <span class="n">i2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;DT&quot;</span>
                                                <span class="k">if</span> <span class="n">i2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cy</span><span class="p">:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;TD&quot;</span>
                                                <span class="k">if</span> <span class="n">i1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">cy</span><span class="p">:</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;DR&quot;</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;RD&quot;</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
                                                <span class="c1"># print&quot;DD&quot;</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
            <span class="n">Gipbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">66.</span><span class="p">)</span>
        <span class="c1"># updating the list of interactions of a given cycle</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="n">pbartmp</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span>
                       <span class="n">desc</span> <span class="o">=</span><span class="s1">&#39;update interraction list&#39;</span><span class="p">,</span>
                       <span class="n">leave</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                       <span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">pbartmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">npt</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,)]</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
            <span class="n">Gipbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="p">)</span>

        <span class="c1"># cleaning deadend Gi </span>
        <span class="c1"># if outdoor for all nodes of Gi </span>
        <span class="c1">#   if not diffraction </span>
        <span class="c1">#       if termination cycle is indoor </span>
        <span class="c1">#           or if starting point is indoor </span>
        <span class="c1"># then delete interaction </span>
        <span class="n">ldelete</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">typ</span><span class="o">==</span><span class="s1">&#39;outdoor&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># R and T </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">segtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">segtype</span><span class="o">!=</span><span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">segtype</span><span class="o">!=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)):</span>
                        <span class="n">cyend</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cyend</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]:</span>
                            <span class="c1"># if k[0]&gt;0:</span>
                            <span class="c1">#     if self.Gs.node[k[0]][&#39;name&#39;]!=&#39;AIR&#39;:</span>
                            <span class="n">ldelete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">cystart</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cystart</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]:</span>
                                <span class="c1"># if k[0]&gt;0:</span>
                                <span class="c1">#     if self.Gs.node[k[0]][&#39;name&#39;]!=&#39;AIR&#39;:</span>
                                <span class="n">ldelete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>       

        <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">ldelete</span><span class="p">)</span>
        <span class="c1"># build adjacency matrix of Gi graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gi_A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">)</span>
        <span class="c1">#store list of nodes of Gi ( for keeping order)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gi_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.filterGi"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.filterGi">[docs]</a>    <span class="k">def</span> <span class="nf">filterGi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">situ</span><span class="o">=</span><span class="s1">&#39;outdoor&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; filter Gi to manage indoor/outdoor situations</span>

<span class="sd">        Not called</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get outdoor notes</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">uout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cy</span><span class="p">])</span>
        <span class="n">cyout</span> <span class="o">=</span> <span class="n">cy</span><span class="p">[</span><span class="n">uout</span><span class="p">]</span>

        <span class="n">inter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="n">Ti</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inter</span> <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">Ri</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inter</span> <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="n">Di</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inter</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">Ti</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ti</span> <span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cyout</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cyout</span><span class="p">))]</span>
        <span class="n">Ri</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ri</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cyout</span><span class="p">)]</span>
        <span class="n">Di</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Di</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ldiffout</span><span class="p">)]</span>

        <span class="n">rinter</span> <span class="o">=</span> <span class="n">Ti</span> <span class="o">+</span> <span class="n">Ri</span> <span class="o">+</span> <span class="n">Di</span>

        <span class="n">rGi</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span> <span class="n">rinter</span><span class="p">)</span>
        <span class="n">rGi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span> <span class="o">=</span> <span class="n">rGi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rGi</span><span class="o">.</span><span class="n">pos</span></div>



<div class="viewcode-block" id="Layout.outputGi"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.outputGi">[docs]</a>    <span class="k">def</span> <span class="nf">outputGi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; filter output of Gi edges</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">        This function checks whether this sequence is feasible or not</span>
<span class="sd">        , whatever the type of nstr0 and nstr1.</span>
<span class="sd">        The feasible outputs from nstr0 to nstr1 are stored in an output field of</span>
<span class="sd">        edge (nstr0,nstr1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.util.cone.Cone.from2seg</span>
<span class="sd">        pylayers.util.cone.Cone.belong_seg</span>


<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">assert</span><span class="p">(</span><span class="s1">&#39;Gi&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

        <span class="n">oGipbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;OutputGi&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="p">)</span>
        <span class="c1"># loop over all edges of Gi</span>
        <span class="n">Nedges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">100.</span><span class="o">/</span><span class="n">Nedges</span>
        <span class="c1"># print &quot;Gi Nedges :&quot;,Nedges</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>

            <span class="c1"># if (k%100)==0:</span>
            <span class="c1"># print&quot;edge :  &quot;,k</span>
            <span class="c1"># extract  both termination interactions nodes</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">oGipbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span>

            <span class="n">i0</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># list of authorized outputs. Initialized void</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># nstr1 : segment number of central interaction</span>
            <span class="k">if</span> <span class="n">nstr1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># central interaction is a segment</span>
                <span class="n">pseg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">nstr1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># list all potential successors of interaction i1</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span> <span class="n">i1</span><span class="p">)</span>
                <span class="c1"># create a Cone object</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                <span class="c1"># if starting from segment</span>
                <span class="k">if</span> <span class="n">nstr0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pseg0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">nstr0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="c1"># if nstr0 and nstr1 are connected segments</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">nstr0</span><span class="p">),</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">nstr1</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># from 2 not connected segment</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># from 2 connected segments</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2csegs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
                <span class="c1"># if starting from a point</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nstr0</span><span class="p">])</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">fromptseg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
                    <span class="c1">#</span>

                <span class="n">ipoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">]</span>                               <span class="c1"># i0      i1     i2[x]  </span>
                <span class="c1"># Avoid to have the same diffaction point after reflection exemple :  (-10,),(245,12),(-10,) impossible </span>
                <span class="c1">#                                                                      nstr0  nstr1 </span>
                <span class="k">if</span> <span class="n">nstr0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span> 
                    <span class="n">ipoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ipoints</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">nstr0</span><span class="p">]</span> 
                <span class="c1">#ipoints = filter(lambda x: len(x) == 1, i2)</span>
                <span class="n">pipoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ipoints</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># filter tuple (R | T)</span>
                <span class="c1">#istup = filter(lambda x : type(eval(x))==tuple,i2)</span>
                <span class="c1"># map first argument segment number</span>
                <span class="c1">#isegments = np.unique(map(lambda x : eval(x)[0],istup))</span>
                <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                    <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i2</span><span class="p">)))</span>
                <span class="c1"># if nstr0 and nstr1 are adjescent segment remove nstr0 from</span>
                <span class="c1"># potential next interaction</span>
                <span class="c1"># Fix 01/2017</span>
                <span class="c1"># This is not always True if the angle between </span>
                <span class="c1"># the two adjascent segments is &lt; pi/2</span>
                <span class="n">nb_nstr0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">nstr0</span><span class="p">)</span>
                <span class="n">nb_nstr1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">nstr1</span><span class="p">)</span>
                <span class="n">common_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nb_nstr0</span><span class="p">,</span><span class="n">nb_nstr1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_point</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">num0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">common_point</span><span class="p">]</span>
                    <span class="n">num1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">common_point</span><span class="p">]</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">num0</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">num1</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">pc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">common_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">v0</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">pc</span> 
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">pc</span> 
                    <span class="n">v0n</span> <span class="o">=</span> <span class="n">v0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span><span class="o">*</span><span class="n">v0</span><span class="p">))</span>
                    <span class="n">v1n</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">v1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0n</span><span class="p">,</span><span class="n">v1n</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">isegments</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">nstr0</span> <span class="p">])</span> 
                    <span class="c1">#    filter(lambda x: x != nstr0, isegments))</span>
                <span class="c1"># there are one or more segments</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isegments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg2pts</span><span class="p">(</span><span class="n">isegments</span><span class="p">)</span>
                    <span class="n">pta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">phe</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span>
                    <span class="c1"># add difraction points</span>
                    <span class="c1"># WARNING Diffraction points are added only if a segment is seen</span>
                    <span class="c1"># it should be the case in 99% of cases</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ipoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">isegments</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ipoints</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]))</span>
                        <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pta</span><span class="p">,</span> <span class="n">pipoints</span><span class="p">))</span>
                        <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">phe</span><span class="p">,</span> <span class="n">pipoints</span><span class="p">))</span>

                    <span class="c1"># cn.show()</span>

                    <span class="c1"># if i0 == (38,79) and i1 == (135,79,23):</span>
                    <span class="c1">#     printi0,i1</span>
                    <span class="c1">#     import ipdb</span>
                    <span class="c1">#     ipdb.set_trace()</span>
                    <span class="c1"># i1 : interaction T</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1">#if ((e[0]==(53,17)) and (e[1]==(108,17,18))):</span>
                        <span class="c1">#    typ, prob = cn.belong_seg(pta, phe,visu=True)</span>
                        <span class="c1">#else:</span>
                        <span class="n">typ</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span> <span class="n">phe</span><span class="p">)</span>
                        <span class="c1"># if bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                        <span class="c1"># if ~bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;k&#39;)</span>

                    <span class="c1"># i1 : interaction R --&gt; mirror</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">Mpta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">Mphe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">typ</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">Mpta</span><span class="p">,</span> <span class="n">Mphe</span><span class="p">)</span>
                        <span class="c1"># printi0,i1</span>
                        <span class="c1"># if ((i0 == (6, 0)) &amp; (i1 == (7, 0))):</span>
                        <span class="c1">#    pdb.set_trace()</span>
                        <span class="c1"># if bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                        <span class="c1"># if ~bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;m&#39;)</span>
                        <span class="c1">#    plt.show()</span>
                        <span class="c1">#    pdb.set_trace())</span>
                    <span class="c1">########</span>
                    <span class="c1"># SOMETIMES PROBA IS 0 WHEReAS SEG IS SEEN</span>
                    <span class="c1">###########</span>
                    <span class="c1"># # keep segment with prob above a threshold</span>
                    <span class="c1"># isegkeep = isegments[prob&gt;0]</span>
                    <span class="c1"># # dict   {numint : proba}</span>
                    <span class="c1"># dsegprob = {k:v for k,v in zip(isegkeep,prob[prob&gt;0])}</span>
                    <span class="c1"># 4 lines are replaced by</span>
                    <span class="c1"># keep segment with prob above a threshold</span>
                    <span class="n">utypseg</span> <span class="o">=</span> <span class="n">typ</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="n">isegkeep</span> <span class="o">=</span> <span class="n">isegments</span><span class="p">[</span><span class="n">utypseg</span><span class="p">]</span>
                    <span class="c1"># dict   {numint : proba}</span>
                    <span class="n">dsegprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isegkeep</span><span class="p">,</span> <span class="n">prob</span><span class="p">[</span><span class="n">utypseg</span><span class="p">])}</span>
                    <span class="c1">#########</span>
                    <span class="c1"># output = filter(lambda x: x[0] in isegkeep, i2)</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isegkeep</span><span class="p">]</span>
                    <span class="c1"># probint = map(lambda x: dsegprob[x[0]], output)</span>
                    <span class="n">probint</span> <span class="o">=</span> <span class="p">[</span><span class="n">dsegprob</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>
                    <span class="c1"># dict interaction : proba</span>
                    <span class="n">dintprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">probint</span><span class="p">)}</span>

                    <span class="c1"># keep all segment above nstr1 and in Cone if T</span>
                    <span class="c1"># keep all segment below nstr1 and in Cone if R</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># central interaction is a point (nstr1 &lt;0) </span>

                <span class="c1"># 1) Simple approach</span>
                <span class="c1">#       output interaction are all visible interactions</span>
                <span class="c1"># 2) TO BE DONE</span>
                <span class="c1">#</span>
                <span class="c1">#       output of the diffraction points</span>
                <span class="c1">#       exploring</span>
                <span class="c1"># b</span>
                <span class="c1">#          + right of ISB</span>
                <span class="c1">#          + right of RSB</span>
                <span class="c1">#</span>
                <span class="c1">#  + using the wedge cone</span>
                <span class="c1">#  + using the incident cone</span>
                <span class="c1">#</span>

                <span class="n">output</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span> <span class="p">(</span><span class="n">nstr1</span><span class="p">,))</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="n">probint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nout</span><span class="p">)</span>  <span class="c1"># temporarybns</span>
                <span class="n">dintprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">probint</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">dintprob</span><span class="p">)</span></div>


<div class="viewcode-block" id="Layout.outputGi_new"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.outputGi_new">[docs]</a>    <span class="k">def</span> <span class="nf">outputGi_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">tqdmpos</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; filter output of Gi edges</span>

<span class="sd">        this version of outputGi, uses sparses matrix instead of NetworkX for MP </span>
<span class="sd">        purpose</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">        This function checks whether this sequence is feasible or not</span>
<span class="sd">        , whatever the type of nstr0 and nstr1.</span>
<span class="sd">        The feasible outputs from nstr0 to nstr1 are stored in an output field of</span>
<span class="sd">        edge (nstr0,nstr1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.util.cone.Cone.from2seg</span>
<span class="sd">        pylayers.util.cone.Cone.belong_seg</span>


<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">def</span> <span class="nf">Gspos</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2pc</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="c1">#s2pc = self.s2pc.toarray()</span>
        <span class="c1">#s2pu = self.s2pu.toarray()</span>
        <span class="c1">#p2pc = self.p2pc.toarray()</span>
        <span class="c1">#A = self.Gi_A.toarray()</span>
        
        <span class="k">assert</span><span class="p">(</span><span class="s1">&#39;Gi&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>

        <span class="n">oGipbar</span> <span class="o">=</span> <span class="n">pbar</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="n">total</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span><span class="n">leave</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;OutputGi&#39;</span><span class="p">,</span><span class="n">position</span><span class="o">=</span><span class="n">tqdmpos</span><span class="p">)</span>
        <span class="c1"># loop over all edges of Gi</span>
        <span class="n">Nedges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="mf">100.</span><span class="o">/</span><span class="n">Nedges</span>
        <span class="c1"># print &quot;Gi Nedges :&quot;,Nedges</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>

            <span class="c1"># if (k%100)==0:</span>
            <span class="c1"># print&quot;edge :  &quot;,k</span>
            <span class="c1"># extract  both termination interactions nodes</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">oGipbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cpt</span><span class="p">)</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># first interaction </span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># central interaction</span>
            <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># list of authorized outputs. Initialized void</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># nstr1 : segment number of central interaction</span>
            <span class="k">if</span> <span class="n">nstr1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># central interaction is a segment</span>
                <span class="c1"># pseg1 = self.s2pc[nstr1,:].toarray().reshape(2, 2).T</span>
                <span class="n">pseg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="p">[</span><span class="n">nstr1</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># pseg1 = self.s2pc[nstr1,:].data.reshape(2, 2).T</span>
                <span class="c1"># pseg1o = self.seg2pts(nstr1).reshape(2, 2).T</span>

                <span class="c1"># create a Cone object</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
                <span class="c1"># if starting from segment</span>
                <span class="k">if</span> <span class="n">nstr0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># pseg0 = self.s2pc[nstr0,:].toarray().reshape(2, 2).T</span>
                    <span class="n">pseg0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="p">[</span><span class="n">nstr0</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="c1"># pseg0 = self.s2pc[nstr0,:].data.reshape(2, 2).T</span>
                    <span class="c1"># pseg0o = self.seg2pts(nstr0).reshape(2, 2).T</span>

                    <span class="c1"># if nstr0 and nstr1 are connected segments</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgsg</span><span class="p">[</span><span class="n">nstr0</span><span class="p">,</span><span class="n">nstr1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># from 2 not connected segment</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># from 2 connected segments</span>
                        <span class="n">cn</span><span class="o">.</span><span class="n">from2csegs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
                <span class="c1"># if starting from a point</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">nstr0</span><span class="p">)[</span><span class="mi">0</span><span class="p">,:]</span>
                    <span class="c1"># pt = np.array(self.Gs.pos[nstr0])</span>
                    <span class="n">cn</span><span class="o">.</span><span class="n">fromptseg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>

                <span class="c1"># list all potential successors of interaction i1</span>
                <span class="n">ui2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi_no</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>
                <span class="n">ui</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi_A</span><span class="p">[</span><span class="n">ui2</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi_no</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ui</span><span class="p">]</span>
                <span class="c1"># i2 = nx.neighbors(self.Gi, i1)</span>

                <span class="c1"># how to find neighbors without network</span>
                <span class="c1"># ngi=L.Gi.nodes()</span>
                <span class="c1"># A=nx.adjacency_matrix(L.Gi)</span>
                <span class="c1"># inter = ngi[10]</span>
                <span class="c1"># u = ngi.index(inter)</span>
                <span class="c1"># ui = A[u,:].indices</span>
                <span class="c1"># neigh_inter = np.array([ngi[u] for u in ui])</span>


                <span class="n">ipoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">]</span>
                
                <span class="c1">#ipoints = filter(lambda x: len(x) == 1, i2)</span>
                <span class="c1"># pipoints = np.array([self.Gs.pos[ip[0]] for ip in ipoints]).T</span>
                <span class="n">pipoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Gspos</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ipoints</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># filter tuple (R | T)</span>
                <span class="c1">#istup = filter(lambda x : type(eval(x))==tuple,i2)</span>
                <span class="c1"># map first argument segment number</span>
                <span class="c1">#isegments = np.unique(map(lambda x : eval(x)[0],istup))</span>
                <span class="c1"># isegments = np.unique(</span>
                <span class="c1">#     filter(lambda y: y &gt; 0, map(lambda x: x[0], i2)))</span>
                <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># if nstr0 and nstr1 are adjescent segment remove nstr0 from</span>
                <span class="c1"># potential next interaction</span>
                <span class="c1"># Fix 01/2017</span>
                <span class="c1"># This is not always True if the angle between </span>
                <span class="c1"># the two adjascent segments is &lt; pi/2</span>
                <span class="c1"># nb_nstr0 = self.Gs.neighbors(nstr0)</span>
                <span class="c1"># nb_nstr1 = self.Gs.neighbors(nstr1)</span>
                <span class="c1"># nb_nstr0 = np.array([self.s2pu[nstr0,0],self.s2pu[nstr0,1]])</span>
                <span class="c1"># nb_nstr1 = np.array([self.s2pu[nstr1,0],self.s2pu[nstr1,1]])</span>
                <span class="c1"># nb_nstr0 = self.s2pu[nstr0,:].toarray()[0]</span>
                <span class="c1"># nb_nstr1 = self.s2pu[nstr1,:].toarray()[0]</span>
                
                <span class="c1"># first interaction is a point</span>
                <span class="k">if</span> <span class="n">nstr0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">nb_nstr0</span> <span class="o">=</span> <span class="p">[</span><span class="n">nstr0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nb_nstr0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span><span class="p">[</span><span class="n">nstr0</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">nb_nstr1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span><span class="p">[</span><span class="n">nstr1</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="c1"># common_point = np.intersect1d(nb_nstr0,nb_nstr1)</span>
                <span class="n">common_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr0</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr1</span><span class="p">])</span>
                <span class="c1">#print(common_point)</span>

                <span class="c1"># if len(common_point) == 1:</span>
                <span class="c1">#     pdb.set_trace()</span>
                <span class="k">if</span> <span class="n">common_point</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">num0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">common_point</span><span class="p">]</span>
                    <span class="n">num1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">common_point</span><span class="p">]</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">num0</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">,:]</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">num1</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">,:]</span>
                    <span class="n">pc</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">common_point</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">,:]</span>

                    <span class="n">v0</span> <span class="o">=</span> <span class="n">p0</span><span class="o">-</span><span class="n">pc</span> 
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-</span><span class="n">pc</span> 
                    <span class="n">v0n</span> <span class="o">=</span> <span class="n">v0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span><span class="o">*</span><span class="n">v0</span><span class="p">))</span>
                    <span class="n">v1n</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">v1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0n</span><span class="p">,</span><span class="n">v1n</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">isegments</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">nstr0</span> <span class="p">])</span> 
                    <span class="c1">#    filter(lambda x: x != nstr0, isegments))</span>
                <span class="c1"># there are one or more segments</span>
                <span class="c1"># if len(isegments) &gt; 0:</span>
                <span class="k">if</span> <span class="n">isegments</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

                    <span class="n">li1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>

                    <span class="c1"># points = self.s2pc[isegments,:].toarray().T</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="p">[</span><span class="n">isegments</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
                    <span class="c1"># points = self.s2pc[isegments,:].data.reshape(4,len(isegments))</span>
                    <span class="c1"># pointso = self.seg2pts(isegments)</span>

                    <span class="n">pta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">phe</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span>
                    <span class="c1"># add difraction points</span>
                    <span class="c1"># WARNING Diffraction points are added only if a segment is seen</span>
                    <span class="c1"># it should be the case in 99% of cases</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ipoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">isegments</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ipoints</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]))</span>
                        <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pta</span><span class="p">,</span> <span class="n">pipoints</span><span class="p">))</span>
                        <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">phe</span><span class="p">,</span> <span class="n">pipoints</span><span class="p">))</span>

                    <span class="c1"># cn.show()</span>

                    <span class="c1"># if i0 == (38,79) and i1 == (135,79,23):</span>
                    <span class="c1">#     printi0,i1</span>
                    <span class="c1">#     import ipdb</span>
                    <span class="c1">#     ipdb.set_trace()</span>
                    <span class="c1"># i1 : interaction T</span>
                    <span class="k">if</span> <span class="n">li1</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">typ</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span> <span class="n">phe</span><span class="p">)</span>
                        <span class="c1"># if bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                        <span class="c1"># if ~bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;k&#39;)</span>

                    <span class="c1"># i1 : interaction R --&gt; mirror</span>
                    <span class="k">elif</span> <span class="n">li1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">Mpta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">Mphe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">typ</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">Mpta</span><span class="p">,</span> <span class="n">Mphe</span><span class="p">)</span>
                        <span class="c1"># printi0,i1</span>
                        <span class="c1"># if ((i0 == (6, 0)) &amp; (i1 == (7, 0))):</span>
                        <span class="c1">#    pdb.set_trace()</span>
                        <span class="c1"># if bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                        <span class="c1"># if ~bs.any():</span>
                        <span class="c1">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;m&#39;)</span>
                        <span class="c1">#    plt.show()</span>
                        <span class="c1">#    pdb.set_trace())</span>
                    <span class="c1">########</span>
                    <span class="c1"># SOMETIMES PROBA IS 0 WHEREAS SEG IS SEEN</span>
                    <span class="c1">###########</span>
                    <span class="c1"># # keep segment with prob above a threshold</span>
                    <span class="c1"># isegkeep = isegments[prob&gt;0]</span>
                    <span class="c1"># # dict   {numint : proba}</span>
                    <span class="c1"># dsegprob = {k:v for k,v in zip(isegkeep,prob[prob&gt;0])}</span>
                    <span class="c1"># 4 lines are replaced by</span>
                    <span class="c1"># keep segment with prob above a threshold</span>
                    <span class="n">utypseg</span> <span class="o">=</span> <span class="n">typ</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="n">isegkeep</span> <span class="o">=</span> <span class="n">isegments</span><span class="p">[</span><span class="n">utypseg</span><span class="p">]</span>
                    <span class="c1"># dict   {numint : proba}</span>
                    <span class="n">dsegprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isegkeep</span><span class="p">,</span> <span class="n">prob</span><span class="p">[</span><span class="n">utypseg</span><span class="p">])}</span>
                    <span class="c1">#########</span>
                    <span class="c1"># output = filter(lambda x: x[0] in isegkeep, i2)</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isegkeep</span><span class="p">]</span>
                    <span class="c1"># probint = map(lambda x: dsegprob[x[0]], output)</span>
                    <span class="n">probint</span> <span class="o">=</span> <span class="p">[</span><span class="n">dsegprob</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>
                    <span class="c1"># dict interaction : proba</span>
                    <span class="n">dintprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">probint</span><span class="p">)}</span>

                    <span class="c1"># keep all segment above nstr1 and in Cone if T</span>
                    <span class="c1"># keep all segment below nstr1 and in Cone if R</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># central interaction is a point</span>

                <span class="c1"># 1) Simple approach</span>
                <span class="c1">#       output interaction are all visible interactions</span>
                <span class="c1"># 2) TO BE DONE</span>
                <span class="c1">#</span>
                <span class="c1">#       output of the diffraction points</span>
                <span class="c1">#       exploring</span>
                <span class="c1"># b</span>
                <span class="c1">#          + right of ISB</span>
                <span class="c1">#          + right of RSB</span>
                <span class="c1">#</span>
                <span class="c1">#  + using the wedge cone</span>
                <span class="c1">#  + using the incident cone</span>
                <span class="c1">#</span>

                <span class="c1"># output = nx.neighbors(self.Gi, (nstr1,))</span>
                <span class="n">uout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi_no</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">nstr1</span><span class="p">,))</span>
                <span class="n">ui</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi_A</span><span class="p">[</span><span class="n">uout</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi_no</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ui</span><span class="p">]</span>
                
                <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="n">probint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nout</span><span class="p">)</span>  <span class="c1"># temporarybns</span>
                <span class="n">dintprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="n">probint</span><span class="p">)}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">dintprob</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span></div>


<div class="viewcode-block" id="Layout.outputGi_mp"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.outputGi_mp">[docs]</a>    <span class="k">def</span> <span class="nf">outputGi_mp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; filter output of Gi edges</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        L : Layout</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Let assume a sequence (nstr0,nstr1,{nstr2A,nstr2B,...}) in a signature.</span>
<span class="sd">        This function checks whether this sequence is feasible or not</span>
<span class="sd">        , whatever the type of nstr0 and nstr1.</span>
<span class="sd">        The feasible outputs from nstr0 to nstr1 are stored in an output field of</span>
<span class="sd">        edge (nstr0,nstr1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.util.cone.Cone.from2seg</span>
<span class="sd">        pylayers.util.cone.Cone.belong_seg</span>


<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># assert(&#39;Gi&#39; in self.__dict__)</span>

        <span class="c1"># oGipbar=pbar(verbose,total=100.,leave=False,desc=&#39;OutputGi&#39;,position=tqdmpos)</span>
        <span class="c1"># # loop over all edges of Gi</span>
        <span class="c1"># Nedges = len(self.Gi.edges())</span>
        <span class="c1"># cpt = 100./Nedges</span>
        <span class="c1"># print &quot;Gi Nedges :&quot;,Nedges</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="c1">#Gi_no = [self.Gi_no]*len(e)</span>

        <span class="c1"># densify sparse matrix</span>
        <span class="c1">#aGi_A = self.Gi_A.toarray()</span>
        <span class="c1">#ap2pc = self.p2pc.toarray()</span>
        <span class="c1">#asgsg = self.sgsg.toarray()</span>
        <span class="c1">#as2pc = self.s2pc.toarray()</span>
        <span class="c1">#as2pu = self.s2pu.toarray()</span>
        
        <span class="k">global</span> <span class="n">Gi_A</span>
        <span class="k">global</span> <span class="n">Gi_no</span>
        <span class="k">global</span> <span class="n">p2pc</span> 
        <span class="k">global</span> <span class="n">sgsg</span> 
        <span class="k">global</span> <span class="n">s2pc</span> 
        <span class="k">global</span> <span class="n">s2pu</span> 
        
        <span class="n">Gi_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi_A</span>
        <span class="n">Gi_no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi_no</span>
        <span class="n">p2pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2pc</span>
        <span class="n">sgsg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgsg</span>
        <span class="n">s2pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span>
        <span class="n">s2pu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pu</span>


        <span class="c1">#Gi_A = [aGi_A]*len(e)</span>
        <span class="c1">#p2pc = [ap2pc]*len(e)</span>
        <span class="c1">#s2pc = [as2pc]*len(e)</span>
        <span class="c1">#s2pu = [as2pu]*len(e)</span>
        <span class="c1">#sgsg = [asgsg]*len(e)</span>

        <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">())</span>

        <span class="c1"># multiprocessing style</span>
        <span class="c1">#Z=zip(e, Gi_no, Gi_A, p2pc, sgsg, s2pc, s2pu)</span>
        <span class="c1">#res = pool.map(outputGi_func,Z)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">outputGi_func</span><span class="p">,</span><span class="n">Z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>




        <span class="c1"># res = pool.map(outputGi_func_test,e)</span>
        <span class="c1"># print(&#39;e&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,Gi_no)</span>
        <span class="c1"># print(&#39;no&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,Gi_A)</span>
        <span class="c1"># print(&#39;A&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,Gspos)</span>
        <span class="c1"># print(&#39;pos&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,sgsg)</span>
        <span class="c1"># print(&#39;sgsg&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,s2pc)</span>
        <span class="c1"># print(&#39;s2pc&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,s2pu)</span>
        <span class="c1"># print(&#39;s2pu&#39;)</span>
        <span class="c1"># time.sleep(1)</span>
        <span class="c1"># res = pool.map(outputGi_func_test,Z)</span>
        <span class="c1"># print(&#39;Z&#39;)</span>
        



    <span class="c1">#def outputGi_func(arg):</span>
           
        <span class="c1"># if (k%100)==0:</span>
        <span class="c1"># print&quot;edge :  &quot;,k</span>
        <span class="c1"># extract  both termination interactions nodes</span>

        <span class="c1">#for k in arg:</span>
        <span class="c1">#    Z=arg*arg</span>
        <span class="c1"># e=arg[0]</span>
        <span class="c1"># s2pc=arg[1]</span>
        <span class="c1"># Gs=arg[2]</span>
        <span class="c1"># Gi=arg[3]</span>

        <span class="c1"># i0 = e[0]</span>
        <span class="c1"># i1 = e[1]</span>
        <span class="c1"># nstr0 = i0[0]</span>
        <span class="c1"># nstr1 = i1[0]</span>
        <span class="c1"># print(i0,i1)</span>

        <span class="c1"># for k in range(1000):</span>
        <span class="c1">#     y=k*k</span>
        <span class="c1"># # list of authorized outputs. Initialized void</span>
        <span class="c1"># output = []</span>
        <span class="c1"># # nstr1 : segment number of central interaction</span>
        <span class="c1"># if nstr1 &gt; 0:</span>
        <span class="c1">#     # central interaction is a segment</span>
        <span class="c1">#     pseg1 = np.array(s2pc[nstr1,:].todense()).reshape(2, 2).T</span>
        <span class="c1">#     # create a Cone object</span>
        <span class="c1">#     cn = cone.Cone()</span>
        <span class="c1">#     # if starting from segment</span>
        <span class="c1">#     if nstr0 &gt; 0:</span>
        <span class="c1">#         pseg0 = np.array(s2pc[nstr0,:].todense()).reshape(2, 2).T</span>
        <span class="c1">#         # if nstr0 and nstr1 are connected segments</span>
        <span class="c1">#         if (len(np.intersect1d(nx.neighbors(Gs, nstr0), nx.neighbors(Gs, nstr1))) == 0):</span>
        <span class="c1">#             # from 2 not connected segment</span>
        <span class="c1">#             cn.from2segs(pseg0, pseg1)</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             # from 2 connected segments</span>
        <span class="c1">#             cn.from2csegs(pseg0, pseg1)</span>
        <span class="c1">#     # if starting from a point</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         pt = np.array(Gs.pos[nstr0])</span>
        <span class="c1">#         cn.fromptseg(pt, pseg1)</span>

        <span class="c1">#     # list all potential successors of interaction i1</span>
        <span class="c1">#     i2 = nx.neighbors(Gi, i1)</span>
        <span class="c1">#     ipoints = [x for x in i2 if len(x)==1 ]</span>
        <span class="c1">#     #ipoints = filter(lambda x: len(x) == 1, i2)</span>
        <span class="c1">#     pipoints = np.array([Gs.pos[ip[0]] for ip in ipoints]).T</span>
        <span class="c1">#     # filter tuple (R | T)</span>
        <span class="c1">#     #istup = filter(lambda x : type(eval(x))==tuple,i2)</span>
        <span class="c1">#     # map first argument segment number</span>
        <span class="c1">#     #isegments = np.unique(map(lambda x : eval(x)[0],istup))</span>
        <span class="c1">#     isegments = np.unique(</span>
        <span class="c1">#         filter(lambda y: y &gt; 0, map(lambda x: x[0], i2)))</span>
        <span class="c1">#     # if nstr0 and nstr1 are adjescent segment remove nstr0 from</span>
        <span class="c1">#     # potential next interaction</span>
        <span class="c1">#     # Fix 01/2017</span>
        <span class="c1">#     # This is not always True if the angle between </span>
        <span class="c1">#     # the two adjascent segments is &lt; pi/2</span>
        <span class="c1">#     nb_nstr0 = Gs.neighbors(nstr0)</span>
        <span class="c1">#     nb_nstr1 = Gs.neighbors(nstr1)</span>
        <span class="c1">#     common_point = np.intersect1d(nb_nstr0,nb_nstr1)</span>
        <span class="c1">#     if len(common_point) == 1:</span>
        <span class="c1">#         num0 = [x for x in nb_nstr0 if x != common_point]</span>
        <span class="c1">#         num1 = [x for x in nb_nstr1 if x != common_point]</span>
        <span class="c1">#         p0 = np.array(Gs.pos[num0[0]])</span>
        <span class="c1">#         p1 = np.array(Gs.pos[num1[0]])</span>
        <span class="c1">#         pc = np.array(Gs.pos[common_point[0]])</span>
        <span class="c1">#         v0 = p0-pc </span>
        <span class="c1">#         v1 = p1-pc </span>
        <span class="c1">#         v0n = v0/np.sqrt(np.sum(v0*v0))</span>
        <span class="c1">#         v1n = v1/np.sqrt(np.sum(v1*v1))</span>
        <span class="c1">#         if np.dot(v0n,v1n)&lt;=0:</span>
        <span class="c1">#             isegments = np.array([ x for x in isegments if x != nstr0 ]) </span>
        <span class="c1">#         #    filter(lambda x: x != nstr0, isegments))</span>
        <span class="c1">#     # there are one or more segments</span>
        <span class="c1">#     if len(isegments) &gt; 0:</span>
        <span class="c1">#         points = np.array(s2pc[isegments,:].todense()).T</span>
        <span class="c1">#         pta = points[0:2, :]</span>
        <span class="c1">#         phe = points[2:, :]</span>
        <span class="c1">#         # add difraction points</span>
        <span class="c1">#         # WARNING Diffraction points are added only if a segment is seen</span>
        <span class="c1">#         # it should be the case in 99% of cases</span>

        <span class="c1">#         if len(ipoints) &gt; 0:</span>
        <span class="c1">#             isegments = np.hstack(</span>
        <span class="c1">#                 (isegments, np.array(ipoints)[:, 0]))</span>
        <span class="c1">#             pta = np.hstack((pta, pipoints))</span>
        <span class="c1">#             phe = np.hstack((phe, pipoints))</span>

        <span class="c1">#         # cn.show()</span>

        <span class="c1">#         # if i0 == (38,79) and i1 == (135,79,23):</span>
        <span class="c1">#         #     printi0,i1</span>
        <span class="c1">#         #     import ipdb</span>
        <span class="c1">#         #     ipdb.set_trace()</span>
        <span class="c1">#         # i1 : interaction T</span>
        <span class="c1">#         if len(i1) == 3:</span>
        <span class="c1">#             typ, prob = cn.belong_seg(pta, phe)</span>
        <span class="c1">#             # if bs.any():</span>
        <span class="c1">#             #    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
        <span class="c1">#             # if ~bs.any():</span>
        <span class="c1">#             #    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;k&#39;)</span>

        <span class="c1">#         # i1 : interaction R --&gt; mirror</span>
        <span class="c1">#         if len(i1) == 2:</span>
        <span class="c1">#             Mpta = geu.mirror(pta, pseg1[:, 0], pseg1[:, 1])</span>
        <span class="c1">#             Mphe = geu.mirror(phe, pseg1[:, 0], pseg1[:, 1])</span>
        <span class="c1">#             typ, prob = cn.belong_seg(Mpta, Mphe)</span>
        <span class="c1">#             # printi0,i1</span>
        <span class="c1">#             # if ((i0 == (6, 0)) &amp; (i1 == (7, 0))):</span>
        <span class="c1">#             #    pdb.set_trace()</span>
        <span class="c1">#             # if bs.any():</span>
        <span class="c1">#             #    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
        <span class="c1">#             # if ~bs.any():</span>
        <span class="c1">#             #    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;m&#39;)</span>
        <span class="c1">#             #    plt.show()</span>
        <span class="c1">#             #    pdb.set_trace())</span>
        <span class="c1">#         ########</span>
        <span class="c1">#         # SOMETIMES PROBA IS 0 WHEREAS SEG IS SEEN</span>
        <span class="c1">#         ###########</span>
        <span class="c1">#         # # keep segment with prob above a threshold</span>
        <span class="c1">#         # isegkeep = isegments[prob&gt;0]</span>
        <span class="c1">#         # # dict   {numint : proba}</span>
        <span class="c1">#         # dsegprob = {k:v for k,v in zip(isegkeep,prob[prob&gt;0])}</span>
        <span class="c1">#         # 4 lines are replaced by</span>
        <span class="c1">#         # keep segment with prob above a threshold</span>
        <span class="c1">#         utypseg = typ != 0</span>
        <span class="c1">#         isegkeep = isegments[utypseg]</span>
        <span class="c1">#         # dict   {numint : proba}</span>
        <span class="c1">#         dsegprob = {k: v for k, v in zip(isegkeep, prob[utypseg])}</span>
        <span class="c1">#         #########</span>
        <span class="c1">#         # output = filter(lambda x: x[0] in isegkeep, i2)</span>
        <span class="c1">#         output = [x for x in i2 if x[0] in isegkeep]</span>
        <span class="c1">#         # probint = map(lambda x: dsegprob[x[0]], output)</span>
        <span class="c1">#         probint = [dsegprob[x[0]] for x in output]</span>
        <span class="c1">#         # dict interaction : proba</span>
        <span class="c1">#         dintprob = {k: v for k, v in zip(output, probint)}</span>

        <span class="c1">#         # keep all segment above nstr1 and in Cone if T</span>
        <span class="c1">#         # keep all segment below nstr1 and in Cone if R</span>

        <span class="c1"># else:</span>
        <span class="c1">#     # central interaction is a point</span>

        <span class="c1">#     # 1) Simple approach</span>
        <span class="c1">#     #       output interaction are all visible interactions</span>
        <span class="c1">#     # 2) TO BE DONE</span>
        <span class="c1">#     #</span>
        <span class="c1">#     #       output of the diffraction points</span>
        <span class="c1">#     #       exploring</span>
        <span class="c1">#     # b</span>
        <span class="c1">#     #          + right of ISB</span>
        <span class="c1">#     #          + right of RSB</span>
        <span class="c1">#     #</span>
        <span class="c1">#     #  + using the wedge cone</span>
        <span class="c1">#     #  + using the incident cone</span>
        <span class="c1">#     #</span>

        <span class="c1">#     output = nx.neighbors(Gi, (nstr1,))</span>
        <span class="c1">#     nout = len(output)</span>
        <span class="c1">#     probint = np.ones(nout)  # temporarybns</span>
        <span class="c1">#     dintprob = {k: v for k, v in zip(output, probint)}</span>

        <span class="c1"># return(i0,i1,dintprob)</span>
        <span class="c1">#self.Gi.add_edge(i0, i1, output=dintprob)</span>

        

<div class="viewcode-block" id="Layout.intercy"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.intercy">[docs]</a>    <span class="k">def</span> <span class="nf">intercy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncy</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the list of interactions seen from a cycle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ncy : cycle number( Project -&gt; save project)</span>
<span class="sd">        typ : string</span>
<span class="sd">            if &#39;source&#39; connect source cycle</span>
<span class="sd">            if &#39;target&#39; connect target cycle</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method is called at the beginning of signature evaluation in order </span>
<span class="sd">        to get the starting and ending interaction. It exploits the information </span>
<span class="sd">        contained in teh graph Gi.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># list of interactions</span>
        <span class="n">lint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="o">.</span><span class="n">node</span>

        <span class="c1"># list of tuple interactions (R|T)</span>
        <span class="n">lD</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lint</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lR</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lint</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lT</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lint</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># lD = filter(lambda x: len(x) == 1, lint)</span>
        <span class="c1"># lR = filter(lambda x: len(x) == 2, lint)</span>
        <span class="c1"># lT = filter(lambda x: len(x) == 3, lint)</span>

        <span class="c1"># visible R|T source cycle is ncy</span>

        <span class="n">lR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ncy</span><span class="p">,</span> <span class="n">lR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;source&#39;</span><span class="p">:</span>
            <span class="n">lT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ncy</span><span class="p">,</span> <span class="n">lT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span>
            <span class="n">lT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">ncy</span><span class="p">,</span> <span class="n">lT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">lT</span> <span class="o">=</span> <span class="n">lT</span>
        <span class="c1"># Finding the diffraction points</span>
        <span class="c1"># Diffraction points are different from indoor cycle and outdoor</span>
        <span class="c1"># cycles</span>
        <span class="c1">#</span>
        <span class="c1"># TODO check wedge validity.</span>
        <span class="c1">#</span>

        <span class="n">vnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span>
        <span class="n">vpoints</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vnodes</span><span class="p">)</span>
        <span class="n">lD</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">ncy</span><span class="p">:</span>
                        <span class="n">lD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,))</span>
        <span class="c1"># indoor = self.Gt.node[ncy][&#39;indoor&#39;]</span>
        <span class="c1"># if indoor:</span>
        <span class="c1">#     lD = map(lambda y : (y,),filter(lambda x : x in</span>
        <span class="c1">#                                     self.ldiffin,vpoints))</span>
        <span class="c1"># else:</span>
        <span class="c1">#     lD = map(lambda y : (y,),filter(lambda x : x in</span>
        <span class="c1">#                                     self.ldiffout,vpoints))</span>

        <span class="k">return</span> <span class="n">lR</span><span class="p">,</span> <span class="n">lT</span><span class="p">,</span> <span class="n">lD</span></div>

<div class="viewcode-block" id="Layout.show"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show layout</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        showG</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;fig&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;alphan&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="s1">&#39;alphae&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s1">&#39;node_color&#39;</span><span class="p">:</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;edge_color&#39;</span><span class="p">:</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;node_size&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
                    <span class="s1">&#39;font_size&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
                    <span class="s1">&#39;nodelist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;figsize&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                    <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="s1">&#39;cycle&#39;</span><span class="p">,</span>
                    <span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="n">lair</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;AIR&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">lair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;AIR&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;_AIR&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">lair</span> <span class="o">=</span> <span class="n">lair</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># tsg : list of segment index for mapping with self.tahe</span>
        <span class="c1">#</span>
        <span class="n">segfilt</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lair</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsg</span><span class="p">)</span>
        <span class="c1"># get the association between segment and nx edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
        <span class="n">Ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="c1"># segments = np.array(edges)[:,0]</span>
        <span class="c1"># segments are &gt;0 index so max in necesssarily</span>
        <span class="c1"># a segment number whatever the order</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>

        <span class="n">dse</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ne</span><span class="p">))}</span>

        <span class="n">edfilt</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">dse</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dse</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">segfilt</span><span class="p">))))</span>

        <span class="c1"># edgelist is to be understood as edges of Graph and not segments of</span>
        <span class="c1"># Layout</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">edgelist</span><span class="o">=</span><span class="n">edfilt</span><span class="p">)</span>

        <span class="c1"># display degree 1 nodes</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
            <span class="n">ldeg1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">print</span><span class="p">(</span><span class="n">ldeg1</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
                                 <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                 <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                                 <span class="n">nodelist</span><span class="o">=</span><span class="n">ldeg1</span><span class="p">,</span>
                                 <span class="n">edges</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">],</span>
                                 <span class="n">nodes</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">],</span>
                                 <span class="n">node_size</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;node_size&#39;</span><span class="p">],</span>
                                 <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="c1"># display degree 4 nodes</span>
        <span class="k">if</span> <span class="mi">4</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
            <span class="n">ldeg4</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">showG</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span>
                                 <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                 <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                                 <span class="n">nodelist</span><span class="o">=</span><span class="n">ldeg4</span><span class="p">,</span>
                                 <span class="n">edges</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">],</span>
                                 <span class="n">nodes</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">],</span>
                                 <span class="n">node_size</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;node_size&#39;</span><span class="p">],</span>
                                 <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span></div>

        <span class="c1">#     if k==1:</span>
        <span class="c1">#         fig,ax = self.showG(&#39;s&#39;,fig=fig,ax=ax,nodelist=ldeg,edges=False,nodes=True,node_size=50,node_color=&#39;c&#39;)</span>
        <span class="c1">#     if k==4:</span>
        <span class="c1">#         fig,ax = self.showG(&#39;s&#39;,fig=fig,ax=ax,nodelist=ldeg,nodes=False,node_size=50,node_color=&#39;b&#39;)</span>

<div class="viewcode-block" id="Layout.showG"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.showG">[docs]</a>    <span class="k">def</span> <span class="nf">showG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show the different graphs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        graph : char</span>
<span class="sd">            &#39;t&#39; : Gt &#39;r&#39; : Gr &#39;s&#39; : Gs &#39;v&#39; : Gv  &#39;i&#39; : Gi</span>
<span class="sd">        fig : matplotlib figure</span>
<span class="sd">            []</span>
<span class="sd">        ax : matplotlib figure</span>
<span class="sd">            []</span>
<span class="sd">        show : boolean</span>
<span class="sd">            False</span>
<span class="sd">        nodes : boolean</span>
<span class="sd">            False</span>
<span class="sd">        edges : boolean</span>
<span class="sd">            True</span>
<span class="sd">        airwalls | aw: boolean</span>
<span class="sd">            display airwalls (False)</span>
<span class="sd">        subseg: boolean</span>
<span class="sd">            display subsegments (False)</span>
<span class="sd">        slab : boolean</span>
<span class="sd">            display color and width of slabs (False)</span>
<span class="sd">        labels : boolean |list</span>
<span class="sd">            display graph labels (False)</span>
<span class="sd">            if list precise label of which cycle to display</span>
<span class="sd">            (e.g. [&#39;t&#39;])</span>
<span class="sd">        alphan : float</span>
<span class="sd">            transparency of nodes (1.0)</span>
<span class="sd">        alphae : float</span>
<span class="sd">            transparency of edges (1.0)</span>
<span class="sd">        width : float</span>
<span class="sd">            line width (2)</span>
<span class="sd">        node_color: string</span>
<span class="sd">            w</span>
<span class="sd">        posnode_color: string</span>
<span class="sd">            positive node color (k)</span>
<span class="sd">        negnode_color: string</span>
<span class="sd">            negative node color (b)</span>
<span class="sd">        edge_color : string</span>
<span class="sd">            k</span>
<span class="sd">        node_size : float</span>
<span class="sd">            20</span>
<span class="sd">        font_size : float</span>
<span class="sd">            15,</span>
<span class="sd">        nodelist : list</span>
<span class="sd">            list of nodes to be displayed (all)</span>
<span class="sd">        edgelist : list</span>
<span class="sd">            list of edges to be displayed (all)</span>
<span class="sd">        mode : string</span>
<span class="sd">            &#39;cycle&#39; | &#39;none&#39; | &#39;room&#39;</span>
<span class="sd">        alphacy : string</span>
<span class="sd">            transparency of cycles (0.8)</span>
<span class="sd">        colorcy :</span>
<span class="sd">            &#39;#abcdef&#39;</span>
<span class="sd">        linter : list</span>
<span class="sd">            list of interaction for Gi</span>
<span class="sd">            [&#39;RR&#39;,&#39;TT&#39;,&#39;RT&#39;,&#39;TR&#39;,&#39;RD&#39;,&#39;DR&#39;,&#39;TD&#39;,&#39;DT&#39;,&#39;DD&#39;]</span>
<span class="sd">        show0 : boolean</span>
<span class="sd">            If true display connection to cycle  0 of Gt (False)</span>
<span class="sd">        eded : boolean</span>
<span class="sd">            True</span>
<span class="sd">        ndnd : boolean</span>
<span class="sd">            True</span>
<span class="sd">        nded : boolean</span>
<span class="sd">            True</span>
<span class="sd">        width : int</span>
<span class="sd">            2</span>
<span class="sd">        nodelist : list</span>
<span class="sd">            []</span>
<span class="sd">        diffraction :boolean </span>
<span class="sd">            False</span>


<span class="sd">        defaults = {&#39;show&#39;: False,</span>
<span class="sd">                    &#39;fig&#39;: [],</span>
<span class="sd">                    &#39;ax&#39;: [],</span>
<span class="sd">                    &#39;nodes&#39;: False,</span>
<span class="sd">                    &#39;edges&#39;: True,</span>
<span class="sd">                    &#39;sllist&#39;:[],</span>
<span class="sd">                    &#39;airwalls&#39;: False,</span>
<span class="sd">                    &#39;subseg&#39;: False,</span>
<span class="sd">                    &#39;slab&#39;: True,</span>
<span class="sd">                    &#39;labels&#39;: False,</span>
<span class="sd">                    &#39;alphan&#39;: 1.0,</span>
<span class="sd">                    &#39;alphae&#39;: 1.0,</span>
<span class="sd">                    &#39;width&#39;: 2,</span>
<span class="sd">                    &#39;node_color&#39;:&#39;w&#39;,</span>
<span class="sd">                    &#39;edge_color&#39;:&#39;k&#39;,</span>
<span class="sd">                    &#39;node_size&#39;:20,</span>
<span class="sd">                    &#39;font_size&#39;:15,</span>
<span class="sd">                    &#39;nodelist&#39;: [],</span>
<span class="sd">                    &#39;edgelist&#39;: [],</span>
<span class="sd">                    &#39;figsize&#39;: (5,5),</span>
<span class="sd">                    &#39;mode&#39;:&#39;nocycle&#39;,</span>
<span class="sd">                    &#39;alphacy&#39;:0.8,</span>
<span class="sd">                    &#39;colorcy&#39;:&#39;abcdef&#39;,</span>
<span class="sd">                    &#39;linter&#39; : [&#39;RR&#39;,&#39;TT&#39;,&#39;RT&#39;,&#39;TR&#39;,&#39;RD&#39;,&#39;DR&#39;,&#39;TD&#39;,&#39;DT&#39;,&#39;DD&#39;],</span>
<span class="sd">                    &#39;show0&#39;:False,</span>
<span class="sd">                    &#39;axis&#39;:False,</span>
<span class="sd">                    &#39;overlay&#39;:False,</span>
<span class="sd">                    &#39;diffraction&#39;:False</span>
<span class="sd">                    }</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import  *</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;TA-Office.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; L.dumpr()</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure(figsize=(10,10))</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(221)</span>
<span class="sd">        &gt;&gt;&gt; fig,ax = L.showG(&#39;s&#39;,fig=fig,ax=ax)</span>
<span class="sd">        &gt;&gt;&gt; tis = plt.title(&quot;Gs&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(222)</span>
<span class="sd">        &gt;&gt;&gt; fig,ax = L.showG(&#39;t&#39;,fig=fig,ax=ax)</span>
<span class="sd">        &gt;&gt;&gt; tit = plt.title(&quot;Gt&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(223)</span>
<span class="sd">        &gt;&gt;&gt; fig,ax = L.showG(&#39;r&#39;,fig=fig,ax=ax)</span>
<span class="sd">        &gt;&gt;&gt; tic = plt.title(&quot;Gr&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax = fig.add_subplot(224)</span>
<span class="sd">        &gt;&gt;&gt; fig,ax = L.showG(&#39;v&#39;,fig=fig,ax=ax)</span>
<span class="sd">        &gt;&gt;&gt; tiv = plt.title(&quot;Gv&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.util.graphutil.draw</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;fig&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;edges&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;sllist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;airwalls&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;aw&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;subseg&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;slab&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;alphan&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="s1">&#39;alphae&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s1">&#39;node_color&#39;</span><span class="p">:</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;edge_color&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;node_size&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
                    <span class="s1">&#39;font_size&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
                    <span class="s1">&#39;nodelist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;edgelist&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;figsize&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                    <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="s1">&#39;nocycle&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;alphacy&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>
                    <span class="s1">&#39;colorcy&#39;</span><span class="p">:</span> <span class="s1">&#39;#abcdef&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;lvis&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;nn&#39;</span><span class="p">,</span> <span class="s1">&#39;ne&#39;</span><span class="p">,</span> <span class="s1">&#39;ee&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;linter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;RR&#39;</span><span class="p">,</span> <span class="s1">&#39;TT&#39;</span><span class="p">,</span> <span class="s1">&#39;RT&#39;</span><span class="p">,</span> <span class="s1">&#39;TR&#39;</span><span class="p">,</span> <span class="s1">&#39;RD&#39;</span><span class="p">,</span> <span class="s1">&#39;DR&#39;</span><span class="p">,</span> <span class="s1">&#39;TD&#39;</span><span class="p">,</span> <span class="s1">&#39;DT&#39;</span><span class="p">,</span> <span class="s1">&#39;DD&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;show0&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;overlay&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;diffraction&#39;</span><span class="p">:</span> <span class="bp">False</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;aw&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;airwalls&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;aw&#39;</span><span class="p">]</span>
        <span class="c1"># overriding first argument graph</span>
        <span class="k">if</span> <span class="s1">&#39;graph&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span>

        <span class="c1"># get color dictionnary from pyutil</span>

        <span class="n">cold</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">coldict</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">dis_nodes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">dis_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dis_nodes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dis_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#</span>
        <span class="c1"># s : structure graph</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>

            <span class="c1"># not efficient</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span>

            <span class="c1"># lss = filter(lambda x: self.Gs.node[x].has_key(&#39;ss_name&#39;),self.Gs.nodes())</span>
            <span class="c1"># lss = filter(lambda x: len(self.Gs.node[x][&#39;ss_name&#39;])&gt;0,lss)</span>

            <span class="c1"># keep track of segments already printed</span>

            <span class="n">nodelistbkup</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodelist&#39;</span><span class="p">]</span>
            <span class="n">edgelistbkup</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span>
            <span class="n">widthbkup</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span>
            <span class="n">nodecolbkup</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sllist</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sllist&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">sllist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

            <span class="c1">#</span>
            <span class="c1"># Draw segment slab per slab with proper linewidth and color </span>
            <span class="c1">#</span>
            <span class="k">for</span> <span class="n">lmat</span> <span class="ow">in</span> <span class="n">sllist</span><span class="p">:</span>
                <span class="c1">#print(lmat)</span>
                <span class="n">lseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">lmat</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">lseg</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">lseg2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lseg</span><span class="p">]</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">lseg2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slab&#39;</span><span class="p">]:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]]</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">dis_nodes</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodelistbkup</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">widthbkup</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodecolbkup</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgelistbkup</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;subseg&#39;</span><span class="p">]:</span>
                <span class="c1">#</span>
                <span class="c1"># Display doors and windows subsegments with a slight offset</span>
                <span class="c1">#</span>
                <span class="n">cold</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">coldict</span><span class="p">()</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseg</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">ss</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">ss</span><span class="p">]:</span>
                        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                        <span class="n">np1</span><span class="p">,</span> <span class="n">np2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">np2</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                        <span class="n">xoff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">yoff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">norm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">xoff</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">yoff</span><span class="p">,</span>
                                          <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># t : graph of cycles</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;show0&#39;</span><span class="p">]:</span>
                <span class="c1"># filter out the 0 cycle</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
                <span class="n">nodf</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
                <span class="n">edf</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodf</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="s1">&#39;t&#39;</span> <span class="ow">in</span> <span class="n">dis_nodes</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="c1">#</span>
        <span class="c1"># r : graph of rooms</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span>
                                                   <span class="n">nodes</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">alphacy</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                                                   <span class="n">fig</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="n">dis_nodes</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="c1">#</span>
        <span class="c1"># v : visibility graph</span>
        <span class="c1"># In blue : segment segment</span>
        <span class="c1"># In red  : point point (Diffraction)</span>
        <span class="c1"># In green : point segment</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>

            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gv</span>
            <span class="n">G</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># nodes of Gv are nodes of Gs</span>
            <span class="n">G</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>

            <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="n">rle</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
            <span class="n">eded</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rle</span><span class="p">)</span>
            <span class="n">ndnd</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rle</span><span class="p">)</span>
            <span class="n">nded</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(((</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">|</span>
                                     <span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))),</span> <span class="n">rle</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">dis_nodes</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="s1">&#39;ee&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lvis&#39;</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eded</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;node_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;nn&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lvis&#39;</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndnd</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;ne&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lvis&#39;</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nded</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># i :  interaction graph</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;i&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>

            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>

            <span class="c1">#</span>
            <span class="c1"># Parsing the type of interactions</span>
            <span class="c1">#</span>

            <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>

            <span class="c1"># range len edges</span>

            <span class="n">rle</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>

            <span class="n">DD</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
                                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">RR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span>
                                   <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">TT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span>
                                   <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">RT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span>
                                   <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">TR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span>
                                   <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">RD</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span>
                                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">TD</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span>
                                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">DR</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
                                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">DT</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
                                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">rle</span><span class="p">)</span>

            <span class="n">tabcol</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;maroon&#39;</span><span class="p">,</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">li</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;i&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">dis_nodes</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">inter</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linter&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">inter</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">li</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>
                    <span class="c1"># ndlist = map(lambda x: edges[x][0],kwargs[&#39;edgelist&#39;])+\</span>
                    <span class="c1">#          map(lambda x: edges[x][1],kwargs[&#39;edgelist&#39;])</span>
                    <span class="n">ndlist</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">])</span> <span class="o">+</span>\
                        <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">])</span>
                    <span class="c1"># keep only unique interaction</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="p">[</span><span class="n">unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ndlist</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">]</span>

                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodelist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tabcol</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">legtxt</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Gs&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">li</span>
            <span class="c1"># plt.legend(legtxt)</span>
        <span class="c1">#</span>
        <span class="c1"># w :  waypoint graph</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>

            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edge_color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span>
                                                   <span class="n">nodes</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">alphacy</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                                                   <span class="n">fig</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fig&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">],</span> <span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgelist&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cycle&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ncy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alphacy&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;colorcy&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
                        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>
                        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;room&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">nro</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nro</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
                        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span>
                        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;overlay&#39;</span><span class="p">]:</span>
            <span class="n">imok</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">pro</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRIMAGE&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_file&#39;</span><span class="p">]))</span>
                <span class="n">imok</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">imok</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;v&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;flip v&quot;</span><span class="p">)</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">FLIP_LEFT_RIGHT</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;h&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_flip&#39;</span><span class="p">]:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">FLIP_TOP_BOTTOM</span><span class="p">)</span>
                    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;flip h&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">()</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span>
                                    <span class="s1">&#39;overlay_axis&#39;</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;diffraction&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
                <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnss</span><span class="p">])</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lnss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pta</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_showGv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; show graph Gv (visibility)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        display</span>
<span class="sd">        fig</span>
<span class="sd">        ax</span>
<span class="sd">        nodes    : boolean</span>
<span class="sd">            display nodes</span>
<span class="sd">        edges    : boolean</span>
<span class="sd">            display edges</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : figure instance</span>
<span class="sd">        ax  : axes instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;eded&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;ndnd&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;nded&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">uneg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">nodes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">upos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">nodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">upos</span><span class="p">,</span>
                                   <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">uneg</span><span class="p">,</span>
                                   <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

        <span class="n">ndnd</span><span class="p">,</span> <span class="n">nded</span><span class="p">,</span> <span class="n">eded</span> <span class="o">=</span> <span class="n">gru</span><span class="o">.</span><span class="n">edgetype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;eded&#39;</span><span class="p">]:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                                   <span class="n">edgelist</span><span class="o">=</span><span class="n">eded</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ndnd&#39;</span><span class="p">]:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                                   <span class="n">edgelist</span><span class="o">=</span><span class="n">ndnd</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nded&#39;</span><span class="p">]:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                                   <span class="n">edgelist</span><span class="o">=</span><span class="n">nded</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="Layout.waypointGw"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.waypointGw">[docs]</a>    <span class="k">def</span> <span class="nf">waypointGw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nroom1</span><span class="p">,</span> <span class="n">nroom2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get the waypoint between room1 and room2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        nroom1</span>
<span class="sd">        nroom2</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout(&#39;TA-Office.lay&#39;)</span>
<span class="sd">            &gt;&gt;&gt; L.build()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        nodes of Gw are no longer room number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rooms</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="p">,</span> <span class="n">nroom1</span><span class="p">,</span> <span class="n">nroom2</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">])</span></div>

<div class="viewcode-block" id="Layout.thwall"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.thwall">[docs]</a>    <span class="k">def</span> <span class="nf">thwall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offx</span><span class="p">,</span> <span class="n">offy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a list of wall tuples (Transit.world format )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        offx</span>
<span class="sd">        offy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        walls : list of wall tuples  (Transit format)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;DLR.lay&#39;)</span>
<span class="sd">        &gt;&gt;&gt; walls = L.thwall(0,0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">walls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">keyn</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
                <span class="n">pta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">phe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">nb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">pn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nd</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nd</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nd</span><span class="p">][</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">thick</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sl</span><span class="p">[</span><span class="s1">&#39;lthick&#39;</span><span class="p">])</span>

                <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pta</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">pn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pn</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">thick</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offx</span><span class="p">,</span> <span class="n">offy</span><span class="p">])</span>

                <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phe</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">pn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pn</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">thick</span> <span class="o">/</span> <span class="mf">2.</span>  <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offx</span><span class="p">,</span> <span class="n">offy</span><span class="p">])</span>

                <span class="n">p3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phe</span><span class="p">)</span> <span class="o">-</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">pn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pn</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">thick</span> <span class="o">/</span> <span class="mf">2.</span>  <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offx</span><span class="p">,</span> <span class="n">offy</span><span class="p">])</span>

                <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pta</span><span class="p">)</span> <span class="o">-</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">pn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pn</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">thick</span> <span class="o">/</span> <span class="mf">2.</span>  <span class="o">+</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offx</span><span class="p">,</span> <span class="n">offy</span><span class="p">])</span>

                <span class="n">wall</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p3</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p4</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">transition</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;AIR&#39;</span><span class="p">:</span>
                    <span class="n">walls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wall</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">walls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.ptin"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.ptin">[docs]</a>    <span class="k">def</span> <span class="nf">ptin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))):</span>
        <span class="sd">&quot;&quot;&quot; check if a point is in the Layout</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        pt : point (ndarray)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        boolean : True if inside</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        ispoint</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>

        <span class="c1"># being   in [xmin xmax]</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># being   in [ymin ymax]</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">c0</span> <span class="o">&amp;</span> <span class="n">c1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.ptGs2cy"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.ptGs2cy">[docs]</a>    <span class="k">def</span> <span class="nf">ptGs2cy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Gs node to cycle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        upt : point (ndarray)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ncy : cycle number</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            If a cycle contains the Gs pointt this function returns the cycle(s) number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">cy</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nseg</span><span class="p">:</span>
                <span class="n">cy</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ptGs2cy</span><span class="p">(</span><span class="n">nn</span><span class="p">))</span>
            <span class="n">cy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cy</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">cy</span></div>

<div class="viewcode-block" id="Layout.pt2cy"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.pt2cy">[docs]</a>    <span class="k">def</span> <span class="nf">pt2cy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))):</span>
        <span class="sd">&quot;&quot;&quot; point to cycle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pt : point (ndarray)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ncy : cycle number</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            If a cycle contains point pt this function returns the cycle number</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Layout.cy2pt</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ptsh</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cycle_exists</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">ncy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ncy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">criter1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">ptsh</span><span class="p">)</span>
                <span class="n">criter2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ptsh</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">criter1</span> <span class="ow">or</span> <span class="n">criter2</span><span class="p">):</span>
                    <span class="n">cycle_exists</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">return</span><span class="p">(</span><span class="n">ncy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cycle_exists</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not in any cycle&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.cy2pt"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.cy2pt">[docs]</a>    <span class="k">def</span> <span class="nf">cy2pt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mf">1.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a point into a given cycle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cy : int</span>
<span class="sd">            cycle number</span>

<span class="sd">        h : float</span>
<span class="sd">            point height</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        point  : nd.array</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        Layout.pt2cy</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">cy</span><span class="p">]))</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pt</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
            <span class="k">return</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;cycle &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cy</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; not in self.Gt&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.pt2ro"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.pt2ro">[docs]</a>    <span class="k">def</span> <span class="nf">pt2ro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))):</span>
        <span class="sd">&quot;&quot;&quot; point to room</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pt : point (ndarray)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nr : Room number</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            If a room contains point pt this function returns the room number</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ptsh</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ptshinroom</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ptsh</span><span class="p">)</span>\
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">ptsh</span><span class="p">):</span>
                <span class="n">ptshinroom</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ptshinroom</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not in any room&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.seg2ro"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.seg2ro">[docs]</a>    <span class="k">def</span> <span class="nf">seg2ro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return room number of a point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        seg : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nr : Room number</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If a room contains point pt this function returns the room number</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># if seg in self.Gt.node[self.Gr.node[nr][&#39;cycle&#39;]][&#39;vnodes&#39;]:</span>
            <span class="n">ncy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cycle</span><span class="p">:</span>
                <span class="n">rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rooms</span></div>

<div class="viewcode-block" id="Layout.room2segments"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.room2segments">[docs]</a>    <span class="k">def</span> <span class="nf">room2segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the segments of a room</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        room : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        seg : list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># old vnodes was there</span>
            <span class="n">ncy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">room</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">]</span><span class="o">.</span><span class="n">cycle</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">room</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not in not on Gr&quot;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>

<div class="viewcode-block" id="Layout.room2nodes"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.room2nodes">[docs]</a>    <span class="k">def</span> <span class="nf">room2nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the nodes of a room</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        room : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        nod : sorted list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ncy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">room</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span>
            <span class="n">nod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ncy</span><span class="p">]</span><span class="o">.</span><span class="n">cycle</span>
            <span class="c1">#nod = self.Gt.node[self.Gr.node[room][&#39;cycle&#39;]][&#39;vnodes&#39;]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">room</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not in not on Gr&quot;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nod</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">nod</span> <span class="o">=</span> <span class="n">nod</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">nod</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>

<div class="viewcode-block" id="Layout.get_diffslab"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.get_diffslab">[docs]</a>    <span class="k">def</span> <span class="nf">get_diffslab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npt</span><span class="p">,</span><span class="n">lz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get the 2 slabs associated to a diffraction point </span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">            lnpt : diffraction point numbers (node of Gs)</span>
<span class="sd">            lz   : array of candidate heights of the diffraction point </span>

<span class="sd">            Info</span>
<span class="sd">            ---- </span>
<span class="sd">            As a diffraction point may involve iso segments the nature </span>
<span class="sd">            of the diffraction interaction depends on a height parameter</span>
<span class="sd">            This function extacts the couple of slab from this information</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            - a list of 2-segments list. the length of this list == length of lz</span>
<span class="sd">            - a list of slab tuples.  the length of this list == length of lz</span>

<span class="sd">            [[443, 529], [444, 530]]</span>
<span class="sd">            [[&#39;WALL&#39;, &#39;WALL&#39;], [&#39;AIR&#39;, &#39;AIR&#39;]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">npt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">),</span> <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;npt not a diffraction point&#39;</span><span class="p">)</span>
        <span class="n">lcy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">[</span><span class="n">npt</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">llz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lz</span><span class="p">)</span>
        <span class="n">dz_seg</span><span class="o">=</span> <span class="p">{</span><span class="n">z</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">llz</span><span class="p">)}</span>
        <span class="n">dz_sl</span><span class="o">=</span> <span class="p">{</span><span class="n">z</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">llz</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">lcy</span><span class="p">:</span> 
            <span class="n">vn</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span><span class="p">)</span>   
            <span class="n">lneig_pt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span>
            <span class="n">lseg</span> <span class="o">=</span> <span class="n">lneig_pt</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span>
            <span class="n">lseg_valid</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lseg</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lseg_valid</span><span class="p">:</span>
                <span class="n">zsup</span> <span class="o">=</span> <span class="n">lz</span> <span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">zinf</span> <span class="o">=</span> <span class="n">lz</span> <span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">z</span>    <span class="o">=</span> <span class="n">zsup</span> <span class="o">&amp;</span> <span class="n">zinf</span> 
                <span class="n">uz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># fill dz_seg at the correct height with a lseg_valid </span>
                <span class="c1"># and simulnaneously </span>
                <span class="c1"># fill dz_sl at the correct height with correspondong slab</span>
                <span class="p">[(</span><span class="n">dz_seg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">dz_sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]))</span>
                                                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uz</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dz_seg</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span><span class="n">dz_sl</span><span class="o">.</span><span class="n">values</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_find_diffractions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">difftol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span><span class="n">tqdmkwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot; find diffractions points of the Layout</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        difftol : float</span>

<span class="sd">            tolerance in radians</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Update self.ddiff {nseg : ([ncy1,ncy2],wedge_angle)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dangles = self.get_Gt_angles()</span>
        <span class="c1">#</span>
        <span class="c1"># Problem here point number are converted into float64</span>

        <span class="k">if</span> <span class="n">tqdmkwargs</span><span class="o">==</span><span class="p">{}:</span>
            <span class="n">tqdmkwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="mf">100.</span><span class="p">,</span>
                        <span class="s1">&#39;desc&#39;</span><span class="p">:</span><span class="s1">&#39;find_diffractions&#39;</span><span class="p">}</span>

        <span class="n">dangles</span> <span class="o">=</span> <span class="p">{</span><span class="n">cy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geu</span><span class="o">.</span><span class="n">get_pol_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">cy</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]))</span>
                   <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">cy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">}</span>

        <span class="c1">#</span>
        <span class="c1"># The candidate points for being diffraction points have degree 1 or 2</span>
        <span class="c1"># A point diffracts toward one or several cycles</span>
        <span class="c1">#</span>
        <span class="c1">#ldiff = list(np.hstack((self.degree[1],self.degree[2])).astype(&#39;int&#39;))</span>
        <span class="n">lpnt</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
            <span class="n">cpt</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lpnt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">tqdmkwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lpnt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mf">100.</span><span class="o">*</span><span class="n">cpt</span><span class="p">)</span>
            <span class="c1"># list of cycles associated with point k</span>
            <span class="n">lcyk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;ncycles&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcyk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Subgraph of connected cycles around k</span>
                <span class="n">Gtk</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">,</span> <span class="n">lcyk</span><span class="p">)</span>
                <span class="c1"># ordered list of connections between cycles</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lccyk</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">Gtk</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>

                <span class="c1"># list of segment neighbours</span>
                <span class="n">neigh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="c1"># sega : list of air segment in neighors</span>
                <span class="n">sega</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neigh</span> <span class="k">if</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;AIR&#39;</span> <span class="ow">or</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)]</span>

                <span class="n">sega_iso</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sega</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;iso&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">sega_eff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sega</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sega_iso</span><span class="p">)))</span>
                <span class="n">nsector</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sega</span><span class="p">)</span>

                <span class="n">dsector</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsector</span><span class="p">)}</span>
                <span class="c1">#</span>
                <span class="c1"># team building algo</span>
                <span class="c1">#</span>
                <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># if k ==-44:</span>
                <span class="c1">#     pdb.set_trace()</span>
                <span class="k">for</span> <span class="n">ccy</span> <span class="ow">in</span> <span class="n">lccyk</span><span class="p">:</span>

                    <span class="c1">#segsep = self.Gt[ccy[0]][ccy[1]][&#39;segment&#39;][0]</span>
                    <span class="n">segsep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">ccy</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">ccy</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;segment&#39;</span><span class="p">]</span>
                    <span class="c1"># filter only segments connected to point k (neigh)</span>
                    <span class="n">lvseg</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">segsep</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lvseg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lvseg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">sega_eff</span><span class="p">):</span>  <span class="c1"># same sector</span>
                        <span class="n">dsector</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># change sector</span>
                        <span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">nsector</span>
                        <span class="n">dsector</span><span class="p">[</span><span class="n">ct</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                    <span class="c1"># typslab = self.Gs.node[segsep][&#39;name&#39;]</span>
                    <span class="c1"># if (typslab==&#39;AIR&#39; or typslab==&#39;_AIR&#39;): # same sector</span>
                        <span class="c1"># dsector[ct].append(ccy[1])</span>
                    <span class="c1"># else: # change sector</span>
                        <span class="c1"># ct=(ct+1)%nsector</span>
                        <span class="c1"># dsector[ct].append(ccy[1])</span>
                        <span class="c1"># lcy2.append(ccy[1])</span>
                        <span class="c1"># lcy1,lcy2 = lcy2,lcy1</span>

                <span class="n">dagtot</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsector</span><span class="p">)}</span>
                <span class="n">save</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dsector</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="n">dsector</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
                        <span class="n">da</span> <span class="o">=</span> <span class="n">dangles</span><span class="p">[</span><span class="n">cy</span><span class="p">]</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">save</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cy</span><span class="p">,</span> <span class="n">da</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">]))</span>
                        <span class="n">dagtot</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dagtot</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="n">da</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dagtot</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dagtot</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">difftol</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dsector</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">dagtot</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                        <span class="k">break</span>

                <span class="c1"># if agtot1 &gt; (np.pi+tol):</span>
                <span class="c1">#     self.ddiff[k]=(lcy1,agtot1)</span>
                <span class="c1"># elif 2*np.pi-agtot1 &gt; (np.pi+tol):</span>
                <span class="c1">#     self.ddiff[k]=(lcy2,2*np.pi-agtot1)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># diffraction by half-plane detected</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ddiff</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lcyk</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>


<div class="viewcode-block" id="Layout.buildGr"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.buildGr">[docs]</a>    <span class="k">def</span> <span class="nf">buildGr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; build the graph of rooms Gr</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        adjascent rooms are connected</span>

<span class="sd">        Gr is at startup a deep copy of Gt</span>

<span class="sd">        The difficulty here is to take into account the AIR transition</span>
<span class="sd">        segments</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">e</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;indoor&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;indoor&#39;</span><span class="p">]):</span>

                <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;segment&#39;</span><span class="p">]</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                <span class="n">trans_seg</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">seg</span> 
                             <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;transition&#39;</span><span class="p">])</span>
                             <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">trans_seg</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],{</span><span class="s1">&#39;segment&#39;</span><span class="p">:</span><span class="n">trans_seg</span><span class="p">})</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">deg</span> <span class="k">if</span> <span class="n">deg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Layout.buildGw"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.buildGw">[docs]</a>    <span class="k">def</span> <span class="nf">buildGw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; build Graph of waypaths</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        buildGr</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        for all edges of Gr (adjascent room)</span>
<span class="sd">            if room1 and room2 have a common transition</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Gw&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">d_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>  <span class="c1"># for numerotation of Gw nodes</span>
        <span class="n">d_id_index</span> <span class="o">=</span> <span class="n">d_id</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">():</span>  <span class="c1"># iterator on Gr edges</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;room&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;door&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;room&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;door&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>

            <span class="c1"># transitions of room e[0]</span>
            <span class="c1"># trans1 = self.Gr.node[e[0]][&#39;segment&#39;]</span>
            <span class="c1"># # transitions of room e[1]</span>
            <span class="c1"># trans2 = self.Gr.node[e[1]][&#39;segment&#39;]</span>
            <span class="c1"># Id = np.intersect1d(trans1, trans2)[0]  # list of common doors</span>
            <span class="c1"># import ipdb</span>
            <span class="c1"># ipdb.set_trace()</span>
            <span class="n">Ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s1">&#39;segment&#39;</span><span class="p">]</span>
            <span class="c1"># here is supposed that 2 room may have more than 1 door in common</span>
            <span class="k">for</span> <span class="n">Id</span> <span class="ow">in</span> <span class="n">Ids</span><span class="p">:</span>
                <span class="n">unode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">Id</span><span class="p">)</span>  <span class="c1"># get edge number of common doors</span>
                <span class="n">up0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">unode</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">up1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">unode</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">Id</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="n">pn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">Id</span><span class="p">][</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">thick</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">sl</span><span class="p">[</span><span class="s1">&#39;lthick&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.2</span>

                <span class="c1"># for &quot;&quot;doors&quot;&quot; extra waypoints points are added </span>
                <span class="c1"># in front and back of the aperture.</span>
                <span class="c1"># this is not done for AIR slabs</span>
                <span class="k">if</span> <span class="s1">&#39;AIR&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span> <span class="p">:</span> 

                    <span class="c1"># middle of the common door</span>
                    <span class="n">pdoor0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">up0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pn</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">thick</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">up1</span><span class="p">)</span> <span class="o">+</span> <span class="n">pn</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">thick</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
                    <span class="n">pdoor1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">up0</span><span class="p">)</span> <span class="o">-</span> <span class="n">pn</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">thick</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">up1</span><span class="p">)</span> <span class="o">-</span> <span class="n">pn</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">thick</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
                    <span class="n">P0</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pdoor0</span><span class="p">)</span>
                    <span class="n">P1</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">pdoor1</span><span class="p">)</span>

                    <span class="n">ep0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">ep1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">P0</span><span class="p">):</span>
                        <span class="n">upd0</span> <span class="o">=</span> <span class="n">d_id_index</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">upd0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdoor0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">upd0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;room&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;door&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
                        <span class="c1"># if self.seginline(pdoor0,ep0).shape[1] &lt;= 1:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">upd0</span><span class="p">)])</span>
                        <span class="n">d_id_index</span> <span class="o">=</span> <span class="n">d_id_index</span> <span class="o">+</span> <span class="mi">1</span>

                        <span class="n">upd1</span> <span class="o">=</span> <span class="n">d_id_index</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">upd1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdoor1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">upd1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;room&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;door&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
                        <span class="c1"># if self.seginline(pdoor1,ep1).shape[1] &lt;= 1:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">upd1</span><span class="p">)])</span>
                        <span class="n">d_id_index</span> <span class="o">=</span> <span class="n">d_id_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">upd0</span> <span class="o">=</span> <span class="n">d_id_index</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">upd0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdoor0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">upd0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;room&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;door&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
                        <span class="c1"># if self.seginline(pdoor0,ep1).shape[1] &lt;= 1:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">upd0</span><span class="p">)])</span>
                        <span class="n">d_id_index</span> <span class="o">=</span> <span class="n">d_id_index</span> <span class="o">+</span> <span class="mi">1</span>

                        <span class="n">upd1</span> <span class="o">=</span> <span class="n">d_id_index</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">upd1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdoor1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">upd1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;room&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;door&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
                        <span class="c1"># if self.seginline(pdoor1,ep0).shape[1] &lt;= 1:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">upd1</span><span class="p">)])</span>
                        <span class="n">d_id_index</span> <span class="o">=</span> <span class="n">d_id_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">upd0</span><span class="p">,</span> <span class="n">upd1</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Gw</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span></div>



<div class="viewcode-block" id="Layout.editor"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.editor">[docs]</a>    <span class="k">def</span> <span class="nf">editor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; invoke interactive layout graphical editor</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        point edition</span>

<span class="sd">            m  toggle point edition mode  (CP : Create Point)</span>

<span class="sd">                lclic same x</span>
<span class="sd">                rclic same y</span>
<span class="sd">                cclic free point</span>

<span class="sd">        segment edition</span>

<span class="sd">            [0-f] - display one of the 16 first layers</span>
<span class="sd">            x : save structure</span>
<span class="sd">            o : toggle overlay</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ednodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;subsegnb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ticksoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1">#self.af = SelectL2(self,fig=fig,ax=ax)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">af</span> <span class="o">=</span> <span class="n">SelectL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cid1</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;button_press_event&#39;</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="o">.</span><span class="n">OnClick</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cid2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;button_release_event&#39;</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="o">.</span><span class="n">OnClickRelease</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cid3</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;motion_notify_event&#39;</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="o">.</span><span class="n">OnMotion</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cid4</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;key_press_event&#39;</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="o">.</span><span class="n">OnPress</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cid5</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;key_release_event&#39;</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="o">.</span><span class="n">OnRelease</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#        # import gtk</span>
<span class="c1">#        from matplotlib.figure import Figure</span>
<span class="c1">#        from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas</span>
<span class="c1">#        from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar</span>
<span class="c1">#        from matplotlib.backend_bases import key_press_handler</span>
<span class="c1">#</span>
<span class="c1">#        win = gtk.Window()</span>
<span class="c1">#        win.show_all()</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#        win = gtk.Window()</span>
<span class="c1">#        win.connect(&quot;destroy&quot;, lambda x: gtk.main_quit())</span>
<span class="c1">#        win.set_default_size(400,300)</span>
<span class="c1">#        win.set_title(&quot;Embedding in GTK&quot;)</span>
<span class="c1">#</span>
<span class="c1">#        vbox = gtk.VBox()</span>
<span class="c1">#        win.add(vbox)</span>
<span class="c1">#</span>
<span class="c1">#        fig = Figure()</span>
<span class="c1">#        ax = fig.add_subplot(111)</span>
<span class="c1">#</span>
<span class="c1">#        fig,ax = self.showG(&#39;s&#39;,fig=fig,ax=ax)</span>
<span class="c1">#</span>
<span class="c1">#        canvas = FigureCanvas(fig)  # a gtk.DrawingArea</span>
<span class="c1">#        canvas.show()</span>
<span class="c1">#        vbox.pack_start(canvas)</span>
<span class="c1">#        toolbar = NavigationToolbar(canvas, win)</span>
<span class="c1">#        vbox.pack_start(toolbar, False, False)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#        def on_key_event(event):</span>
<span class="c1">#            print(&#39;you pressed %s&#39;%event.key)</span>
<span class="c1">#            key_press_handler(event, canvas, toolbar)</span>
<span class="c1">#</span>
<span class="c1">#        canvas.mpl_connect(&#39;key_press_event&#39;, on_key_event)</span>
<span class="c1">#</span>
<span class="c1">#        win.show_all()</span>
<span class="c1">#        gtk.main()</span>

<div class="viewcode-block" id="Layout.editorTk"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.editorTk">[docs]</a>    <span class="k">def</span> <span class="nf">editorTk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; invoke interactive layout graphical editor</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        point edition</span>

<span class="sd">            m  toggle point edition mode  (CP : Create Point)</span>

<span class="sd">                lclic same x</span>
<span class="sd">                rclic same y</span>
<span class="sd">                cclic free point</span>

<span class="sd">        segment edition</span>

<span class="sd">            [0-f] - display one of the 16 first layers</span>
<span class="sd">            x : save structure</span>
<span class="sd">            o : toggle overlay</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#import matplotlib</span>
        <span class="c1"># matplotlib.use(&#39;TkAgg&#39;)</span>

        <span class="kn">from</span> <span class="nn">matplotlib.backend_bases</span> <span class="kn">import</span> <span class="n">key_press_handler</span>
        <span class="kn">from</span> <span class="nn">matplotlib.backends.backend_tkagg</span> <span class="kn">import</span> <span class="n">FigureCanvasTkAgg</span><span class="p">,</span> <span class="n">NavigationToolbar2TkAgg</span>
        <span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">Figure</span>
        <span class="kn">import</span> <span class="nn">Tkinter</span> <span class="kn">as</span> <span class="nn">Tk</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">Tk</span><span class="o">.</span><span class="n">Tk</span><span class="p">()</span>
        <span class="n">root</span><span class="o">.</span><span class="n">wm_title</span><span class="p">(</span><span class="s1">&#39;Pylayers Layout Editor&#39;</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="c1"># ax.plot(np.arange(10))</span>

        <span class="n">canvas</span> <span class="o">=</span> <span class="n">FigureCanvasTkAgg</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">master</span><span class="o">=</span><span class="n">root</span><span class="p">)</span>
        <span class="n">canvas</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">canvas</span><span class="o">.</span><span class="n">get_tk_widget</span><span class="p">()</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">Tk</span><span class="o">.</span><span class="n">TOP</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">Tk</span><span class="o">.</span><span class="n">BOTH</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">toolbar</span> <span class="o">=</span> <span class="n">NavigationToolbar2TkAgg</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
        <span class="n">toolbar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">canvas</span><span class="o">.</span><span class="n">_tkcanvas</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">Tk</span><span class="o">.</span><span class="n">TOP</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">Tk</span><span class="o">.</span><span class="n">BOTH</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">button</span> <span class="o">=</span> <span class="n">Tk</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="n">master</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;Quit&#39;</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">)</span>
        <span class="n">button</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="n">Tk</span><span class="o">.</span><span class="n">BOTTOM</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;ednodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">select</span> <span class="o">=</span> <span class="n">SelectL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canvas</span><span class="p">)</span>

        <span class="c1"># self.af.show(clear=True)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cid1</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;button_press_event&#39;</span><span class="p">,</span> <span class="n">select</span><span class="o">.</span><span class="n">OnClick</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cid2</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="n">select</span><span class="o">.</span><span class="n">OnPress</span><span class="p">)</span>
        <span class="c1"># ax.axis(&#39;tight&#39;)</span>
        <span class="n">canvas</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">Tk</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.info"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; gives information about the Layout</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;filestr : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>
        <span class="c1"># print(&quot;filematini : &quot;, self.filematini)</span>
        <span class="c1"># print(&quot;fileslabini : &quot;, self.fileslabini)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;filegeom : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filegeom</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;geomfile (.off) has no been generated&quot;</span><span class="p">)</span>

        <span class="c1"># self.boundary()</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;boundaries &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;number of Points :&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Np</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;number of Segments :&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;number of Sub-Segments :&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nss</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gs Nodes : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gs Edges : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">())</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;no Gs graph&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gt Nodes : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gt Edges : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;vnodes = Gt.node[Nc][&#39;polyg&#39;].vnodes&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;poly = Gt.node[Nc][&#39;polyg&#39;]&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;no Gt graph&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gr Nodes    :&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Gr Edges    :&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">())</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;no Gr graph&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.facets3D"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.facets3D">[docs]</a>    <span class="k">def</span> <span class="nf">facets3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edlist</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Layer&#39;</span><span class="p">,</span> <span class="n">subseg</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        facets3d(edlist,name)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.list&#39;</span>
        <span class="n">filestruc</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRGEOM&#39;</span><span class="p">])</span>
        <span class="n">fos</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filestruc</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;LIST{</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edlist</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">facet3D</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">subseg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="s1">&#39;void&#39;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chaine</span> <span class="o">=</span> <span class="s1">&#39;{&lt;&#39;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chaine</span><span class="p">)</span>

        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="Layout.numseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.numseg">[docs]</a>    <span class="k">def</span> <span class="nf">numseg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">he</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get segment number from 2 points index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ta  : int &lt;0</span>
<span class="sd">        he  : int &lt;0</span>
<span class="sd">        first : Boolean </span>
<span class="sd">            if True returns only one among the several iso segments </span>
<span class="sd">            else returns a np.array of iso segments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        nseg : &gt; 0</span>
<span class="sd">        if 0 not a segment</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">ta</span><span class="p">))</span>
        <span class="n">nhe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">he</span><span class="p">))</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nta</span><span class="p">,</span> <span class="n">nhe</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nseg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="n">nseg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nseg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.isseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.isseg">[docs]</a>    <span class="k">def</span> <span class="nf">isseg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">he</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; test if ta&lt;-&gt;he is a segment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ta  : int &lt;0</span>
<span class="sd">        he  : int &lt;0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># transpose point numbering</span>

        <span class="n">upnt</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upnt</span><span class="p">)</span> <span class="o">==</span> <span class="n">ta</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">upnt</span><span class="p">)</span> <span class="o">==</span> <span class="n">he</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">ipdb</span>
            <span class="n">ipdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ta</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">he</span><span class="p">))</span>
                                <span class="o">|</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">he</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ta</span><span class="p">))),</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="Layout.ispoint"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.ispoint">[docs]</a>    <span class="k">def</span> <span class="nf">ispoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check if pt is a point of the Layout</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        pt  : point (2,1)</span>
<span class="sd">        tol : float</span>
<span class="sd">            default (0.05 meters)</span>

<span class="sd">        if True the point number (&lt;0) is returned</span>
<span class="sd">        else 0 is return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        pt : point number if point exists 0 otherwise</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">        pylayers.util.geomutil.Polygon.setvnodes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print&quot;ispoint : pt &quot;, pt</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">-</span> <span class="n">pt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># if all layout points are different from pt</span>
            <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nz</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span><span class="p">(</span><span class="n">ke</span><span class="p">[</span><span class="n">nup</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">nup</span><span class="p">])</span> <span class="o">==</span> <span class="n">v</span><span class="p">[</span><span class="n">nup</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span><span class="p">(</span><span class="n">ke</span><span class="p">[</span><span class="n">nup</span><span class="p">[</span><span class="n">mi</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Layout.onseg"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.onseg">[docs]</a>    <span class="k">def</span> <span class="nf">onseg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; segment number from point (deprecated)</span>

<span class="sd">        return segment number which contains point pt</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        pt  np.array(1x2)</span>
<span class="sd">        tol = 0.01      tolerance</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">T</span>   <span class="c1"># structure points</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>        <span class="c1"># point keys</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pts</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nbu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>                   <span class="c1">#</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inbox</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

            <span class="n">ta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">he</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tahe</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>

            <span class="n">nb</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

            <span class="c1"># printta</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[:,</span> <span class="n">ta</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[:,</span> <span class="n">he</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span>

            <span class="n">nv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">nv2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

            <span class="n">v1n</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">nv1</span>
            <span class="n">v2n</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">/</span> <span class="n">nv2</span>

            <span class="n">ps</span> <span class="o">=</span> <span class="n">v1n</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v2n</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">v1n</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">v2n</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">ps</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="n">nbu</span> <span class="o">=</span> <span class="n">nb</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">nbu</span></div>

<div class="viewcode-block" id="Layout.facet3D"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.facet3D">[docs]</a>    <span class="k">def</span> <span class="nf">facet3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">subseg</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate 3D facet from segment</span>


<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>

<span class="sd">        s : int</span>
<span class="sd">            segment number</span>
<span class="sd">        subseg : boolean</span>
<span class="sd">            default False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">P3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">P4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">nebr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span>
        <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span>
        <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span>
        <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span>
        <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cold</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">coldict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">subseg</span><span class="p">:</span>
            <span class="n">nsseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_name&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsseg</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;fa&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.off&#39;</span>
        <span class="n">filestruc</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRGEOM&#39;</span><span class="p">])</span>
        <span class="n">fos</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filestruc</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;OFF</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">nsseg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">nsseg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;0.000 0.000 0.000</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subseg</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_name&#39;</span><span class="p">]):</span>
                    <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P4</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;no subsegment on &#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="k">return</span><span class="p">(</span><span class="s1">&#39;void&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P4</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">subseg</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;ss_name&#39;</span><span class="p">]):</span>
                <span class="n">colname</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
                <span class="n">colhex</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.</span>
                <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;4 </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> 0.4</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span>
                                                                     <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">colname</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="n">colhex</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;4 </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> 0.4</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                                                 <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.geomfile"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.geomfile">[docs]</a>    <span class="k">def</span> <span class="nf">geomfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; create a .off geomview file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        centered : Boolean</span>
<span class="sd">            if True the layout is centered around its center of gravity</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The `.off` file can be vizualized through the show3 method</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;DLR.lay&#39;)</span>
<span class="sd">        &gt;&gt;&gt; pg = L.geomfile()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate center of gravity</span>
        <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># en  = self.Ns # number of segments</span>
        <span class="n">en</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">en</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;wrong number of segment consistency problem in layout&quot;</span><span class="p">)</span>
        <span class="c1">#cen = self.Nss</span>
        <span class="c1"># d : dictionnary of layout sub segments</span>
        <span class="c1">#</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseg</span><span class="p">()</span>
        <span class="n">cen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">lss</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cen</span> <span class="o">=</span> <span class="n">cen</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">lss</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cen</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nss</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;wrong number of subsegment consistency problem in layout&quot;</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span>
<span class="c1">#</span>
<span class="c1">#        Create a polygon for each segment and subsegment</span>
<span class="c1">#</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">P3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">P4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">ik</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dikn</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># segment</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)):</span>
                    <span class="n">nebr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">n2</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dikn</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">ik</span> <span class="o">=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">en</span> <span class="o">=</span> <span class="n">en</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># d = self.subseg()</span>
        <span class="c1"># k : ss_name v: seg number</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">subseg</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">subseg</span><span class="p">[</span><span class="n">cpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cpt</span> <span class="o">=</span> <span class="n">cpt</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">nebr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># printik,n1,n2</span>

                <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># printP1[:,ik]</span>

                <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># printP2[:,ik]</span>

                <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># printP3[:,ik]</span>

                <span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># printP4[:,ik]</span>

                <span class="n">dikn</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">ik</span> <span class="o">=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">npt</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">)</span>
        <span class="n">_filename</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">)</span>
        <span class="n">_filegeom</span> <span class="o">=</span> <span class="n">_filename</span> <span class="o">+</span> <span class="s1">&#39;.off&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filegeom</span> <span class="o">=</span> <span class="n">_filegeom</span>
        <span class="n">filegeom</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="n">_filegeom</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRGEOM&#39;</span><span class="p">])</span>
        <span class="n">fos</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filegeom</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;OFF</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">npt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">))</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;0.000 0.000 0.000</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">):</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P4</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>

        <span class="n">cold</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">coldict</span><span class="p">()</span>
<span class="c1">#        ke   = cold.keys()</span>
<span class="c1">#</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">en</span><span class="p">:</span>
                <span class="c1">#ne = i + 1</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="n">dikn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ne</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="n">dikn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">dikn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#nss = i - en</span>
                <span class="c1">##ne = subseg[nss]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ne</span><span class="p">][</span><span class="s1">&#39;ss_name&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">]</span>

<span class="c1">#            if (i&lt;en):</span>
<span class="c1">#                name = self.name[i]</span>
<span class="c1">#            else:</span>
<span class="c1">#                core = self.ce[subseg[i-en]][0]</span>
<span class="c1">#                name = sl.di[core]</span>

            <span class="n">colname</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>

            <span class="n">colhex</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.</span>
            <span class="n">fos</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;4 </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%i</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> </span><span class="si">%6.3f</span><span class="s2"> 0.4</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span> <span class="o">+</span>
                                                                 <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">fos</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pg</span></div>

    <span class="k">def</span> <span class="nf">_show3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">newfig</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">ceil_opacity</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">show_ceil</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">cyid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; mayavi 3D vizualisation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        newfig : Boolean</span>
<span class="sd">            create a new mayavi Figure</span>
<span class="sd">        opacity : float ([0,1])</span>
<span class="sd">            set slab opacity</span>
<span class="sd">        ceil_opacity : float</span>
<span class="sd">        centered : Boolean</span>
<span class="sd">            if True the layout is centered around its center of gravity</span>
<span class="sd">        cyid : boolean</span>
<span class="sd">            display cycle number</span>
<span class="sd">        show_ceil: boolean</span>
<span class="sd">            display ceil or not</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The `.off` file can be vizualized through the show3 method</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">            &gt;&gt;&gt; L = Layout()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># calculate center of gravity of the layout</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># en  = self.Ns # number of segments</span>
        <span class="n">en</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">en</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;wrong number of segment consistency problem in layout&quot;</span><span class="p">)</span>
        <span class="c1">#cen = self.Nss</span>
        <span class="c1"># d : dictionnary of layout sub segments</span>
        <span class="c1">#</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subseg</span><span class="p">()</span>
        <span class="n">cen</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">lss</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cen</span> <span class="o">=</span> <span class="n">cen</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">lss</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cen</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nss</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;wrong number of subsegment consistency problem in layout&quot;</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sl</span>
<span class="c1">#</span>
<span class="c1">#        Create a 3D polygon for each segment and subsegment</span>
<span class="c1">#</span>
        <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">P3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">P4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">ik</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dikn</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#</span>
        <span class="c1"># segments which are not _AIR or AIR</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># segment</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;AIR&#39;</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_AIR&#39;</span><span class="p">)):</span>
                    <span class="n">nebr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">n2</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                    <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">dikn</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">ik</span> <span class="o">=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">en</span> <span class="o">=</span> <span class="n">en</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># d = self.subseg()</span>
        <span class="c1"># k : ss_name v: seg number</span>
        <span class="n">cpt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">subseg</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">subseg</span><span class="p">[</span><span class="n">cpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cpt</span> <span class="o">=</span> <span class="n">cpt</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">nebr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="n">nebr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># printik,n1,n2</span>

                <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># printP1[:,ik]</span>

                <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># printP2[:,ik]</span>

                <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># printP3[:,ik]</span>

                <span class="n">P4</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n1</span><span class="p">])</span> <span class="o">-</span> <span class="n">pg</span>
                <span class="n">P4</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ids</span><span class="p">][</span><span class="s1">&#39;ss_z&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># printP4[:,ik]</span>

                <span class="n">dikn</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">ik</span> <span class="o">=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">npt</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">)</span>
        <span class="n">npt_s</span> <span class="o">=</span> <span class="p">(</span><span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">P1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">npt_s</span><span class="p">],</span> <span class="n">P2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">npt_s</span><span class="p">]))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">P3</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">npt_s</span><span class="p">]))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">P4</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">npt_s</span><span class="p">]))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span>

        <span class="n">boxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">npt</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npt</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>

        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">npt_s</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">npt_s</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">npt_s</span>

<span class="c1">#         _filename,ext = os.path.splitext(self._filename)</span>
<span class="c1">#         _filegeom = _filename+&#39;.off&#39;</span>
<span class="c1">#         self.filegeom=_filegeom</span>
<span class="c1">#         filegeom = pyu.getlong(_filegeom, pro.pstruc[&#39;DIRGEOM&#39;])</span>
<span class="c1">#         fos = open(filegeom, &quot;w&quot;)</span>
<span class="c1">#         fos.write(&quot;OFF\n&quot;)</span>
<span class="c1">#         fos.write(&quot;%d %d \n\n&quot; % (npt + 1, en + cen))</span>
<span class="c1">#         fos.write(&quot;0.000 0.000 0.000\n&quot;)</span>
<span class="c1">#         for i in range(en + cen):</span>
<span class="c1">#             fos.write(&quot;%6.3f %6.3f %6.3f \n&quot; % (P1[0, i], P1[1, i], P1[2, i]))</span>
<span class="c1">#             fos.write(&quot;%6.3f %6.3f %6.3f \n&quot; % (P2[0, i], P2[1, i], P2[2, i]))</span>
<span class="c1">#             fos.write(&quot;%6.3f %6.3f %6.3f \n&quot; % (P3[0, i], P3[1, i], P3[2, i]))</span>
<span class="c1">#             fos.write(&quot;%6.3f %6.3f %6.3f \n&quot; % (P4[0, i], P4[1, i], P4[2, i]))</span>

        <span class="n">cold</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">coldict</span><span class="p">()</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">cen</span> <span class="o">+</span> <span class="n">en</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">en</span> <span class="o">+</span> <span class="n">cen</span><span class="p">):</span>
            <span class="c1"># q = 4 * i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">en</span><span class="p">:</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="n">dikn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ne</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="n">dikn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">dikn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">ne</span><span class="p">][</span><span class="s1">&#39;ss_name&#39;</span><span class="p">][</span><span class="n">order</span><span class="p">]</span>

            <span class="n">colname</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="n">colhex</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
            <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span>
            <span class="n">color</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">npt_s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span>
            <span class="n">color</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">npt_s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span>
            <span class="n">color</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">npt_s</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">)</span>

        <span class="n">colname</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="s1">&#39;FLOOR&#39;</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
        <span class="n">colhex</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
        <span class="n">colf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">color</span><span class="p">,</span> <span class="n">colf</span><span class="p">))</span>

        <span class="c1"># trick for correcting  color assignement</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">UnsignedCharArray</span><span class="p">()</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

        <span class="c1"># manage floor</span>

        <span class="c1"># if Gt doesn&#39;t exists</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">coorddeter</span><span class="p">()</span>
            <span class="c1"># z=np.ones(self.ma.xy.shape[1])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

            <span class="n">tri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="n">meshf</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tri</span><span class="p">]))</span>

            <span class="n">meshf</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">sc</span>
            <span class="n">meshf</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>

            <span class="n">surff</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">meshf</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">)</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">extract_edges</span><span class="p">(</span><span class="n">surff</span><span class="p">),</span>
                                  <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">)</span>

        <span class="c1"># otherwise</span>
        <span class="k">except</span><span class="p">:</span>

            <span class="n">floorx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="n">floory</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">Pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">floorx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">floory</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zmin</span><span class="p">])</span>
            <span class="n">Pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Pf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">floorx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">floory</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zmin</span><span class="p">])))</span>
            <span class="n">Pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Pf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">floorx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">floory</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zmin</span><span class="p">])))</span>
            <span class="n">Pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Pf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">floorx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">floory</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zmin</span><span class="p">])))</span>

            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">Pf</span><span class="p">))</span>
            <span class="n">bf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">boxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">boxes</span><span class="p">,</span> <span class="n">bf</span><span class="p">))</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="n">boxes</span><span class="p">)</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">sc</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>

        <span class="k">if</span> <span class="n">newfig</span><span class="p">:</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">bgcolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">background</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">disable_render</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">surf</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">)</span>
        <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">extract_edges</span><span class="p">(</span><span class="n">surf</span><span class="p">),</span>
                              <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Layout &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>

        <span class="k">if</span> <span class="n">show_ceil</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">uin</span> <span class="o">=</span> <span class="p">[</span><span class="n">kn</span> <span class="k">for</span> <span class="n">kn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">kn</span><span class="p">]</span>
                       <span class="p">[</span><span class="s1">&#39;indoor&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">]</span>

                <span class="n">ptc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">boxc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">cpt</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">uin</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span>
                    <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;polyg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">vnodes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">no</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">40000000</span><span class="p">:</span>
                            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">break</span>
                    <span class="n">vert</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;vertices&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">}</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">vert</span><span class="p">)</span>
                    <span class="n">nbpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">])</span>
                    <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;vertices&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbpt</span><span class="p">))</span>
                    <span class="n">box</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="s1">&#39;triangles&#39;</span><span class="p">]</span>

                    <span class="c1"># if u == 114:</span>
                    <span class="c1">#     import ipdb</span>
                    <span class="c1">#     ipdb.set_trace()</span>
                    <span class="c1">#     box = np.roll(box,1,1)</span>
                    <span class="n">ptc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ptc</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
                    <span class="n">boxc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">boxc</span><span class="p">,</span> <span class="n">box</span> <span class="o">+</span> <span class="n">cpt</span><span class="p">))</span>
                    <span class="n">cpt</span> <span class="o">=</span> <span class="n">cpt</span> <span class="o">+</span> <span class="n">nbpt</span>
                    <span class="c1"># if box.shape[0] == 2 :</span>
                    <span class="c1">#     import ipdb</span>
                    <span class="c1">#     ipdb.set_trace()</span>
                    <span class="c1">#     print(cpt,nbpt)</span>
                    <span class="c1">#     print(box)</span>
                    <span class="c1">#     print(pt)</span>
                    <span class="c1">#     break</span>

                <span class="c1"># manage Ceil color</span>

                <span class="n">colname</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="s1">&#39;CEIL&#39;</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
                <span class="n">colhex</span> <span class="o">=</span> <span class="n">cold</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
                <span class="n">colf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">pyu</span><span class="o">.</span><span class="n">rgb</span><span class="p">(</span><span class="n">colhex</span><span class="p">))[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">cpt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># color = np.vstack((color, colf))</span>
                <span class="n">color</span><span class="o">=</span><span class="n">colf</span>

                <span class="c1"># trick for correcting  color assignement</span>

                <span class="n">sc</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">UnsignedCharArray</span><span class="p">()</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

                <span class="n">meshc</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">ptc</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="n">boxc</span><span class="p">)</span>
                <span class="n">meshc</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">sc</span>
                <span class="n">meshc</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
                <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span>
                    <span class="n">meshc</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="n">ceil_opacity</span><span class="p">,</span> <span class="n">reset_zoom</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                <span class="c1"># ptc =</span>

                <span class="c1"># ptcxy = np.array([self.Gt.node[u][&#39;polyg&#39;].exterior.xy[0],self.Gt.node[u][&#39;polyg&#39;].exterior.xy[1]])</span>
                <span class="c1"># ptcz = [self.Gs.node[self.Gt.node[u][&#39;polyg&#39;].vnodes[1]][&#39;z&#39;][1]]*len(self.Gt.node[u][&#39;polyg&#39;].exterior.xy[0])</span>
                <span class="c1"># ptc = np.vstack((ptcxy,ptcz))</span>
                <span class="c1"># nbpt = ptc.shape[1]</span>
                <span class="c1"># pdb</span>
                <span class="c1"># ceil = tvtk.PolyData(points=ptc.T, polys=np.arange(nbpt).reshape(1,nbpt))</span>
                <span class="c1"># surf2 = mlab.pipeline.surface(ceil, opacity=opacity)</span>
                <span class="c1"># import ipdb</span>
                <span class="c1"># ipdb.set_trace()</span>

        <span class="k">if</span> <span class="n">cyid</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="p">[</span><span class="n">mlab</span><span class="o">.</span><span class="n">text3d</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pk</span><span class="p">)]</span>
        <span class="c1"># if segpt:</span>

        <span class="c1">#     seg = dict(filter(lambda x: x[0]&gt;0,self.Gs.pos.items()))</span>
        <span class="c1">#     pt = dict(filter(lambda x: x[0]&lt;0,self.Gs.pos.items()))</span>
        <span class="c1">#     pseg = np.array(seg.values())</span>
        <span class="c1">#     ppt = np.array(pt.values())</span>
        <span class="c1">#     [mlab.text3d(pseg[ik,0],pseg[ik,1],0.5,str(k)) for ik,k in enumerate(seg)]</span>
        <span class="c1">#     [mlab.text3d(ppt[ik,0],ppt[ik,1],3.,str(k)) for ik,k in enumerate(pt)]</span>

        <span class="n">f</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">disable_render</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<div class="viewcode-block" id="Layout.show3"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.show3">[docs]</a>    <span class="k">def</span> <span class="nf">show3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bdis</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; geomview display of the indoor structure</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bdis boolean (default True)</span>
<span class="sd">            boolean display (call geowview if True)</span>
<span class="sd">        centered : boolean</span>
<span class="sd">            if True center the layout before display</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geomfile</span><span class="p">(</span><span class="n">centered</span><span class="o">=</span><span class="n">centered</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">pyu</span><span class="o">.</span><span class="n">getlong</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filegeom</span><span class="p">,</span> <span class="n">pro</span><span class="o">.</span><span class="n">pstruc</span><span class="p">[</span><span class="s1">&#39;DIRGEOM&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bdis</span><span class="p">):</span>
            <span class="c1">#chaine = &quot;geomview -nopanel -b 1 1 1 &quot; + filename + &quot; 2&gt;/dev/null &amp;&quot;</span>
            <span class="n">chaine</span> <span class="o">=</span> <span class="s2">&quot;geomview  -b 1 1 1 &quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot; 2&gt;/dev/null &amp;&quot;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">chaine</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.signature"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.signature">[docs]</a>    <span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iTx</span><span class="p">,</span> <span class="n">iRx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determine signature between node iTx and node iRx</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        cy1  : int</span>
<span class="sd">            source cycle</span>
<span class="sd">        cy2  : int</span>
<span class="sd">            target cycle</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sigarr    :</span>
<span class="sd">        signature :</span>


<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This a temporary function</span>
<span class="sd">            There is some algorithmic work to find the best way to determine signature</span>
<span class="sd">            T4 : limit the ndt to only edges and nodes in visibility from Tx</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Here we take all the vnodes &gt;0  from the room</span>
        <span class="c1">#</span>
        <span class="c1"># Practically those list of nodes should depend on pTx , pRx</span>
        <span class="c1">#</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gi</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="s1">&#39;Interaction graph layout.Gi must be build before signature computation&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iTx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">NroomTx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt2ro</span><span class="p">(</span><span class="n">iTx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iTx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">NroomTx</span> <span class="o">=</span> <span class="n">iTx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;iTx must be an array or a room number&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iRx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">NroomRx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt2ro</span><span class="p">(</span><span class="n">iRx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iRx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">NroomRx</span> <span class="o">=</span> <span class="n">iRx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;iRx must be an array or a room number&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">NroomTx</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">NroomRx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Tx or Rx is not in Gr&#39;</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># .. todo:: modifier inter afin de ne pas retenir les points non diffractants</span>
        <span class="c1">#</span>
        <span class="n">ndt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">NroomTx</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]][</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span>
        <span class="n">ndr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gt</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gr</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">NroomRx</span><span class="p">][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]][</span><span class="s1">&#39;inter&#39;</span><span class="p">]</span>
        <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">ndt</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="n">ndr</span><span class="p">:</span>
                <span class="n">addpath</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">nr</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span>
                        <span class="n">addpath</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c1"># print&#39;no path between &#39;,nt,nr</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">nt</span> <span class="o">!=</span> <span class="n">nr</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gi</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span>
                        <span class="n">addpath</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                        <span class="c1"># print&#39;no path between &#39;,nt,nr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">addpath</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">nt</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">addpath</span><span class="p">:</span>
                    <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])))</span>
                    <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="n">it</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])))</span>
                        <span class="k">elif</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sigarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sigarr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">it</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])))</span>

        <span class="k">return</span> <span class="n">sigarr</span></div>

<div class="viewcode-block" id="Layout.plot"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; plot the layout with shapely polygons</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>

<span class="sd">        fig </span>
<span class="sd">        ax </span>
<span class="sd">        labels : list</span>
<span class="sd">        nodes : boolean</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; L= Layout(&#39;Munich.lay&#39;,bbuild=False)</span>
<span class="sd">        &gt;&gt;&gt; L.plot(show=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;fig&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="p">[],</span>
                    <span class="s1">&#39;nodes&#39;</span><span class="p">:</span> <span class="bp">False</span>
                    <span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="n">kk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kk</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">vv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vv</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">vv</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vv</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ML</span> <span class="o">=</span> <span class="n">sh</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shseg</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pltlines</span><span class="p">(</span><span class="n">ML</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Layout.get_Sg_pos"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.get_Sg_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_Sg_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigarr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return position of the signatures</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sigarr : signature</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">sigarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sposfull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">signature</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">signature</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">sposfull</span><span class="p">[</span><span class="n">iz</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">spos</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">sposfull</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.plot_segments"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.plot_segments">[docs]</a>    <span class="k">def</span> <span class="nf">plot_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lns</span>
<span class="sd">        *kwargs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;show&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                    <span class="s1">&#39;fig&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
                    <span class="s1">&#39;ax&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
                    <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fig&#39;</span><span class="p">]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span>

        <span class="n">nth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">lns</span><span class="p">))</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="n">nth</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">nh</span> <span class="o">=</span> <span class="n">nth</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># pt : 2 x Ns</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
                          <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">nt</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># ph : 2 x Ns</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
                          <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">nh</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plu</span><span class="o">.</span><span class="n">displot</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Layout.showSig"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.showSig">[docs]</a>    <span class="k">def</span> <span class="nf">showSig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigarr</span><span class="p">,</span> <span class="n">Tx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Rx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="p">[],</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Show signature</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tx  : np.array (2,1)</span>
<span class="sd">                Transmitter coordinates</span>
<span class="sd">        Rx  : np.array (2,1)</span>
<span class="sd">                Receipter coordinates</span>
<span class="sd">        sr  : boolean</span>
<span class="sd">                show room signature</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig   : figure instance</span>
<span class="sd">        ax    : axes instance</span>
<span class="sd">        lines : lines instance</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sigarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fig</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Sg_pos</span><span class="p">(</span><span class="n">sigarr</span><span class="p">)</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="n">nz</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">Tx</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">itx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">nz</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">itx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">itx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">itx2</span><span class="p">]</span>
            <span class="n">tx</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">),</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Tx</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">Rx</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">irx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">nz</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">irx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">irx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">irx2</span><span class="p">]</span>
            <span class="n">rx</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rx</span><span class="p">),</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Rx</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span></div>
<span class="c1">#        lines=[]</span>
<span class="c1">#        for s in sig:</span>
<span class="c1">#            l=[self.Gs.pos[s[ii]] for ii in xrange(len(s))]</span>
<span class="c1">#            if Tx!=None and Rx!=None:</span>
<span class="c1">#                l.insert(0,Tx)</span>
<span class="c1">#                l.insert(-1,Rx)</span>
<span class="c1">#            ls=sh.LineString(l)</span>
<span class="c1">#            x,y=ls.xy</span>
<span class="c1">#            lines.extend(ax.plot(x,y,&#39;k&#39;,lw=0.1,alpha=0.2))</span>
<span class="c1">#        return (fig,ax,lines)</span>

<span class="c1">#    def distwall(self, p, nroom):</span>
<span class="c1">#        &quot;&quot;&quot; calculate distance to wall</span>
<span class="c1">#</span>
<span class="c1">#        Parameters</span>
<span class="c1">#        ----------</span>
<span class="c1">#</span>
<span class="c1">#        p : ndarray</span>
<span class="c1">#            point coordinate</span>
<span class="c1">#</span>
<span class="c1">#        nroom : int</span>
<span class="c1">#            room number of p</span>
<span class="c1">#</span>
<span class="c1">#        Returns</span>
<span class="c1">#        -------</span>
<span class="c1">#</span>
<span class="c1">#        dist</span>
<span class="c1">#                list of distances to walls of room nroom</span>
<span class="c1">#</span>
<span class="c1">#        Notes</span>
<span class="c1">#        -----</span>
<span class="c1">#</span>
<span class="c1">#        Return  dist a list of all the distances to the walls of a room</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        pp = sh.Point(p[0], p[1])</span>
<span class="c1">#</span>
<span class="c1">#        dist = []</span>
<span class="c1">#        p0_xy = []</span>
<span class="c1">#        p1_xy = []</span>
<span class="c1">#</span>
<span class="c1">#        vnode = self.Gr.node[nroom][&#39;cycle&#39;].cycle</span>
<span class="c1">#</span>
<span class="c1">#        # for j in range(len(Gr[nroom][&#39;vnodes&#39;])):</span>
<span class="c1">#        for j in range(len(vnodes)):</span>
<span class="c1">#            nn = self.b_Gr[5][&#39;vnodes&#39;][j]</span>
<span class="c1">#            nta = G1.tahe[0, nn - 1]</span>
<span class="c1">#            nhe = G1.tahe[1, nn - 1]</span>
<span class="c1">#            p0 = np.array([G1.pt[0, nta], G1.pt[1, nta]])</span>
<span class="c1">#            p1 = np.array([G1.pt[0, nhe], G1.pt[1, nhe]])</span>
<span class="c1">#            p0_xy.insert(j, p0)</span>
<span class="c1">#            p1_xy.insert(j, p1)</span>
<span class="c1">#</span>
<span class="c1">#        pstartwll = np.array(p0_xy)</span>
<span class="c1">#        pfinwll = np.array(p1_xy)</span>
<span class="c1">#</span>
<span class="c1">#        for i in range(len(self.b_Gr[nroom][&#39;vnodes&#39;])):</span>
<span class="c1">#            line_wall = sh.LineString([(pstartwll[i, 0],</span>
<span class="c1">#                                        pstartwll[i, 1]), (pfinwll[i, 0], pfinwll[i, 1])])</span>
<span class="c1">#            dist.insert(i, line_wall.distance(pp))</span>
<span class="c1">#        return(dist)</span>

<div class="viewcode-block" id="Layout.randTxRx"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.randTxRx">[docs]</a>    <span class="k">def</span> <span class="nf">randTxRx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns random coordinates for Tx and Rx.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        p_Tx : numpy.ndarray</span>
<span class="sd">             A point of the placement of the Tx</span>
<span class="sd">        p_Rx : numpy.ndarray</span>
<span class="sd">             A point of the placement of the Rx</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;defstr.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p_Tx,p_Rx = L.randTxRx()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            ex fn Tx_Rx_pos</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># self.boundary()</span>

        <span class="n">Tx_x</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Tx_y</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">Rx_x</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Rx_y</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">p_Tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Tx_x</span><span class="p">,</span> <span class="n">Tx_y</span><span class="p">])</span>
        <span class="n">p_Rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Rx_x</span><span class="p">,</span> <span class="n">Rx_y</span><span class="p">])</span>

        <span class="k">return</span><span class="p">(</span><span class="n">p_Tx</span><span class="p">,</span> <span class="n">p_Rx</span><span class="p">)</span></div>

<div class="viewcode-block" id="Layout.boundary"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.boundary">[docs]</a>    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percx</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">percy</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(),</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add a blank boundary around layout</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        percx : float</span>
<span class="sd">            percentage of Dx for x offset calculation (default 0.15)</span>
<span class="sd">        percy : float</span>
<span class="sd">           percentage of Dy for y offset calculation (default 0.15)</span>

<span class="sd">        self.lboundary is the list of the nodes of the added boundary</span>
<span class="sd">        self.axn is the zone without the boundary extension</span>
<span class="sd">        self.ax  is updated</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pylayers.gis.layout import *</span>
<span class="sd">        &gt;&gt;&gt; L = Layout(&#39;defstr.ini&#39;)</span>
<span class="sd">        &gt;&gt;&gt; L.boundary()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasboundary</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">xlim</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">20.</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="mf">20.</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10.</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="mf">10.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="n">Dx</span> <span class="o">=</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span>
            <span class="n">Dy</span> <span class="o">=</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">Dx</span> <span class="o">*</span> <span class="n">percx</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">Dy</span> <span class="o">*</span> <span class="n">percy</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">((</span><span class="n">xmin</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">((</span><span class="n">xmax</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">-</span> <span class="n">dy</span><span class="p">))</span>
            <span class="n">n3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">((</span><span class="n">xmax</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">+</span> <span class="n">dy</span><span class="p">))</span>
            <span class="n">n4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_fnod</span><span class="p">((</span><span class="n">xmin</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">+</span> <span class="n">dy</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lboundary</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">n4</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">ns1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>
            <span class="n">ns2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>
            <span class="n">ns3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n3</span><span class="p">,</span> <span class="n">n4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>
            <span class="n">ns4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_segment</span><span class="p">(</span><span class="n">n4</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_AIR&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segboundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns4</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">axn</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">-</span> <span class="n">dy</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;box&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hasboundary</span> <span class="o">=</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="Layout.off_overlay"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.off_overlay">[docs]</a>    <span class="k">def</span> <span class="nf">off_overlay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; offset overlay image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        dx : float</span>
<span class="sd">        dy : float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="Layout.scl_overlay"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.scl_overlay">[docs]</a>    <span class="k">def</span> <span class="nf">scl_overlay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ay</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; scale overlay image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ax : float</span>
<span class="sd">        ay : float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ax</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">ay</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">ay</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">[</span><span class="s1">&#39;overlay_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="Layout.get_paths"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.Layout.html#pylayers.gis.layout.Layout.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nd_in</span><span class="p">,</span> <span class="n">nd_fin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; returns the possible paths of graph Gs between two nodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            nd_in: int</span>
<span class="sd">                initial graph node (segment or point)</span>
<span class="sd">            nd_fin: int</span>
<span class="sd">                final graph node (segment or point)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            paths : list</span>
<span class="sd">                paths between nd_in and nd_fin</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="n">gph</span><span class="o">.</span><span class="n">find_all_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gs</span><span class="p">,</span> <span class="n">nd_in</span><span class="p">,</span> <span class="n">nd_fin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span></div></div>


<div class="viewcode-block" id="outputGi_func_test"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.outputGi_func_test.html#pylayers.gis.layout.outputGi_func_test">[docs]</a><span class="k">def</span> <span class="nf">outputGi_func_test</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="n">k</span>
    <span class="k">return</span> <span class="n">y</span></div>

<div class="viewcode-block" id="outputGi_func"><a class="viewcode-back" href="../../../api/pylayers.gis.layout.outputGi_func.html#pylayers.gis.layout.outputGi_func">[docs]</a><span class="k">def</span> <span class="nf">outputGi_func</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="c1"># def outputGi_func(e, Gi_no, Gi_A, Gspos, sgsg, s2pc, s2pu):</span>
       

    <span class="c1"># for k in range(10000):</span>
    <span class="c1">#     y = k*k</span>
    <span class="c1">#     # time.sleep(0.01)</span>
    <span class="c1"># return y</span>

    <span class="k">def</span> <span class="nf">Gspos</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#return np.mean(s2pc[n].reshape(2,2),axis=0)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s2pc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p2pc</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>

    <span class="n">e</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#Gi_no = args[1]</span>
    <span class="c1">#Gi_A = args[2]</span>
    <span class="c1">#p2pc = args[3]</span>
    <span class="c1">#sgsg = args[4]</span>
    <span class="c1">#s2pc = args[5]</span>
    <span class="c1">#s2pu = args[6]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>



    <span class="n">i0</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nstr0</span> <span class="o">=</span> <span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nstr1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># list of authorized outputs. Initialized void</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># nstr1 : segment number of central interaction</span>
    <span class="k">if</span> <span class="n">nstr1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># central interaction is a segment</span>
        <span class="c1"># pseg1 = self.s2pc[nstr1,:].toarray().reshape(2, 2).T</span>
        <span class="n">pseg1</span> <span class="o">=</span> <span class="n">s2pc</span><span class="p">[</span><span class="n">nstr1</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># pseg1 = self.s2pc[nstr1,:].data.reshape(2, 2).T</span>
        <span class="c1"># pseg1o = self.seg2pts(nstr1).reshape(2, 2).T</span>

        <span class="c1"># create a Cone object</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">Cone</span><span class="p">()</span>
        <span class="c1"># if starting from segment</span>
        <span class="k">if</span> <span class="n">nstr0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># pseg0 = self.s2pc[nstr0,:].toarray().reshape(2, 2).T</span>
            <span class="n">pseg0</span> <span class="o">=</span> <span class="n">s2pc</span><span class="p">[</span><span class="n">nstr0</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># pseg0 = self.s2pc[nstr0,:].data.reshape(2, 2).T</span>
            <span class="c1"># pseg0o = self.seg2pts(nstr0).reshape(2, 2).T</span>

            <span class="c1"># if nstr0 and nstr1 are connected segments</span>
            <span class="k">if</span> <span class="n">sgsg</span><span class="p">[</span><span class="n">nstr0</span><span class="p">,</span><span class="n">nstr1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># from 2 not connected segment</span>
                <span class="n">cn</span><span class="o">.</span><span class="n">from2segs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># from 2 connected segments</span>
                <span class="n">cn</span><span class="o">.</span><span class="n">from2csegs</span><span class="p">(</span><span class="n">pseg0</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>
        <span class="c1"># if starting from a point</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">nstr0</span><span class="p">)</span>
            <span class="n">cn</span><span class="o">.</span><span class="n">fromptseg</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">)</span>

        <span class="c1"># list all potential successors of interaction i1</span>
        <span class="n">ui2</span> <span class="o">=</span> <span class="n">Gi_no</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>
        <span class="n">ui</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Gi_A</span><span class="p">[</span><span class="n">ui2</span><span class="p">,:]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gi_no</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ui</span><span class="p">]</span>
        <span class="c1"># i2 = nx.neighbors(self.Gi, i1)</span>

        <span class="c1"># how to find neighbors without network</span>
        <span class="c1"># ngi=L.Gi.nodes()</span>
        <span class="c1"># A=nx.adjacency_matrix(L.Gi)</span>
        <span class="c1"># inter = ngi[10]</span>
        <span class="c1"># u = ngi.index(inter)</span>
        <span class="c1"># ui = A[u,:].indices</span>
        <span class="c1"># neigh_inter = np.array([ngi[u] for u in ui])</span>


        <span class="n">ipoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">]</span>
        <span class="c1">#ipoints = filter(lambda x: len(x) == 1, i2)</span>
        <span class="n">pipoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Gspos</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">ipoints</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># filter tuple (R | T)</span>
        <span class="c1">#istup = filter(lambda x : type(eval(x))==tuple,i2)</span>
        <span class="c1"># map first argument segment number</span>
        <span class="c1">#isegments = np.unique(map(lambda x : eval(x)[0],istup))</span>
        <span class="c1"># isegments = np.unique(</span>
        <span class="c1">#     filter(lambda y: y &gt; 0, map(lambda x: x[0], i2)))</span>
        <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># if nstr0 and nstr1 are adjescent segment remove nstr0 from</span>
        <span class="c1"># potential next interaction</span>
        <span class="c1"># Fix 01/2017</span>
        <span class="c1"># This is not always True if the angle between </span>
        <span class="c1"># the two adjascent segments is &lt; pi/2</span>
        <span class="c1"># nb_nstr0 = self.Gs.neighbors(nstr0)</span>
        <span class="c1"># nb_nstr1 = self.Gs.neighbors(nstr1)</span>
        <span class="c1"># nb_nstr0 = np.array([self.s2pu[nstr0,0],self.s2pu[nstr0,1]])</span>
        <span class="c1"># nb_nstr1 = np.array([self.s2pu[nstr1,0],self.s2pu[nstr1,1]])</span>
        <span class="n">nb_nstr0</span> <span class="o">=</span> <span class="n">s2pu</span><span class="p">[</span><span class="n">nstr0</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nb_nstr1</span> <span class="o">=</span> <span class="n">s2pu</span><span class="p">[</span><span class="n">nstr1</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;nb_nstr0&#39;</span><span class="p">,</span><span class="n">nb_nstr0</span><span class="p">)</span>
        <span class="c1">#nb_nstr0 = s2pu[nstr0,:]</span>
        <span class="c1">#nb_nstr1 = s2pu[nstr1,:]</span>
        <span class="c1"># common_point = np.intersect1d(nb_nstr0,nb_nstr1)</span>
        <span class="n">common_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr0</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr1</span><span class="p">])</span>
        <span class="c1"># if len(common_point) == 1:</span>
        <span class="k">if</span> <span class="n">common_point</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">num0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">common_point</span><span class="p">]</span>
            <span class="n">num1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nb_nstr1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">common_point</span><span class="p">]</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">num0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">num1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pc</span> <span class="o">=</span> <span class="n">Gspos</span><span class="p">(</span><span class="n">common_point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">p0</span><span class="o">-</span><span class="n">pc</span> 
            <span class="n">v1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-</span><span class="n">pc</span> 
            <span class="n">v0n</span> <span class="o">=</span> <span class="n">v0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span><span class="o">*</span><span class="n">v0</span><span class="p">))</span>
            <span class="n">v1n</span> <span class="o">=</span> <span class="n">v1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">v1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0n</span><span class="p">,</span><span class="n">v1n</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">isegments</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">nstr0</span> <span class="p">])</span> 
            <span class="c1">#    filter(lambda x: x != nstr0, isegments))</span>
        <span class="c1"># there are one or more segments</span>
        <span class="c1"># if len(isegments) &gt; 0:</span>
        <span class="k">if</span> <span class="n">isegments</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

            <span class="n">li1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>

            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s2pc</span><span class="p">[</span><span class="n">isegments</span><span class="p">,:]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
            <span class="c1">#points = s2pc[isegments,:].T</span>
            <span class="c1"># points = self.s2pc[isegments,:].data.reshape(4,len(isegments))</span>
            <span class="c1"># pointso = self.seg2pts(isegments)</span>

            <span class="n">pta</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">phe</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># add difraction points</span>
            <span class="c1"># WARNING Diffraction points are added only if a segment is seen</span>
            <span class="c1"># it should be the case in 99% of cases</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ipoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">isegments</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ipoints</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="n">pta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pta</span><span class="p">,</span> <span class="n">pipoints</span><span class="p">))</span>
                <span class="n">phe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">phe</span><span class="p">,</span> <span class="n">pipoints</span><span class="p">))</span>

            <span class="c1"># cn.show()</span>

            <span class="c1"># if i0 == (38,79) and i1 == (135,79,23):</span>
            <span class="c1">#     printi0,i1</span>
            <span class="c1">#     import ipdb</span>
            <span class="c1">#     ipdb.set_trace()</span>
            <span class="c1"># i1 : interaction T</span>
            <span class="k">if</span> <span class="n">li1</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">typ</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span> <span class="n">phe</span><span class="p">)</span>
                <span class="c1"># if bs.any():</span>
                <span class="c1">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                <span class="c1"># if ~bs.any():</span>
                <span class="c1">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;k&#39;)</span>

            <span class="c1"># i1 : interaction R --&gt; mirror</span>
            <span class="k">elif</span> <span class="n">li1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">Mpta</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">pta</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Mphe</span> <span class="o">=</span> <span class="n">geu</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">phe</span><span class="p">,</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pseg1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">typ</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">cn</span><span class="o">.</span><span class="n">belong_seg</span><span class="p">(</span><span class="n">Mpta</span><span class="p">,</span> <span class="n">Mphe</span><span class="p">)</span>
                <span class="c1"># printi0,i1</span>
                <span class="c1"># if ((i0 == (6, 0)) &amp; (i1 == (7, 0))):</span>
                <span class="c1">#    pdb.set_trace()</span>
                <span class="c1"># if bs.any():</span>
                <span class="c1">#    plu.displot(pta[:,bs],phe[:,bs],color=&#39;g&#39;)</span>
                <span class="c1"># if ~bs.any():</span>
                <span class="c1">#    plu.displot(pta[:,~bs],phe[:,~bs],color=&#39;m&#39;)</span>
                <span class="c1">#    plt.show()</span>
                <span class="c1">#    pdb.set_trace())</span>
            <span class="c1">########</span>
            <span class="c1"># SOMETIMES PROBA IS 0 WHEREAS SEG IS SEEN</span>
            <span class="c1">###########</span>
            <span class="c1"># # keep segment with prob above a threshold</span>
            <span class="c1"># isegkeep = isegments[prob&gt;0]</span>
            <span class="c1"># # dict   {numint : proba}</span>
            <span class="c1"># dsegprob = {k:v for k,v in zip(isegkeep,prob[prob&gt;0])}</span>
            <span class="c1"># 4 lines are replaced by</span>
            <span class="c1"># keep segment with prob above a threshold</span>
            <span class="n">utypseg</span> <span class="o">=</span> <span class="n">typ</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="n">isegkeep</span> <span class="o">=</span> <span class="n">isegments</span><span class="p">[</span><span class="n">utypseg</span><span class="p">]</span>
            <span class="c1"># dict   {numint : proba}</span>
            <span class="n">dsegprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isegkeep</span><span class="p">,</span> <span class="n">prob</span><span class="p">[</span><span class="n">utypseg</span><span class="p">])}</span>
            <span class="c1">#########</span>
            <span class="c1"># output = filter(lambda x: x[0] in isegkeep, i2)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i2</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isegkeep</span><span class="p">]</span>
            <span class="c1"># probint = map(lambda x: dsegprob[x[0]], output)</span>
            <span class="n">probint</span> <span class="o">=</span> <span class="p">[</span><span class="n">dsegprob</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>
            <span class="c1"># dict interaction : proba</span>
            <span class="n">dintprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">probint</span><span class="p">)}</span>

            <span class="c1"># keep all segment above nstr1 and in Cone if T</span>
            <span class="c1"># keep all segment below nstr1 and in Cone if R</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># central interaction is a point</span>

        <span class="c1"># 1) Simple approach</span>
        <span class="c1">#       output interaction are all visible interactions</span>
        <span class="c1"># 2) TO BE DONE</span>
        <span class="c1">#</span>
        <span class="c1">#       output of the diffraction points</span>
        <span class="c1">#       exploring</span>
        <span class="c1"># b</span>
        <span class="c1">#          + right of ISB</span>
        <span class="c1">#          + right of RSB</span>
        <span class="c1">#</span>
        <span class="c1">#  + using the wedge cone</span>
        <span class="c1">#  + using the incident cone</span>
        <span class="c1">#</span>

        <span class="c1"># output = nx.neighbors(self.Gi, (nstr1,))</span>
        <span class="n">uout</span> <span class="o">=</span> <span class="n">Gi_no</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">nstr1</span><span class="p">,))</span>
        <span class="n">ui</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Gi_A</span><span class="p">[</span><span class="n">uout</span><span class="p">,:]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gi_no</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ui</span><span class="p">]</span>

        <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="n">probint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nout</span><span class="p">)</span>  <span class="c1"># temporarybns</span>
        <span class="n">dintprob</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">probint</span><span class="p">)}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span><span class="n">dintprob</span><span class="p">})</span></div>
    <span class="c1"># self.Gi.add_edge(i0, i1, output=dintprob)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
    <span class="c1"># L = Layout(&#39;Servon Sur Vilaine&#39;,verbose=True,dist_m=60)</span>
    <span class="c1"># L.build()    </span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Nov 13, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>